/*
** Copyright (c) 1990, 2001 Actian Corporation
** All Rights Reserved
*/

#include    <compat.h>
#include    <gl.h>
#include    <tm.h>
#include    <tmtz.h>
#include    <st.h>
#include    <me.h>
#include    <cm.h>
#include    <cv.h>
#include    <dbms.h>
#include    <descrip.h>
#include    <ssdef.h>
#include    <adf.h>
#include    <add.h>
#include    <adudate.h>
#include    "gwrmsdt.h"
#include    "gwrmsdtmap.h"
#include    "gwrmserr.h"

/**
**
**  Name: GWRMSCVR.C - Routines to convert various INGRES types to RMS types
**
**  Description:
**      This file contains routines to implement coercions necessary to
**	convert INGRES data values to RMS data values.
**
**          rms_rintcvt - Convert INGRES types to RMS signed integer
**          rms_runscvt - Convert INGRES types to RMS unsigned integer
**          rms_rfltcvt - Convert INGRES types to g_float or h_float
**          rms_rdtecvt - Convert INGRES types to VAX date
**          rms_rstrcvt - Convert INGRES types to null- or blank-padded string
**          rms_rdeccvt - Convert INGRES types to decimal string types
**
**
**  History:
**      18-apr-90 (jrb)
**	    Created.
**	7-sep-90 (linda)
**	    Added support for "trailing separate numeric" datatype.  This type
**	    is a string type, one byte per ascii digit, with a separate sign
**	    byte at the end.  It is generated by COBOL PIC statements.  Its
**	    internal type definition is RMSGW_TRL_NUM.
**      18-may-92 (schang)
**          GW merge.
**	    25-sep-91 (rickh)
**	        Strings are not necessarily null terminated.  Assuming that they
**	        were caused the conversion of strings to integers to blow up.
**	        Correct the overflow detection for coercions into RMS i4s and
**	        for coercions into signed octawords.
**      17-dec-1992 (schang)
**          prototype
**      30-mar-1993 (schang)
**          decimal support in.  Also add support for negative time zone
**      24-aug-93 (ed)
**          added missing includes
**      30-jul-96 (schang) 6.4 fix in
**        22-mar-93 (schang)
**          When convert from GMT time to local time, don't forget do it for
**          negative ii_timezone
**	  24-jan-94 (jimg)
**	    Fix for bug#57399, conversion of Ingres date datatype to VMS date.
**	    See detailed comments at routine "rms_rdtecvt()" ahead.
**      03-mar-1999 (chash01)
**          integrate all changes since ingres 6.4.
**      mar-11-2000 (chash01)
**          remove the restriction of 19xx year limit
**      apr-03-2000 (chash01)
**          encode last three digits of a year, not 2
**	28-feb-2001	(kinte01)
**	    Bug 103393 - removed nat, longnat, u_nat, & u_longnat
**	    from RMS GW code as the use is no longer allowed
**      22-dec-2008 (stegr01)
**          Itanium VMS port.
**	16-Jun-2009 (thich01)
**	    Treat GEOM type the same as LBYTE.
**	20-Aug-2009 (thich01)
**	    Treat all spatial types the same as LBYTE.
**      25-dec-2009 (stegr01)
**          replace ALPHA and IA64 by axm_vms and i64_vms
[@history_template@]...
**/


/*
**  Forward and/or External function references.
*/

FUNC_EXTERN DB_STATUS	rms_dterr();		    /* datatype error */
FUNC_EXTERN VOID	rms_intcmpl();		    /* complement integer */
FUNC_EXTERN DB_STATUS	rms_octashift();	    /* shift and add octaword */
FUNC_EXTERN DB_STATUS	rms_straddr();		    /* get address of string */

/* These are all simple functions written in MACRO to take advantage of VAX
** instructions not available in C.
*/
#if (!defined(axm_vms) && !defined(i64_vms))
FUNC_EXTERN VOID	rms_mcvt_g_l();
FUNC_EXTERN VOID	rms_mcvt_h_l();
FUNC_EXTERN VOID	rms_mcvt_l_g();
FUNC_EXTERN VOID	rms_mcvt_l_h();
FUNC_EXTERN VOID	rms_mcvt_f_g();
FUNC_EXTERN VOID	rms_mcvt_f_h();
FUNC_EXTERN VOID	rms_mcvt_d_h();
FUNC_EXTERN VOID	rms_mcvt_d_g();
FUNC_EXTERN VOID	rms_mcvt_p_s();
FUNC_EXTERN VOID	rms_mcvt_p_t();
#endif
GLOBALREF   RMS_ADFFI_CVT   Rms_adffi_arr[];
/*
[@function_reference@]...
[@#defines_of_other_constants@]
[@type_definitions@]
[@global_variable_definitions@]
[@static_variable_or_function_definitions@]
*/

/*{
** Name: cvt_f2s - Convert ffloat to sfloat (axp specific type)
** 
** Description:
**      This routine convert ffloat (vax type) to sfloat (axp type),
**      treating sfloat as an arry of bytes.
**
** Inputs:
**      src                        ffloat (f4) data.
**
** Outputs:
**      dst                        sfloat in character type
** 
** Returns:
**      E_DB_OK
**      E_DB_ERROR
**
** Side Effects:
**      None.
**
** History:
**     sep-02-1997 (chash01) created
*/

static STATUS cvt_f2s (f4 src, char *dst)
{
    u_i2 exponent = 0;
    char tmpsrc[4];

    /*
    ** VAX floating point exponent is in excess 128 form,
    ** S-floating point exponent is in excess 127 form.
    ** need to make this conversion.
    */
    MEcopy((char *)&src, 4, tmpsrc);
    exponent = tmpsrc[1] & 0x7F;
    exponent--;
    tmpsrc[1] = tmpsrc[1] & 0x80;
    tmpsrc[1] = tmpsrc[1] | exponent;

    MEcopy((PTR)&tmpsrc, 2, dst+2);
    MEcopy((PTR)(&tmpsrc)+2, 2, dst);

    return(E_DB_OK);
}

/*{
** Name: cvt_d2t - Convert dfloat to tfloat (axp specific type)
** 
** Description:
**      This routine convert dfloat (vax type) to tfloat (axp type),
**      treating dfloat as an arry of bytes.
**
** Inputs:
**      src                        dfloat (f8) data.
**
** Outputs:
**      dst                        tfloat in character type
** 
** Returns:
**      E_DB_OK
**      E_DB_ERROR
**
** Side Effects:
**      None.
**
** History:
**     sep-02-1997 (chash01) created
*/

static STATUS cvt_d2t (f8 src, PTR dst)
{
    struct dsc$descriptor  srcdsc;
    struct dsc$descriptor  dstdsc;
    char gform[8], 
         *tmpgform = &gform;       /* for debugging */
    STATUS cond;
    i4     len;
    unsigned short   exponent;
    
    /*
    ** first convert to a g_floating then do the MEcopy's
    */
    srcdsc.dsc$a_pointer = &src;
    srcdsc.dsc$b_class = DSC$K_CLASS_S;
    srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;

    dstdsc.dsc$a_pointer = (PTR)gform;
    dstdsc.dsc$b_class = DSC$K_CLASS_S;
    dstdsc.dsc$b_dtype = DSC$K_DTYPE_G;
    cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
    /*
    ** now manipulate the exponent before copying
    ** to the t-floating
    */
    exponent=gform[1] & 0x007F;
    exponent = (exponent << 8) | (gform[0] & 0x00F0);
    exponent = exponent >> 5;
    exponent--;
    exponent = exponent << 5;
    gform[1] = (gform[1] & 0x0080) | (exponent >> 8);
    exponent = exponent & 0x00F0;
    gform[0] = (gform[0] & 0x001F) | exponent;
   
    MEcopy ((PTR)&gform, 2, dst+6);
    MEcopy (((PTR)&gform)+2, 2, dst+4);
    MEcopy (((PTR)&gform)+4, 2, dst+2);
    MEcopy (((PTR)&gform)+6, 2, dst);
    
    return(E_DB_OK);
}

/*{
** Name: cvt_d2s - Convert dfloat to sfloat (axp specific type)
** 
** Description:
**      This routine convert dfloat (vax type) to sfloat (axp type),
**      treating sfloat as an arry of bytes.  Loss of precision is
**      expected, but not reported.
**
** Inputs:
**      src                        dfloat (f8) data.
**
** Outputs:
**      dst                        address of sfloat 
** 
** Returns:
**      E_DB_OK
**      E_DB_ERROR
**
** Side Effects:
**      None.
**
** History:
**     sep-02-1997 (chash01) created
*/

static STATUS cvt_d2s (f8 src, PTR dst)
{
    char tmpsrc[4];
    u_i2 exponent;

    MEcopy ((PTR)&src, 4, &tmpsrc);
    exponent = tmpsrc[1] & 0x7F;
    exponent--;
    tmpsrc[1] = tmpsrc[1] & 0x80;
    tmpsrc[1] = tmpsrc[1] | exponent;

    MEcopy((PTR)&tmpsrc, 2, dst+2);
    MEcopy((PTR)(&tmpsrc)+2, 2, dst);
    return(E_DB_OK);
}

/*{
** Name: rms_rintcvt - Convert INGRES types to RMS signed integer
**
** Description:
**	This routine takes a variety of INGRES data values and converts them
**	to RMS signed integer type.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	18-apr-90 (jrb)
**	    Created.
**	25-sep-91 (rickh)
**	    Strings are not necessarily null terminated.  Assuming that they
**	    were caused the conversion of strings to integers to blow up.
**	    Correct the overflow detection for coercions into RMS i4s and
**	    for coercions into signed octawords.
**      30-mar-1993 (schang)
**          decimal support in.
**      21-mar-2000 (chash01)
**          remove yewar 2000 limit
*/

#define	I4_SIGN_FILL	0xffffffff
#define	I4_SIGN_BIT	0x80000000

DB_STATUS
rms_rintcvt
(
    ADF_CB	  *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    STATUS	    stat;
    i4		    temp;
    RMS_OCTAWORD    ow;
    bool	    overflow = FALSE;
    bool	    smallint = TRUE;

    switch (indv->db_datatype)
    {
      case DB_INT_TYPE:
      {
	switch (indv->db_length)
	{
	  case 1:
	    temp = I1_CHECK_MACRO(*(i1 *)indv->db_data);
	    break;

	  case 2:
	    temp = *(i2 *)indv->db_data;
	    break;
	    
	  case 4:
	    temp = *(i4 *)indv->db_data;
	    break;
	}
	break;
      }

      case DB_DEC_TYPE:
      {
        char buff1[40], buff2[40], buff3[40], buff4[40], buff5[40];
        bool negative = FALSE;
        u_i2 sixteen_bit[8];
        i4   p, s, i;
        i4   binary_int;
        char *numerator, *denominator, *quotient, *remainder, *inter;

        /*
        ** converting from Ingres decimal type to rms integer,
        ** always assume result is a big one; determine the
        ** real result size later
        */
	ow.octa_chunk[0] = 0;
	ow.octa_chunk[1] = 0;
	ow.octa_chunk[2] = 0;
	ow.octa_chunk[3] = 0;

        /*
        ** first, take the integer part of this decimal and 
        ** convert to (31,0)
        */

	MHpkint(indv->db_data, DB_P_DECODE_MACRO(indv->db_prec),
		DB_S_DECODE_MACRO(indv->db_prec), buff1);
        CVpkpk(buff1, DB_P_DECODE_MACRO(indv->db_prec),
	        DB_S_DECODE_MACRO(indv->db_prec), 31, 0, buff2);
        MHpkabs(buff2, 31, 0, buff1);
        if (MHpkcmp(buff1, 31, 0, buff2, 31, 0))
            negative = TRUE;

        /*
        ** we now have a positive decimal number in buff1,
        ** for each iteration, convert into binary
        */
        CVlpk(65536,31,0,buff2);
        numerator = buff1;
        denominator = buff2;
        quotient = buff3;
        remainder = buff5;
        for (i = 0; i < 8; i++)
        {
          MHpkdiv(numerator, 31, 0, denominator, 31, 0, quotient, &p, &s);
          MHpkmul(quotient, 31, 0, denominator, 31, 0, buff4, &p, &s);
          MHpksub(numerator, 31, 0, buff4, 31, 0, remainder, &p, &s);
          CVpkl(remainder, 31, 0, &binary_int);
          sixteen_bit[i] = binary_int & 0x0000ffff;
          inter = numerator; 
          numerator = quotient;
          quotient = inter;
        }
                
	ow.octa_chunk[0] = sixteen_bit[0] | 
                                 ((sixteen_bit[1] << 16) & 0xffff0000);
	ow.octa_chunk[1] = sixteen_bit[2] | 
                                 ((sixteen_bit[3] << 16) & 0xffff0000);
	ow.octa_chunk[2] = sixteen_bit[4] | 
                                 ((sixteen_bit[5] << 16) & 0xffff0000);
	ow.octa_chunk[3] = sixteen_bit[6] | 
                                 ((sixteen_bit[7] << 16) & 0xffff0000);
        if (negative)
        {
            u_i4 carry = 1;

	    ow.octa_chunk[0] = ~ow.octa_chunk[0];
	    ow.octa_chunk[1] = ~ow.octa_chunk[1];
	    ow.octa_chunk[2] = ~ow.octa_chunk[2];
	    ow.octa_chunk[3] = ~ow.octa_chunk[3];

            ow.octa_chunk[0] = (unsigned long)ow.octa_chunk[0] + carry;
            if (ow.octa_chunk[0] == 0)
                carry = 1;
            else
                carry = 0;

            ow.octa_chunk[1] = (unsigned long)ow.octa_chunk[1] + carry;
            if ((ow.octa_chunk[1] == 0) && carry)
                carry = 1;
            else
                carry = 0;

            ow.octa_chunk[2] = (unsigned long)ow.octa_chunk[2] + carry;
            if ((ow.octa_chunk[2] == 0) && carry)
                carry = 1;
            else
                carry = 0;

            ow.octa_chunk[3] = (unsigned long)ow.octa_chunk[3] + carry;
        }
        /*
        ** now we get gigantic binary integer in ow, we want to find out
        ** just how big is this number
        */
        if (((ow.octa_chunk[3]==0) && 
                   (ow.octa_chunk[2]==0) && (ow.octa_chunk[1]==0)) ||
            ((ow.octa_chunk[3]==-1) &&
                   (ow.octa_chunk[2]==-1) && (ow.octa_chunk[1]==-1)))
        {
            temp = ow.octa_chunk[0];
            smallint = TRUE;
        }
        else 
            smallint = FALSE;
        break;
      }

      case DB_FLT_TYPE:
      case DB_MNY_TYPE:		/* we cheat here: we know money's an f8 */
      {
	f8		ftemp;
	bool		isneg = FALSE;
	char		buf[50];
	i2		res_width;
	char		*p;
	RMS_OCTAWORD	ow1;

	switch (indv->db_length)
	{
	  case 4:
	    ftemp = *(f4 *)indv->db_data;
	    break;

	  case 8:
	    ftemp = *(f8 *)indv->db_data;
	    break;
	}

	/* for money it's the number of cents; divide by 100 to get dollars */
	if (indv->db_datatype == DB_MNY_TYPE)
	    ftemp /= 100.0;

	if (ftemp >= MINI4  &&  ftemp <= MAXI4)
	{
	    temp = ftemp;
	    break;
	}

	/* we'll have to go to an octaword representation to hold this number */
	smallint = FALSE;
	ow1.octa_chunk[0] = 0;
	ow1.octa_chunk[1] = 0;
	ow1.octa_chunk[2] = 0;
	ow1.octa_chunk[3] = 0;

	if (ftemp < 0.0)
	{
	    ftemp = -ftemp;
	    isneg = TRUE;
	}

	_VOID_ CVfa(ftemp, 40, 0, 'f', '.', buf, &res_width);

	/* now buf contains ascii representation of ftemp as an integer;
	** convert to octaword
	*/
	for (p=buf; *p != EOS; p++)
	{
	    if (rms_octashift(&ow1, *p-'0') != E_DB_OK)
		overflow = TRUE;
	}

	if (isneg)
	    rms_intcmpl(&ow1, 4, &ow);
	else
	    STRUCT_ASSIGN_MACRO(ow1, ow);

	break;
      }

      case DB_VCH_TYPE:
      case DB_CHA_TYPE:
      case DB_TXT_TYPE:
      case DB_CHR_TYPE:
      {
	char		*p, *endp;
	i4		len;
	bool		isneg = FALSE;

	rms_straddr(indv, &p);
	rms_strcount(indv, &len);
	endp = p + len - 1;

	while (CMwhite(p))
	    p++;
	while (endp > p  &&  CMwhite(endp))
	    endp--;

	/* if length (endp-p+1) <= 9 then we know the number will fit in an
	** i4; otherwise it may need to go into a larger number
	*/
	if (endp - p < 9)
	{
	    char	buf[10];

	    MEcopy(p, (endp - p + 1), buf);
	    buf[endp - p + 1] = EOS;

	    if (CVal(buf, &temp) != OK)
		return(rms_dterr(scb, E_GW7012_BAD_STR_TO_INT, 1, 0, buf));
	}
	else
	{
	    RMS_OCTAWORD	ow1;
	    
	    smallint = FALSE;
	    ow1.octa_chunk[0] = 0;
	    ow1.octa_chunk[1] = 0;
	    ow1.octa_chunk[2] = 0;
	    ow1.octa_chunk[3] = 0;

	    if (*p == '-')
	    {
		isneg = TRUE;
		p++;
	    }

	    for (; p <= endp; p++)
	    {
		if (!CMdigit(p))
		{
		    return(rms_dterr(scb, E_GW7012_BAD_STR_TO_INT, 1,
								endp-p+1, p));
		}

		if (rms_octashift(&ow1, *p-'0') != E_DB_OK)
		    overflow = TRUE;
	    }

	    /* check for overflow on octaword conversions */

	    if ( ( outdv->db_length == 16 )
	      && ( ow1.octa_chunk[ 3 ] & I4_SIGN_BIT ) )
	    {
		if ( isneg ) 
		{	/* only allow the most negative number allowed */
		    if ( ( ow1.octa_chunk[ 3 ] != I4_SIGN_BIT )
		      || (   ow1.octa_chunk[2]
			   | ow1.octa_chunk[1]
			   | ow1.octa_chunk[0] != 0 ) )
		        overflow = TRUE;
		}
		else overflow = TRUE;
	    }

	    if (isneg)
		rms_intcmpl(&ow1, 4, &ow);
	    else
		STRUCT_ASSIGN_MACRO(ow1, ow);
	}
        break;
      }

      case DB_DTE_TYPE:
      {
	/* Note: If a date being converted to an integer has a timespec, we
	** ignore it.
        ** chash01 03-21-2000 : remove year 2000 limitation
	*/
	AD_DATENTRNL	*dp = indv->db_data;

	/* Note: Here we make dependencies on the various date formats; this
	** is bad.  Only ADF should know what input formats are available for
	** each date format.  Eventually a solution to this problem should be
	** found; perhaps a new entry point into ADF which would return this
	** information?  In the meantime, whenever there is a new date format
	** added to ADF which does not have the mmddyy input format, it must
	** be added to this list.
	*/
	if (scb->adf_dfmt == DB_ISO_DFMT)
	{
	    temp =	(dp->dn_year - 1900) * 10000
		    +	dp->dn_month * 100
		    +	dp->dn_lowday;
	}
	else if (scb->adf_dfmt == DB_GERM_DFMT)
	{
	    temp =	dp->dn_lowday * 100000
		    +	dp->dn_month * 1000
		    +	dp->dn_year - 1900;
	}
	else
	{
	    temp =	dp->dn_month * 100000
		    +	dp->dn_lowday * 1000
		    +	dp->dn_year - 1900;
	}
	break;
      }
    }

    /* now we have a representation of the destination integer in temp if
    ** smallint is TRUE, else we have it in ow
    */
    if (smallint)
    {
	switch (outdv->db_length)
	{
	  case 1:
	    if (temp > MAXI1  ||  temp < MINI1)
		overflow = TRUE;
	    *(i1 *)outdv->db_data = temp;
	    break;

	  case 2:
	    if (temp > MAXI2  ||  temp < MINI2)
		overflow = TRUE;
	    *(i2 *)outdv->db_data = temp;
	    break;
	
	  case 4:
	    *(i4 *)outdv->db_data = temp;
	    break;
    
	  case 8:
	  {
	    RMS_QUADWORD	*qp = outdv->db_data;

	    qp->quad_chunk[0] = temp;
	    if (temp < 0)
		qp->quad_chunk[1] = 0xffffffff;
	    else
		qp->quad_chunk[1] = 0;
	    break;
	  }
    
	  case 16:
	  {
	    RMS_OCTAWORD	*op = outdv->db_data;

	    op->octa_chunk[0] = temp;
	    if (temp < 0)
	    {
		op->octa_chunk[1] = 0xffffffff;
		op->octa_chunk[2] = 0xffffffff;
		op->octa_chunk[3] = 0xffffffff;
	    }
	    else
	    {
		op->octa_chunk[1] = 0;
		op->octa_chunk[2] = 0;
		op->octa_chunk[3] = 0;
	    }
	    break;
	  }
	}
    }
    else
    {
	switch (outdv->db_length)
	{
	  case 1:
	    overflow = TRUE;
	    *(i1 *)outdv->db_data = ow.octa_chunk[0];
	    break;

	  case 2:
	    overflow = TRUE;
	    *(i2 *)outdv->db_data = ow.octa_chunk[0];
	    break;

	  case 4:

	    temp = ow.octa_chunk[ 0 ];
	    if (temp >= 0)
	    {
		if ( ( ow.octa_chunk[3]
		     | ow.octa_chunk[2]
		     | ow.octa_chunk[1] ) != 0 )
		    overflow = TRUE;
	    }
	    else
	    {
		if ( ( ow.octa_chunk[3]
		     & ow.octa_chunk[2]
		     & ow.octa_chunk[1] ) != I4_SIGN_FILL )
		    overflow = TRUE;
	    }

	    *(i4 *)outdv->db_data = ow.octa_chunk[0];
	    break;

	  case 8:
	  {
	    RMS_QUADWORD	*qp = outdv->db_data;
	    
	    temp = ow.octa_chunk[1];
	    if (temp >= 0)
	    {
		if ((ow.octa_chunk[3] | ow.octa_chunk[2]) != 0)
		    overflow = TRUE;
	    }
	    else
	    {
		if ((ow.octa_chunk[3] & ow.octa_chunk[2]) != 0xffffffff)
		    overflow = TRUE;
	    }
	    qp->quad_chunk[1] = temp;
	    qp->quad_chunk[0] = ow.octa_chunk[0];
	    break;
	  }

          case 16:
	  {
	    RMS_OCTAWORD	*op = outdv->db_data;

	    op->octa_chunk[0] = ow.octa_chunk[0];
	    op->octa_chunk[1] = ow.octa_chunk[1];
	    op->octa_chunk[2] = ow.octa_chunk[2];
	    op->octa_chunk[3] = ow.octa_chunk[3];
	    break;
	  }
	}
    }

    if (overflow)
	return(rms_dterr(scb, E_GW7000_INTEGER_OVF, 1, 4, &outdv->db_length));

    return(E_DB_OK);
}


/*{
** Name: rms_runscvt - Convert INGRES types to RMS unsigned integer
**
** Description:
**	This routine takes a variety of INGRES data values and converts them
**	to RMS unsigned integer type.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	19-apr-90 (jrb)
**	    Created.
**	25-sep-91 (rickh)
**	    Strings are not necessarily null terminated.  Assuming that they
**	    were caused the conversion of strings to integers to blow up.
**	    Correct the overflow detection for coercions into RMS i4s and
**	    for coercions into signed octawords.
**	27-sep-91 (rickh)
**	    Correct overflow detection for conversions into unsigned bytes
**	    and words.
**      30-mar-1993 (schang)
**          decimal support in.
**      03-21-2000 (chash01)
**          remove year 2000 limitation
*/

#define	MAX_UNSIGNED_BYTE	0xFF
#define	MAX_UNSIGNED_WORD	0xFFFF

DB_STATUS
rms_runscvt
(
    ADF_CB	   *scb,
    DB_DATA_VALUE  *indv,
    DB_DATA_VALUE  *outdv
)
{
    STATUS	    stat;
    i4		    temp;
    u_i4	    utemp;
    RMS_OCTAWORD    ow;
    bool	    overflow = FALSE;
    bool	    smallint = TRUE;

    switch (indv->db_datatype)
    {
      case DB_INT_TYPE:
      {
	switch (indv->db_length)
	{
	  case 1:
	    temp = I1_CHECK_MACRO(*(i1 *)indv->db_data);
	    break;

	  case 2:
	    temp = *(i2 *)indv->db_data;
	    break;
	    
	  case 4:
	    temp = *(i4 *)indv->db_data;
	    break;
	}
	if (temp < 0)
	    overflow = TRUE;
	utemp = temp;
	break;
      }
      case DB_DEC_TYPE:
      {
        char buff1[40], buff2[40], buff3[40], buff4[40], buff5[40];
        u_i2 sixteen_bit[8];
        i4   p, s, i;
        i4   binary_int;
        char *numerator, *denominator, *quotient, *remainder, *inter;


        /*
        ** first, find out if the integer value is negative.  We do not
        ** convert negative value into RMS unsigned value.  Only positive,
        ** thus UNSIGNED, ingres value is converted.
        */
        MHpkabs(indv->db_data, DB_P_DECODE_MACRO(indv->db_prec),
		DB_S_DECODE_MACRO(indv->db_prec), buff1);
        if (MHpkcmp(indv->db_data,
                    DB_P_DECODE_MACRO(indv->db_prec),
		    DB_S_DECODE_MACRO(indv->db_prec),
                    buff1,
                    DB_P_DECODE_MACRO(indv->db_prec),
		    DB_S_DECODE_MACRO(indv->db_prec)))
        {
            return(rms_dterr(scb, E_GW702C_DATA_INCOMPAT, 0));
        }

        /*
        ** converting from Ingres decimal type to rms integer,
        ** always assume result is a big one; determine the
        ** real result size later
        */
	ow.octa_chunk[0] = 0;
	ow.octa_chunk[1] = 0;
	ow.octa_chunk[2] = 0;
	ow.octa_chunk[3] = 0;

        /*
        ** first, take the integer part of this decimal and 
        ** convert to (31,0)
        */

	MHpkint(indv->db_data, DB_P_DECODE_MACRO(indv->db_prec),
		DB_S_DECODE_MACRO(indv->db_prec), buff2);
        CVpkpk(buff2, DB_P_DECODE_MACRO(indv->db_prec),
		DB_S_DECODE_MACRO(indv->db_prec), 31, 0, buff1);
        /*
        ** for each iteration, convert 16 bits into binary
        */
        CVlpk(65536,31,0,buff2);
        numerator = buff1;
        denominator = buff2;
        quotient = buff3;
        remainder = buff5;
        for (i = 0; i < 8; i++)
        {
          MHpkdiv(numerator, 31, 0, denominator, 31, 0, quotient, &p, &s);
          MHpkmul(quotient, 31, 0, denominator, 31, 0, buff4, &p, &s);
          MHpksub(numerator, 31, 0, buff4, 31, 0, remainder, &p, &s);
          CVpkl(remainder, 31, 0, &binary_int);
          sixteen_bit[i] = binary_int & 0x0000ffff;
          inter = numerator; 
          numerator = quotient;
          quotient = inter;
        }
                
	ow.octa_chunk[0] = sixteen_bit[0] | 
                                 ((sixteen_bit[1] << 16) & 0xffff0000);
	ow.octa_chunk[1] = sixteen_bit[2] | 
                                 ((sixteen_bit[3] << 16) & 0xffff0000);
	ow.octa_chunk[2] = sixteen_bit[4] | 
                                 ((sixteen_bit[5] << 16) & 0xffff0000);
	ow.octa_chunk[3] = sixteen_bit[6] | 
                                 ((sixteen_bit[7] << 16) & 0xffff0000);
        /*
        ** now we get gigantic binary integer in ow, we want to find out
        ** just how big is this number and we don't take negative number
        */
        if ((ow.octa_chunk[1]==0) && 
                   (ow.octa_chunk[2]==0) && (ow.octa_chunk[1]==0))
        {
            utemp = ow.octa_chunk[0];
            smallint = TRUE;
        }
        else 
            smallint = FALSE;
        break;
      }

      case DB_FLT_TYPE:
      case DB_MNY_TYPE:		/* we cheat here: we know money's an f8 */
      {
	f8		ftemp;
	char		buf[50];
	i2		res_width;
	char		*p;

	switch (indv->db_length)
	{
	  case 4:
	    ftemp = *(f4 *)indv->db_data;
	    break;

	  case 8:
	    ftemp = *(f8 *)indv->db_data;
	    break;
	}

	/* for money it's the number of cents; divide by 100 to get dollars */
	if (indv->db_datatype == DB_MNY_TYPE)
	    ftemp /= 100.0;

	if (ftemp < 0.0)
	{
	    utemp = 0;
	    overflow = TRUE;
	    break;
	}

	if (ftemp <= MAXI4)
	{
	    utemp = ftemp;
	    break;
	}

	/* we'll have to go to an octaword representation to hold this number */
	smallint = FALSE;
	ow.octa_chunk[0] = 0;
	ow.octa_chunk[1] = 0;
	ow.octa_chunk[2] = 0;
	ow.octa_chunk[3] = 0;

	_VOID_ CVfa(ftemp, 40, 0, 'f', '.', buf, &res_width);

	/* now buf contains ascii representation of ftemp as an integer;
	** convert to octaword
	*/
	for (p=buf; *p != EOS; p++)
	{
	    if (rms_octashift(&ow, *p-'0') != E_DB_OK)
		overflow = TRUE;
	}
	break;
      }

      case DB_VCH_TYPE:
      case DB_CHA_TYPE:
      case DB_TXT_TYPE:
      case DB_CHR_TYPE:
      {
	char		*p, *endp;
	i4		len;
	bool		isneg = FALSE;

	rms_straddr(indv, &p);
	rms_strcount(indv, &len);
	endp = p + len - 1;

	while (CMwhite(p))
	    p++;
	while (endp > p  &&  CMwhite(endp))
	    endp--;

	/* if length (endp-p+1) <= 9 then we know the number will fit in an
	** i4; otherwise it may need to go into a larger number
	*/
	if (endp - p < 9)
	{
	    char	buf[10];

	    MEcopy(p, (endp - p + 1), buf);
	    buf[endp - p + 1] = EOS;

	    if (CVal(buf, &temp) != OK)
		return(rms_dterr(scb, E_GW7012_BAD_STR_TO_INT, 1, 0, buf));

	    utemp = temp;
	    if (temp < 0)
		overflow = TRUE;
	}
	else
	{
	    smallint = FALSE;
	    ow.octa_chunk[0] = 0;
	    ow.octa_chunk[1] = 0;
	    ow.octa_chunk[2] = 0;
	    ow.octa_chunk[3] = 0;

	    if (*p == '-')
	    {
		overflow = TRUE;
		p++;
	    }
	    
	    for (; p <= endp; p++)
	    {
		if (!CMdigit(p))
		{
		    return(rms_dterr(scb, E_GW7012_BAD_STR_TO_INT, 1,
								endp-p+1, p));
		}

		if (rms_octashift(&ow, *p-'0') != E_DB_OK)
		    overflow = TRUE;
	    }
	}
        break;
      }

      case DB_DTE_TYPE:
      {
	/* Note: If a date being converted to an integer has a timespec, we
	** ignore it.
        ** chash01 03-21-2000 : remove year 2000 limitation
	*/
	AD_DATENTRNL	*dp = indv->db_data;

	/* Note: Here we make dependencies on the various date formats; this
	** is bad.  Only ADF should know what input formats are available for
	** each date format.  Eventually a solution to this problem should be
	** found; perhaps a new entry point into ADF which would return this
	** information?  In the meantime, whenever there is a new date format
	** added to ADF which does not have the mmddyy input format, it must
	** be added to this list.
	*/
	if (scb->adf_dfmt == DB_ISO_DFMT)
	{
	    utemp =	(dp->dn_year - 1900) * 10000
		    +	dp->dn_month * 100
		    +	dp->dn_lowday;
	}
	else if (scb->adf_dfmt == DB_GERM_DFMT)
	{
	    utemp =	dp->dn_lowday * 100000
		    +	dp->dn_month * 1000
		    +	dp->dn_year - 1900;
	}
	else
	{
	    utemp =	dp->dn_month * 100000
		    +	dp->dn_lowday * 1000
		    +	dp->dn_year - 1900;
	}
	break;
      }
    }

    /* now we have a representation of the destination integer in utemp if
    ** smallint is TRUE, else we have it in ow
    */
    if (smallint)
    {
	switch (outdv->db_length)
	{
	  case 1:
	    if (utemp > MAX_UNSIGNED_BYTE )
		overflow = TRUE;
	    *(u_i1 *)outdv->db_data = utemp;
	    break;

	  case 2:
	    if (utemp > MAX_UNSIGNED_WORD )
		overflow = TRUE;
	    *(u_i2 *)outdv->db_data = utemp;
	    break;
	
	  case 4:
	    *(u_i4 *)outdv->db_data = utemp;
	    break;
    
	  case 8:
	  {
	    RMS_QUADWORD	*qp = outdv->db_data;

	    qp->quad_chunk[0] = utemp;
	    qp->quad_chunk[1] = 0;
	    break;
	  }
    
	  case 16:
	  {
	    RMS_OCTAWORD	*op = outdv->db_data;

	    op->octa_chunk[0] = utemp;
	    op->octa_chunk[1] = 0;
	    op->octa_chunk[2] = 0;
	    op->octa_chunk[3] = 0;
	    break;
	  }
	}
    }
    else
    {
	switch (outdv->db_length)
	{
	  case 1:
	    overflow = TRUE;
	    *(u_i1 *)outdv->db_data = ow.octa_chunk[0];
	    break;

	  case 2:
	    overflow = TRUE;
	    *(u_i2 *)outdv->db_data = ow.octa_chunk[0];
	    break;

	  case 4:

	    if ( ( ow.octa_chunk[3]
		 | ow.octa_chunk[2]
		 | ow.octa_chunk[1] ) != 0)
		overflow = TRUE;

	    *(u_i4 *)outdv->db_data = ow.octa_chunk[0];
	    break;

	  case 8:
	  {
	    RMS_QUADWORD	*qp = outdv->db_data;
	    
	    utemp = ow.octa_chunk[1];
	    if ((ow.octa_chunk[3] | ow.octa_chunk[2]) != 0)
		overflow = TRUE;

	    qp->quad_chunk[1] = utemp;
	    qp->quad_chunk[0] = ow.octa_chunk[0];
	    break;
	  }

          case 16:
	  {
	    RMS_OCTAWORD	*op = outdv->db_data;

	    op->octa_chunk[0] = ow.octa_chunk[0];
	    op->octa_chunk[1] = ow.octa_chunk[1];
	    op->octa_chunk[2] = ow.octa_chunk[2];
	    op->octa_chunk[3] = ow.octa_chunk[3];
	    break;
	  }
	}
    }

    if (overflow)
	return(rms_dterr(scb, E_GW7000_INTEGER_OVF, 1, 4, &outdv->db_length));

    return(E_DB_OK);
}


/*{
** Name: rms_rfltcvt - Convert INGRES types to RMS floats (g_float or h_float)
**
** Description:
**	This routine takes a variety of INGRES data values and converts them
**	to RMS floats (g_float or h_float).
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	20-apr-90 (jrb)
**	    Created.
**	9-oct-91 (rickh)
**	    Money to float was passing wrong number to g_float and h_float
**	    conversion routines.
**      30-mar-1993 (schang)
**          decimal support in.
*/
DB_STATUS
rms_rfltcvt
(
    ADF_CB	  *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    struct dsc$descriptor  srcdsc;
    struct dsc$descriptor  dstdsc;
    i4	len;
    DB_STATUS cond;

    switch (indv->db_datatype)
    {
      case DB_INT_TYPE:
      {
	i4	itemp;
        struct dsc$descriptor  srcdsc;
        struct dsc$descriptor  dstdsc;
	i4	len;
        f8      ftemp;

	switch (indv->db_length)
	{
	  case 1:
	    itemp = I1_CHECK_MACRO(*(i1 *)indv->db_data);
	    break;

	  case 2:
	    itemp = *(i2 *)indv->db_data;
	    break;
	    
	  case 4:
	    itemp = *(i4 *)indv->db_data;
	    break;
        }
        srcdsc.dsc$a_pointer = &itemp;
        srcdsc.dsc$b_class = DSC$K_CLASS_S;
        srcdsc.dsc$b_dtype = DSC$K_DTYPE_L;

        dstdsc.dsc$a_pointer = (PTR)outdv->db_data;
        dstdsc.dsc$b_class = DSC$K_CLASS_S;
        if (outdv->db_datatype != RMSGW_SFLOAT &&
             outdv->db_datatype != RMSGW_TFLOAT)
        {
            switch (outdv->db_datatype)
            {  
              case RMSGW_FFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_F;
                break;
              case RMSGW_DFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
                break;
              case RMSGW_GFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_G;
                break;
              case RMSGW_HFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_H;
                break;
            }
            cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
        }
        else
        {
            switch (outdv->db_datatype)
            {
#if defined(axm_vms) || defined(i64_vms)
              case RMSGW_SFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_FS;
                cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
                break;
              case RMSGW_TFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
                cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
                break;
#else /* VAX */
              case RMSGW_SFLOAT:
                dstdsc.dsc$a_pointer = (f4 *)&ftemp;
                dstdsc.dsc$b_class = DSC$K_CLASS_S;
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_F;
                cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
                cond = cvt_f2s(ftemp, outdv->db_data);
                break;
              case RMSGW_TFLOAT:
                dstdsc.dsc$a_pointer = (f8 *)&ftemp;
                dstdsc.dsc$b_class = DSC$K_CLASS_S;
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
                cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
                cond = cvt_d2t(ftemp, outdv->db_data);
                break;
#endif
            }
        }
        break; 
      }

      case DB_DEC_TYPE:
      {
        i4   length;
        char decimal_string[40];
	char *p;
        /*
        ** first convert to string, then convert string to
        ** different float representation based on 
        ** outdv->db_length
        */

        CVpka(indv->db_data,
              DB_P_DECODE_MACRO(indv->db_prec),
	      DB_S_DECODE_MACRO(indv->db_prec),
              0,
              39,
	      DB_S_DECODE_MACRO(indv->db_prec),
              CV_PKLEFTJUST,
              decimal_string,
              &length);

	srcdsc.dsc$w_length = length;
	srcdsc.dsc$b_dtype = DSC$K_DTYPE_T;
	srcdsc.dsc$b_class = DSC$K_CLASS_S;
	srcdsc.dsc$a_pointer = decimal_string;

        dstdsc.dsc$a_pointer = (PTR)outdv->db_data;
        dstdsc.dsc$b_class = DSC$K_CLASS_S;
        if (outdv->db_datatype != RMSGW_SFLOAT &&
            outdv->db_datatype != RMSGW_TFLOAT)
        {
            switch (outdv->db_datatype)
            {
              case RMSGW_FFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_F;
                break;
              case RMSGW_DFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
                break;
              case RMSGW_GFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_G;
                break;
              case RMSGW_HFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_H;
                break;
            }

            cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
            break;
        }
        else
        {
            f8 ftemp;
            switch (outdv->db_datatype)
            { 
#if defined(axm_vms) || defined(i64_vms)
             case RMSGW_SFLOAT:
               dstdsc.dsc$b_dtype = DSC$K_DTYPE_FS;
               cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
               break;
             case RMSGW_TFLOAT:
               dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
               cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
               break;
#else
             case RMSGW_SFLOAT:
               dstdsc.dsc$b_dtype = DSC$K_DTYPE_F;
               dstdsc.dsc$a_pointer = (f4 *)&ftemp;
               cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
               cond = cvt_f2s(ftemp, outdv->db_data);
               break;
             case RMSGW_TFLOAT:
               dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
               dstdsc.dsc$a_pointer = (f8 *)&ftemp;
               cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
               cond = cvt_d2t(ftemp, outdv->db_data);
               break;
#endif
            } 
        }
        break;
      }

      case DB_FLT_TYPE:
      {
        f8 ftemp, dbgtemp;

	switch (indv->db_length)
	{
	  case 4:
#ifdef VAX
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_F;
              ftemp = *(f4 *)indv->db_data;
#else
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_FS;
              ftemp = *(f8 *)indv->db_data;
              
#endif
              dbgtemp= *(f4 *)(indv->db_data+4);
              break;
          case 8:
#ifdef VAX
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;
#else
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
#endif
              ftemp = *(f8 *)indv->db_data;
              break;
        }

	srcdsc.dsc$b_class = DSC$K_CLASS_S;
	srcdsc.dsc$a_pointer = &ftemp;

        dstdsc.dsc$a_pointer = (PTR)outdv->db_data;
        dstdsc.dsc$b_class = DSC$K_CLASS_S;
        if ( outdv->db_datatype != RMSGW_SFLOAT &&
              outdv->db_datatype != RMSGW_TFLOAT )
        {
            switch (outdv->db_datatype)
            {
              case RMSGW_FFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_F;
                break;
              case RMSGW_DFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
                break;
              case RMSGW_GFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_G;
                break;
              case RMSGW_HFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_H;
                break;
            }
            cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
            break;
        }
        else
        {
            switch (outdv->db_datatype)
            {

#if defined(axm_vms) || defined(i64_vms)
              case RMSGW_SFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_FS;
                cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
                break;
              case RMSGW_TFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
                cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
                break;
#else
              case RMSGW_SFLOAT:
                cond = cvt_f2s((f4)ftemp, outdv->db_data);
                break;
              case RMSGW_TFLOAT:
                 cond = cvt_d2t((f8)ftemp, outdv->db_data);
                break;
#endif
            }
        }
        break;

      }
      case DB_VCH_TYPE:
      case DB_CHA_TYPE:
      case DB_TXT_TYPE:
      case DB_CHR_TYPE:
      {
	char			    *p;
	i4			    len;

	rms_straddr(indv, &p);
	rms_strcount(indv, &len);

	srcdsc.dsc$w_length = len;
	srcdsc.dsc$b_dtype = DSC$K_DTYPE_T;  /* text type */
	srcdsc.dsc$b_class = DSC$K_CLASS_S;
	srcdsc.dsc$a_pointer = p;

        dstdsc.dsc$a_pointer = (PTR)outdv->db_data;
        dstdsc.dsc$b_class = DSC$K_CLASS_S;
        if (outdv->db_datatype != RMSGW_SFLOAT &&
            outdv->db_datatype != RMSGW_TFLOAT)
        {
            switch (outdv->db_datatype)
            {
              case RMSGW_FFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_F;
                break;
              case RMSGW_DFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
                break;
              case RMSGW_GFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_G;
                break;
              case RMSGW_HFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_H;
                break;
            }

            cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
            break;
        }
        else
        {
           f8 ftemp;

           switch (outdv->db_datatype)
           { 
#if defined(axm_vms) || defined(i64_vms)
             case RMSGW_SFLOAT:
               dstdsc.dsc$b_dtype = DSC$K_DTYPE_FS;
               cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
               break;
             case RMSGW_TFLOAT:
               dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
               cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
               break;
#else
             case RMSGW_SFLOAT:
               dstdsc.dsc$b_dtype = DSC$K_DTYPE_F;
               dstdsc.dsc$a_pointer = (f4 *)&ftemp;
               cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
               cond = cvt_f2s(ftemp, outdv->db_data);
               break;
             case RMSGW_TFLOAT:
               dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
               dstdsc.dsc$a_pointer = (f8 *)&ftemp;
               cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
               cond = cvt_d2t(ftemp, outdv->db_data);
               break;
#endif
           }
        }
        break;
      }

      case DB_MNY_TYPE:		/* we cheat here: we know money's an f8 */
      {
	f8	temp;

	/* for money it's the number of cents; divide by 100 to get dollars */
	if (indv->db_datatype == DB_MNY_TYPE)
	    temp = *(f8 *)indv->db_data / 100.0;

#ifdef VAX
	srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;
#else
	srcdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
#endif
	srcdsc.dsc$b_class = DSC$K_CLASS_S;
	srcdsc.dsc$a_pointer = &temp;

        dstdsc.dsc$a_pointer = (PTR)outdv->db_data;
        dstdsc.dsc$b_class = DSC$K_CLASS_S;
        if ( outdv->db_datatype != RMSGW_SFLOAT &&
              outdv->db_datatype != RMSGW_TFLOAT )
        {
            switch (outdv->db_datatype)
            {
              case RMSGW_FFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_F;
                break;
              case RMSGW_DFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
                break;
              case RMSGW_GFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_G;
                break;
              case RMSGW_HFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_H;
                break;
            }
            cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
            break;
        }
        else
        {
            switch (outdv->db_datatype)
            {

#if defined(axm_vms) || defined(i64_vms)
              case RMSGW_SFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_FS;
                cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
                break;
              case RMSGW_TFLOAT:
                dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
                cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
                break;
#else
              case RMSGW_SFLOAT:
                cond = cvt_d2s(temp, outdv->db_data);
                break;
              case RMSGW_TFLOAT:
                 cond = cvt_d2t(temp, outdv->db_data);
                break;
#endif
            }
        }
        break;
      }
    }

    return(E_DB_OK);
}




/*{
** Name: rms_rdtecvt - Convert INGRES types to VAX date
**
** Description:
**	This routine takes a variety of INGRES data values and converts them
**	to VAX date.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	23-apr-90 (jrb)
**	    Created.
**      30-mar-1993 (schang)
**          add support for negative time zone
**	24-jan-94 (jimg)
**	    case = DB_DTE_TYPE:
**          One design issue:
**             An Ingres date without timestamp cannot be accurately converted
**             into a VAX/VMS internal format for absolute time.  The current
**             method of using a zero timestamp and not shifting to GMT is kept
**             because that at least allows such a date to appear correct when
**             entered and displayed from the same time zone. Display of such a
**             date from a different time zone will be wrong because the VAX
**             internal format does not preserve the difference between an
**             Ingres GMT date converted to a VAX local date with time=0 and an
**             Ingres date without a timespec; consequently, the companion
**             routine "rms_idtecvt()" performs Local-to-GMT shifts for all VAX
**             internal absolute time values.
**
**          Algorithm changes:
**             Re-wrote entire conversion routine for "date" with "timestamps"
**             after realizing that the caller of this routine can give us
**             "Ingres GMT" data values in negative as well as positive forms,
**             and with hour values that can exceed the natural range of [0,23].
**             Apparently, the caller -- in an attempt to avoid any handling of
**             spills out of "timestamps" and into "date"s -- simply adds to the
**             user's original (or defaulted) specification of 'hh:mm:ss':
**             1. 12 hours if 'pm' is specified,
**             2. a time zone shift that is either
**                2.1. { 8, 7, 6, 5, 4, or 0} hours for 
**		       { 'pst', 'pdt'/'mst', 'mdt'/cst', 'cdt'/'est', 'edt', or
**			 'gmt'}, respectively, OR
**                2.2. the user session's time zone value in minutes.
**
**             The algorithm now follows the same tack and keeps "time" units as
**             a composite when doing the shifts and when checking and
**             normalizing for any overflow or underflow.  Spills into the
**             "date" part of the data value is handled similar to the old
**             routine with some simplifications due to assuming a bounded range
**             on the server's time zone values (as returned by TMzone()).
**
**          Clarifications regarding use of TMzone():
**             The conversion algorithm is simplified by the fact that time zone
**             shifts are "naturally" defined within the bounds (-13,+14]
**             hours.  It is possible, however, for TMzone() to return values
**             outside of these bounds.  This can happen because the user is
**             allowed to set the II_TIMEZONE logical to values larger than
**             their natural bounds, and TMzone does no bounds checking.
**             Therefore, it is possible to break the conversion algorithms with
**             values outside the "natural" bounds.  Particularly, an
**             II_TIMEZONE value less than -546 or greater than +546 will cause
**             TMzone() to produce and return a  value near + or - 2**15.  These
**             values can cause any two-byte variable used in arithmetic
**             operations to overflow or underflow.
**
**             A decision was made NOT to check for this bound in these
**             routines.  The reasons are that performance of in-bound values
**             should not suffer a check against  exceptional values and that
**             users should be suitably constrained to set proper values for
**             II_TIMEZONE if their data is to have any natural meaning.
*/
DB_STATUS
rms_rdtecvt
(
    ADF_CB	  *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    switch (indv->db_datatype)
    {
      case DB_VCH_TYPE:
      case DB_CHA_TYPE:
      case DB_TXT_TYPE:
      case DB_CHR_TYPE:
      {
	char			    *p;
	i4			    len;
	struct dsc$descriptor	    dsc;

	rms_straddr(indv, &p);
	rms_strcount(indv, &len);

	dsc.dsc$w_length = len;
	dsc.dsc$b_dtype = DSC$K_DTYPE_T;
	dsc.dsc$b_class = DSC$K_CLASS_S;
	dsc.dsc$a_pointer = p;
	if (lib$convert_date_string(&dsc, outdv->db_data,
					&scb->adf_rms_context) != SS$_NORMAL
	   )
	{
	    return(rms_dterr(scb, E_GW7014_BAD_STR_TO_VDATE, 1, len, p));
	}

        break;
      }

      case DB_DTE_TYPE:
      {
        /*
        ** 24-jan-93 (jimg)
        ** For converting shifted values of "timestamp" that are negative.
        ** The maximum negative value (in days) cannot exceed, in absolute value,
        ** this value.
        **/
#define MAX_NEG_ADJUST  2

	i2		timebuf[7];
	static i1	daysin[][12] = {31,28,31,30,31,30,31,31,30,31,30,31,
					31,29,31,30,31,30,31,31,30,31,30,31};

	AD_DATENTRNL	    *dp = indv->db_data;
	i4		    tmshift;
	i4		    yearsize;
	i4		    time;
        /*  Used for negative timeshift interval arithmetic. (jimg) */
        i4		    delta;
        PTR             tm_cb;
        char            tm_name[32];
        char            *string;

	if ((dp->dn_status & AD_DN_ABSOLUTE) == 0)
	    return(rms_dterr(scb, E_GW7028_DATE_IS_INTERVAL, 0));

	timebuf[0] = dp->dn_year;
	timebuf[1] = dp->dn_month;
	timebuf[2] = dp->dn_lowday;

	/* If there was no time specified as part of the INGRES date, set VAX
	** date's time field to all zeros.  Otherwise, extract the time and
	** shift it as appropriate.
	**
	** 24-jan-94 (jimg)
	**  Note that this allows INGRES dates without timespecs to be
	**  entered and displayed correctly in the same time zone.  However,
	**  after conversion to VAX internal format for absolute time
	**  the distinction is forever lost between an INGRES GMT date
	**  converted to VAX local with time=0 and an INGRES date without
	**  a timespec.
	*/
	if ((dp->dn_status & AD_DN_TIMESPEC) == 0)
	{
	    timebuf[3] = 0;
	    timebuf[4] = 0;
	    timebuf[5] = 0;
	    timebuf[6] = 0;
	}
	else
	{
            /* adjust from GMT to local time
            ** 24-jan-94 (jimg)
            **  My re-write of this entire routine.
	    **
            **  Assumptions:
            **  1) TMzone() returns the value that represents the shift west of
            **     GMT in minutes.  These values are based on political
            **     agreements  as well as by technical determination.  Daylight
            **     savings time, when observed in a certain zone, can also shift
            **     the upper bounds by an hour or so.  In any case, the
            **     "natural" range for time zone shifts seems to be within
            **     (-13, +14] hours, viz., (-780,+840] minutes.  The value need
            **     not be an even multiple of 60 (e.g., 30 or 45 minutes are
            **     possible for some time zones).
            **     NOTE: ** No bounds check for this value is done here. **
            **
            **  2) Notes on interval arithmetic for date conversions: The numeric
            **     values for each of the date-time units are based on the format of
            **     the seven-word binary integer data structure specified by the VMS
            **     System Service companion routiner SYS$NUMTIME and LIB$CVT_VECTIM.
            **     SYS$NUMTIME converts a VAX VMS 64-bit binary system time to numeric
            **     time.  LIB$CVT_VECTIM provides the inverse function.
	    **
	    **      variable     description             interval
	    **      -----------  --------------------    -----------------------
	    **      timebuf[0]   year since 0            0..AD_24DTE_MAX_ABS_YR
	    **      timebuf[1]   month of year           1..12
	    **      timebuf[2]   day of month            1..daysin[yr][month]
	    **      timebuf[3]   hour of day             0..23
	    **      timebuf[4]   minute of hour          0..59
	    **      timebuf[5]   second of minute        0..59
	    **      timebuf[6]   hundredths of second    0..99
	    **
            */

	    /* Save multiple de-referencing with local variable */
            time = dp->dn_time;

            /* Get the server's time zone value */
            string = NULL;
            NMgtAt("II_TIMEZONE_NAME",&string);
            if (string != NULL)
               STcopy (string, tm_name);
            else 
               /* default to IIGMT */
               STcopy ("IIGMT", tm_name);

            TMtz_lookup(tm_name, &tm_cb);
            tmshift = TMtz_search(tm_cb, TM_TIMETYPE_LOCAL, 
                                 adu_5time_of_date(dp));
            /*
            ** change tmshift to min
            */
            tmshift /= 60;

            if ( (time += (tmshift * AD_7DTE_IMSPERMIN) ) > 0 )
            {
                /* Check if "hour" value overflowed */
                if ( time >= (24 * AD_8DTE_IMSPERHOUR) )
                {
                    /*
                    ** NOTE:Valid II_TIMEZONE values of (-13,14] ensure
                    **      that the largest positive shift will
                    **      produce 62:59:59 for:
                    **          * user-entered time =  23:59:59 pm
                    **          * pm adds in a value  +12
                    **          * session time zone = +14
                    **          * server time zone  = -13.
                    **
                    **      This means that 2 days is the maximum
                    **      overflow that can be added to the "date".
                    **
                    **  WARNING: II_TIMEZONE values outside this range
                    **      may break this algorithm and return a 
		    **	    conversion error.
                    */

                    /*
                    ** Add computed overflow to "day" and
                    ** normalize "time" value.
                    */
                    timebuf[2] += time / (24 * AD_8DTE_IMSPERHOUR);
                    time        = time % (24 * AD_8DTE_IMSPERHOUR);

                    /* Check result for overflow out of "day of month" */
                    TMyrsize(timebuf[0], &yearsize);
                    if ( timebuf[2] > daysin[yearsize-365][timebuf[1]-1] )
                    {
                        /* Normalize "day of month" with respect to "year" */
                        timebuf[2] -= daysin[yearsize-365][timebuf[1]-1];

                        /* Increment "month", check result for overflow */
                        if ( (++timebuf[1]) > 12)
                        {
                            /*
                            ** Only "month" overflow is
                            **   from   DEC "year"
                            **   to     JAN "year"+1.
                            */
                            timebuf[1]  = 1;
                            timebuf[0] += 1;
                        }
                    }
                }
            }

            /* Check result for underflow out of "time" */
            else if ( time < 0 )
            {
                /*
                ** NOTE:Valid II_TIMEZONE values of (-13,14] ensure that
                **      the largest negative shift will produce -27:00:00
                **      for:
                **      * user-entered time =  00:00:00
                **      * session time zone = -13
                **      * server time zone  = +14.
                **
                **      This means that 2 days is the MAX_NEG_ADJUST
                **      needed to restore the "time" to a positive
                **      value using modulo arithmetic.
                **
                **  WARNING: II_TIMEZONE values outside this range may
                **      break this algorithm and return a conversion error.
                */

                /* Compute underflow into "date" as a negative integer */
                delta = ((time + MAX_NEG_ADJUST * 24*AD_8DTE_IMSPERHOUR) /
                                                 (24*AD_8DTE_IMSPERHOUR))
                               - MAX_NEG_ADJUST;

                /* Normalize "time" value to a positive number */
                time =  (time + MAX_NEG_ADJUST *24*AD_8DTE_IMSPERHOUR) %
                                    (24*AD_8DTE_IMSPERHOUR);

                /* Add underflow to "day" and check result for further underflow */
                if ( (timebuf[2] += delta) <= 0 )
                {
                    /* Decrement "month", check result for underflow */
                    if ( (--timebuf[1] ) <= 0)
                    {
                        /*
                        ** Only "month" underflow is
                        **   from   JAN "year"
                        **   to     DEC "year"-1.
                        */
                        timebuf[0] -= 1;
                        timebuf[1]  = 12;

                        /* Adjust "day" knowing month */
                        timebuf[2] += 31;
                    }
                    else
                    {
                        /* All other underflows, do variable adjustment */
                        TMyrsize(timebuf[0], &yearsize);
                        timebuf[2] += daysin[yearsize-365][timebuf[1]-1];
                    }
                }
            }

            /*
            ** Now, form "time" units for VAX conversion routine
            **
            ** Guaranteed at this point, that "time" is not negative
            ** and each of the units will be within the proper VAX
            ** specified ranges.
            */
            timebuf[3]   = time / AD_8DTE_IMSPERHOUR;
            time        %=        AD_8DTE_IMSPERHOUR;
            timebuf[4]   = time / AD_7DTE_IMSPERMIN;
            time        %=        AD_7DTE_IMSPERMIN;
            timebuf[5]   = time / AD_6DTE_IMSPERSEC;
            time        %=        AD_6DTE_IMSPERSEC;
            timebuf[6]   = time / 10;
        }

	/* now timebuf is ready to be converted to a VAX date */
	if ((lib$cvt_vectim(&timebuf, outdv->db_data) & 1) != 1)
	    return(rms_dterr(scb, E_GW7006_ING_TO_VAX_DATE, 0));
      }
    }

    return(E_DB_OK);
}

/*{
** Name: rms_rstrcvt - Convert INGRES types to RMS NULL-padded string
**
** Description:
**	This routine takes a variety of INGRES data values and converts them
**	to RMS BLANK-padded or NULL-padded string type.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	24-apr-90 (jrb)
**	    Created.
**	14-jun-90 (jrb)
**	    Added support for blank-padded strings as well.
**	26-jun-90 (linda)
**	    Added support for blank-padded and null-padded varying string
**	    types.  Actually, for conversion purposes the so-called RMS varying
**	    string type is identical to a fixed string type; it only makes a
**	    difference on output to a file with varying record lengths, where
**	    trailing pad characters are truncated on output.  We need to have
**	    the type so that we know when to do that.
**      30-mar-1993 (schang)
**          decimal support in.
**      30-dec-97 (schang)
**          convert ingres byte to rmsgw null pad string
*/
DB_STATUS
rms_rstrcvt
(
    ADF_CB	  *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    char	    temp[50];
    char	    *p = temp;
    i2		    slen;

    switch (indv->db_datatype)
    {
      case DB_INT_TYPE:
	switch (indv->db_length)
	{
	  case 1:
	    CVla((i4)I1_CHECK_MACRO(*(i1 *)indv->db_data), temp);
	    break;

	  case 2:
	    CVla((i4)*(i2 *)indv->db_data, temp);
	    break;

	  case 4:
	    CVla(*(i4 *)indv->db_data, temp);
	    break;
	}
	slen = STlength(temp);
	break;

      case DB_FLT_TYPE:
      {
	char	    decimal = (scb->adf_decimal.db_decspec
				    ? (char) scb->adf_decimal.db_decimal
				    : '.'
			      );

	if (indv->db_length == 4)
	{
	    CVfa((f8) *(f4 *) indv->db_data,
		 scb->adf_outarg.ad_f4width,
		 scb->adf_outarg.ad_f4prec,
		 scb->adf_outarg.ad_f4style,
		 decimal, temp, &slen);
	}
	else
	{
	    CVfa(*(f8 *)indv->db_data,
		 scb->adf_outarg.ad_f8width,
		 scb->adf_outarg.ad_f8prec,
		 scb->adf_outarg.ad_f8style,
		 decimal, temp, &slen);
	}
	break;
      }

      case DB_DEC_TYPE:
      {
        i4 length;
	i4			    len;
	struct dsc$descriptor	    dsc;

        if (CVpka(indv->db_data,
                  DB_P_DECODE_MACRO(indv->db_prec),
	          DB_S_DECODE_MACRO(indv->db_prec),
                  0,
                  (u_i2)outdv->db_length,
	          DB_S_DECODE_MACRO(indv->db_prec),
                  CV_PKLEFTJUST,
                  temp,
                  &slen) == CV_OVERFLOW)
            return(E_DB_ERROR);
            /*
	    ** return(rms_dterr(scb, E_GW7015_DECIMAL_OVF, 2, 4, &pr, 4, &sc));
            */
        break;
      }

      case DB_VCH_TYPE:
      case DB_CHA_TYPE:
      case DB_TXT_TYPE:
      case DB_CHR_TYPE:
      case DB_LVCH_TYPE:
      case DB_BYTE_TYPE:
      case DB_VBYTE_TYPE:
      case DB_LBYTE_TYPE:
      case DB_GEOM_TYPE:
      case DB_POINT_TYPE:
      case DB_MPOINT_TYPE:
      case DB_LINE_TYPE:
      case DB_MLINE_TYPE:
      case DB_POLY_TYPE:
      case DB_MPOLY_TYPE:
      case DB_GEOMC_TYPE:
      {
	char	    *q;
	i4	    l;

	rms_straddr(indv, &q);
	rms_strcount(indv, &l);

	if (	indv->db_datatype == DB_CHA_TYPE
	    ||  indv->db_datatype == DB_CHR_TYPE
	    ||  indv->db_datatype == DB_VBYTE_TYPE
	   )
	{
	    while (l--  &&  q[l] == ' ')
		continue;

	    l++;
	}
	p = q;
	slen = l;
        break;
      }

      case DB_MNY_TYPE:
      {
	DB_DATA_VALUE	    dvs[2];
	DB_STATUS	    db_stat;

	dvs[0].db_datatype = DB_VCH_TYPE;
	dvs[0].db_length = 25;
	dvs[0].db_prec = 0;
	dvs[0].db_data = temp;
	STRUCT_ASSIGN_MACRO(*indv, dvs[1]);

        if ((db_stat = adf_exec_quick(scb,
		Rms_adffi_arr[RMS_03MNY2VCH_CVT].rms_fiid, dvs)) != E_DB_OK)
	{
	    return(db_stat);
	}

	p = ((DB_TEXT_STRING *)temp)->db_t_text;
	slen = ((DB_TEXT_STRING *)temp)->db_t_count;

	/* since the converted money value will be right-justified, we need to
	** strip the leading blanks
	*/
	while (slen > 0  &&  *p == ' ')
	    p++, slen--;
        break;
      }

      case DB_DTE_TYPE:
      {
	DB_DATA_VALUE	    dvs[2];
	DB_STATUS	    db_stat;

	dvs[0].db_datatype = DB_VCH_TYPE;
	dvs[0].db_length = 48;
	dvs[0].db_prec = 0;
	dvs[0].db_data = temp;
	STRUCT_ASSIGN_MACRO(*indv, dvs[1]);

        if ((db_stat = adf_exec_quick(scb,
		Rms_adffi_arr[RMS_04DTE2VCH_CVT].rms_fiid, dvs)) != E_DB_OK)
	{
	    return(db_stat);
	}
	p = ((DB_TEXT_STRING *)temp)->db_t_text;
	slen = ((DB_TEXT_STRING *)temp)->db_t_count;
        break;
      }
    }

    /* now put temp value into output buffer and pad with proper character */
    switch (outdv->db_datatype)
    {
	case	RMSGW_BL_FIXSTR:
	case	RMSGW_BL_VARSTR:
	    MEmove(slen, p, ' ',
		   outdv->db_length, outdv->db_data);
	    break;

	case	RMSGW_NL_FIXSTR:
	case	RMSGW_NL_VARSTR:
	    MEmove(slen, p, NULLCHAR,
		   outdv->db_length, outdv->db_data);
	    break;

	/* no default case, we don't expect to get bad datatype id's... */
    }

    return(E_DB_OK);
}


/*{
** Name: rms_rdeccvt - Convert INGRES types to decimal string types
**
** Description:
**	This routine takes a variety of INGRES data values and converts them
**	to the VAX decimal string types: packed decimal, unsigned numeric,
**	leading numeric, zoned numeric, and overpunched numeric.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	24-apr-90 (jrb)
**	    Created.
**	7-sep-90 (linda)
**	    Added support for RMSGW_TRL_NUM (trailing separate numeric)
**	    datatype.
**	14-oct-91 (rickh)
**	    Corrected placement of sign byte for trailing separate numeric.
**      30-mar-93 (schang)
**          decimal support in.
**      mar-03-2000 (chash01)
**          modify numerical type conversion, old vax version does not apply
**          to Alpha .  Also library routine lib$cvt_dx_dx does not work on 
**          6.1 aplpha VMS.  The conversions have to be hand coded.
*/
DB_STATUS
rms_rdeccvt
(
    ADF_CB	  *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    STATUS	    status = E_DB_OK;
    char	    *cp;
    i4		    itemp;
    f8		    ftemp;
    u_i2	    count;
    i4		    pr = DB_P_DECODE_MACRO(outdv->db_prec);
    i4		    sc = DB_S_DECODE_MACRO(outdv->db_prec);
    char	    temp[DB_MAXSTRING + 1];
    u_char	    result[32];
    char	    decimal = (scb->adf_decimal.db_decspec ?
				(char) scb->adf_decimal.db_decimal : '.');


    switch (indv->db_datatype)
    {
      case DB_INT_TYPE:
        switch (indv->db_length)
        {
          case 1:
            itemp = I1_CHECK_MACRO(*(i1 *)indv->db_data);
            break;

          case 2:
            itemp = *(i2 *)indv->db_data;
            break;

          case 4:
            itemp = *(i4 *)indv->db_data;
            break;
        }

	if (CVlpk(itemp,
		pr,
		sc,
		(PTR)result)
	    == CV_OVERFLOW)
	{
	    return(rms_dterr(scb, E_GW7015_DECIMAL_OVF, 2, 4, &pr, 4, &sc));
	}
        break;

      case DB_FLT_TYPE:
        if (indv->db_length == 4)
	    ftemp = *(f4 *)indv->db_data;
        else
	    ftemp = *(f8 *)indv->db_data;

	if (CVfpk(ftemp, pr, sc, (PTR)result) == CV_OVERFLOW)
	    return(rms_dterr(scb, E_GW7015_DECIMAL_OVF, 2, 4, &pr, 4, &sc));

        break;
	
      case DB_CHA_TYPE:
      case DB_CHR_TYPE:
        cp = temp;
        MEcopy(indv->db_data, indv->db_length, (PTR) cp);
        cp[indv->db_length] = EOS;

        status = CVapk(cp, decimal, pr, sc, (PTR)result);

	if (status == CV_SYNTAX)
	    return(rms_dterr(scb, E_GW7016_BAD_STR_TO_DEC, 1, 0, cp));

	if (status == CV_OVERFLOW)
	    return(rms_dterr(scb, E_GW7015_DECIMAL_OVF, 2, 4, &pr, 4, &sc));

        break;

      case DB_VCH_TYPE:
      case DB_TXT_TYPE:
      case DB_LTXT_TYPE:
        cp = temp;
        count = ((DB_TEXT_STRING *) indv->db_data)->db_t_count;
        MEcopy((PTR)((DB_TEXT_STRING *)indv->db_data)->db_t_text,
		count,
		(PTR)cp);
        cp[count] = EOS;

        status = CVapk(cp, decimal, pr, sc, (PTR)result);

	if (status == CV_SYNTAX)
	    return(rms_dterr(scb, E_GW7016_BAD_STR_TO_DEC, 1, 0, cp));

	if (status == CV_OVERFLOW)
	    return(rms_dterr(scb, E_GW7015_DECIMAL_OVF, 2, 4, &pr, 4, &sc));
	    
        break;

      case DB_MNY_TYPE:		/* we cheat here: we know money is an f8 */
	/* get dollars since it's stored as cents */
        ftemp = *(f8 *)indv->db_data / 100.0;

	if (CVfpk(ftemp, pr, sc, (PTR)result) == CV_OVERFLOW)
	    return(rms_dterr(scb, E_GW7015_DECIMAL_OVF, 2, 4, &pr, 4, &sc));

        break;

      case DB_DEC_TYPE:         /* convert from input format to output format */
        if (CVpkpk(indv->db_data,
                   DB_P_DECODE_MACRO(indv->db_prec),
                   DB_S_DECODE_MACRO(indv->db_prec),
	           pr, sc, (PTR)result) == CV_OVERFLOW)
	    return(rms_dterr(scb, E_GW7015_DECIMAL_OVF, 2, 4, &pr, 4, &sc));
        break; 
    }

    /* Now 'result' variable contains the packed decimal representation of
    ** the converted number.  Convert this to the proper destination datatype.
    */
    if ( outdv->db_datatype ==  RMSGW_PACKED_DEC )
	MEcopy((PTR)result, outdv->db_length, (PTR)outdv->db_data);
    else
    {
#if defined(axm_vms) || defined(i64_vms)
      /*
      ** for leading, trailing numericals, the length specified is the number
      ** of DIGITS (not counting siign).  The real field length in the record
      ** is the specified length+1.  The field length of packed decimal is
      ** (length/2)+1; here the length in () is that specified in registration.
      ** for zoned and overpunched, the specified length  is the same as the
      ** field length in RMS record.  IT is unclear about unsigned.  Since
      ** it is called unsigned, it should not contain a sign, + or -.  Thus
      ** I assumethat specified length is the real field length in RMS record.
      ** The conversion scheme is that we convert data into packed decimal,
      ** extract out sign, and digit value in string format. For zoned and
      ** overpunched numericals, we change the last digist to ecode sign.
      ** for trailing numeric, we put sign at the end.  We then fill in the
      ** the return buffer byte by byte from the rear.  If return buffer length
      ** is longer than needed, we fill it in with '0's.  At the very first
      ** byte of return buffer, if datatype is leading numeric, we put in
      ** '+' or '-"; or an '0' if not.
      **
      ** To convert back to Ingres data we reverse the process exactly.
      **   pr (number of total digits, excluding sign)
      **   sc (scale, number of digitsafter implicit decimal point)
      **   result (packed decimal value)
      */
      char digit_buf[32];               /* numeric digit without sign */
      char new_buff[32];
      i1 plussign, nibble, i, j,
         p_len = pr/2 + 1;

         nibble = result[p_len-1] & 0x0f;
      if (nibble == 12 || nibble == 14)
          plussign = 1;
      else /* must be 11, 13, 15 */
          plussign= 0;
      for ( i = pr-1, j = p_len-1;;)
      {
          if (j == (p_len-1))
          {
              nibble = (result[j] & 0xf0) >> 4;
              digit_buf[i--] = nibble + '0';
              j --;
              if (i < 0 || j < 0)
                  break;
          }
          else
          {
              nibble = result[j] & 0x0f;
              digit_buf[i--] = nibble + '0';
              if (i < 0 || j < 0)
                  break;
              nibble = (result[j] & 0xf0) >> 4;
              digit_buf[i--] = nibble + '0';
              j --;
              if (i < 0 || j < 0)
                  break;
          }
      }
      
      /*
      ** we have sign and digit buffer isolated, now
      ** we construct another string that contains both
      ** sign and digit.
      */
      if (outdv->db_datatype == RMSGW_LEADING_NUM )
      {
         if(plussign)
         {
            new_buff[0] = '+';
         }
         else 
            new_buff[0] = '-';
	 MEcopy((PTR)digit_buf, pr, &new_buff[1]);
      }
      else if (outdv->db_datatype == RMSGW_TRL_NUM )
      {
	 MEcopy((PTR)digit_buf, pr, new_buff);
         if(plussign)
         {
            new_buff[pr] = '+';
         }
         else 
            new_buff[pr] = '-';
      }
      else if (outdv->db_datatype == RMSGW_ZONED_NUM ||
                 outdv->db_datatype == RMSGW_OVR_NUM )
      {
	 MEcopy((PTR)digit_buf, pr, new_buff);
         if (outdv->db_datatype == RMSGW_ZONED_NUM)
             if (!plussign)
                 new_buff[pr-1] += 0x40;
  
         if (outdv->db_datatype == RMSGW_OVR_NUM)
             if (!plussign)
             {
                 if (new_buff[pr-1] == '0')
                     new_buff[pr-1] = 0x7d;
                 else
                     new_buff[pr-1] += 0x19;
             }
             else
             {
                 if (new_buff[pr-1] == '0')
                     new_buff[pr-1] = 0x7b;
                 else
                     new_buff[pr-1] += 0x10;
             }
      }  
      else if (outdv->db_datatype == RMSGW_UNS_NUM )
      {
	 MEcopy((PTR)digit_buf, pr, new_buff);
      }
      /*
      ** copy result to outdb->db_data
      */
      MEcopy(new_buff, outdv->db_length, outdv->db_data);
      /****** done */
#else
      switch (outdv->db_datatype)
      {
      case RMSGW_LEADING_NUM:
        rms_mcvt_p_s(result, pr, outdv->db_data);
	break;

      case RMSGW_UNS_NUM:
      case RMSGW_ZONED_NUM:
        rms_mcvt_p_t(result, pr, outdv->db_data, Rms_deczon_map);
	break;

      case RMSGW_OVR_NUM:
        rms_mcvt_p_t(result, pr, outdv->db_data, Rms_decovr_map);
	break;

      case RMSGW_TRL_NUM:
        {
	  u_char	tmpres[34];
	  rms_mcvt_p_s(result, pr, tmpres); /* cvt to leading separate numeric */
	  /* place sign byte at end */
	  tmpres[ (u_i2)outdv->db_length ] = tmpres[ 0 ];
	  MEcopy((PTR)&tmpres[1], outdv->db_length, (PTR)outdv->db_data);
          break;
        }
      } /* switch */
#endif
    }   /* else */
    return(E_DB_OK);
}

/*
[@function_definition@]...
*/
