/*
**  Copyright (C) 2005-2006 Actian Corporation. All Rights Reserved.
*/

/*
**    Source   : dbeframe.cpp, Implementation   (MDI Child Frame)
**    Project  : CA-OpenIngres/Monitoring.
**    Author   : EMB, Standard Skeleton Generated by MFC Widzard
**               UK Sotheavut, Detail implementation.
**    Purpose  : Frame window for the DBEvent Trace.
**
** History (after 26-Sep-2000)
** 
** 26-Sep-2000 (uk$so01)
**    SIR #102711: Callable in context command line improvement (for Manage-IT)
**    Select the input database if specified.
** 21-Mar-2001 (schph01)
**    SIR 104284: call DomgetFirstObject function with bWithSystem flag at
**    TRUE to fill the database combobox with the iidbdb and imadb databases
** 26-Mar-2001 (noifr01)
**    (sir 104270) removal of code for managing Ingres/Desktop
** 13-Dec-2010 (drivi01) 
**    Port the solution to x64. Clean up the warnings.
**    Clean up datatypes. Port function calls to x64.
*/

#include "stdafx.h"
#include "mainmfc.h"
#include "dbedoc.h"
#include "dbeframe.h"
#include "dbeview.h"
#include "vwdbep02.h"

#include "cmdline.h"    // Unicenter-driven features

extern "C" 
{
#include "dba.h"
#include "dbaset.h"
#include "domdata.h"
#include "dbaginfo.h"   // Gwtype - constants
#include "main.h"       // WM_USER_GETNODEHANDLE
#include "dbafile.h"    // ARCHIVEBUFSIZE
}

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDbeventFrame

IMPLEMENT_DYNCREATE(CDbeventFrame, CMDIChildWnd)

CDbeventFrame::CDbeventFrame()
{
    m_pEditMaxLine = NULL;
    m_iMaxLine     = 200;
    m_iMaxLineMin  = 10;
    m_iMaxLineMax  = 4000;
    m_bPopup       = FALSE;
    m_bAllViewCreated = TRUE;
    m_bMaxLineChanged = FALSE;
}

CDbeventFrame::~CDbeventFrame()
{
}


CuDlgDBEventPane01* CDbeventFrame::GetPaneRegisteredDBEvent()
{
    CDbeventView* pView = (CDbeventView*)m_wndSplitter.GetPane (0, 0);
    ASSERT (pView && pView->m_pDlgRegisteredDBEvent);
    return pView->m_pDlgRegisteredDBEvent;
}

CuDlgDBEventPane02* CDbeventFrame::GetPaneRaisedDBEvent()
{
    CDbeventView2* pView = (CDbeventView2*)m_wndSplitter.GetPane (0, 1);
    ASSERT (pView && pView->m_pDlgRaisedDBEvent);
    return pView->m_pDlgRaisedDBEvent;
}


BEGIN_MESSAGE_MAP(CDbeventFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CDbeventFrame)
	ON_WM_CREATE()
	ON_WM_MDIACTIVATE()
	ON_UPDATE_COMMAND_UI(IDM_DBEVENT_TRACE_DATABASE, OnUpdateDbeventTraceDatabase)
	ON_UPDATE_COMMAND_UI(IDM_DBEVENT_TRACE_MAXLINE, OnUpdateDbeventTraceMaxline)
	ON_UPDATE_COMMAND_UI(IDM_DBEVENT_TRACE_POPUP, OnUpdateDbeventTracePopup)
	ON_UPDATE_COMMAND_UI(IDM_DBEVENT_TRACE_REFRESH, OnUpdateDbeventTraceRefresh)
	ON_UPDATE_COMMAND_UI(IDM_DBEVENT_TRACE_RESET, OnUpdateDbeventTraceReset)
	ON_COMMAND(IDM_DBEVENT_TRACE_POPUP, OnDbeventTracePopup)
	ON_COMMAND(IDM_DBEVENT_TRACE_REFRESH, OnDbeventTraceRefresh)
	ON_COMMAND(IDM_DBEVENT_TRACE_RESET, OnDbeventTraceReset)
	ON_WM_DESTROY()
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
	ON_COMMAND(IDM_DBEVENT_TRACE_CLEARFIRST, OnClearFirst)
    ON_COMMAND (IDM_DBEVENT_TRACE_SYSDBEVENT, OnSystemDBEvent)
    ON_CBN_DROPDOWN  (IDM_DBEVENT_TRACE_DATABASE, OnRequeryDatabase)
    ON_CBN_SELCHANGE (IDM_DBEVENT_TRACE_DATABASE, OnSelChangeDatabase)
    ON_EN_SETFOCUS   (IDM_DBEVENT_TRACE_MAXLINE,  OnSetFocusMaxLine)
    ON_EN_KILLFOCUS  (IDM_DBEVENT_TRACE_MAXLINE,  OnKillFocusMaxLine)
    ON_EN_CHANGE     (IDM_DBEVENT_TRACE_MAXLINE,  OnEditChangeMaxLine)
    ON_MESSAGE (WM_USER_GETNODEHANDLE, OnGetNodeHandle)
    ON_MESSAGE (WM_USER_GETMFCDOCTYPE, OnGetMfcDocType)
    ON_MESSAGE (WM_USER_DBEVENT_TRACE_INCOMING, OnDbeventTraceIncoming)
    ON_MESSAGE (WM_USER_REFRESH_DATA, OnRefresh)

    // Toolbar management
    ON_MESSAGE(WM_USER_HASTOOLBAR,        OnHasToolbar      )
    ON_MESSAGE(WM_USER_ISTOOLBARVISIBLE,  OnIsToolbarVisible)
    ON_MESSAGE(WM_USER_SETTOOLBARSTATE,   OnSetToolbarState )
    ON_MESSAGE(WM_USER_SETTOOLBARCAPTION, OnSetToolbarCaption)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDbeventFrame message handlers

LRESULT CDbeventFrame::OnDbeventTraceIncoming (WPARAM wParam, LPARAM lParam)
{
    if (!IsAllViewCreated())
        return RES_ERR;

    CWnd* pWnd = (CWnd*)GetPaneRaisedDBEvent();
    return (LONG)pWnd->SendMessage (WM_USER_DBEVENT_TRACE_INCOMING, wParam, lParam);
}

int CDbeventFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
   	EnableDocking(CBRS_ALIGN_ANY);
	if (!m_DbeDlgBar.Create(this, 
        IDD_DBEVENTBAR,
        WS_CHILD|WS_THICKFRAME|
		CBRS_SIZE_DYNAMIC  | CBRS_TOP | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_HIDE_INPLACE,
		IDD_DBEVENTBAR))
	{
	    TRACE0("Failed to create dialog bar m_wndVirtualNode\n");
		return -1;		// fail to create
	}
   	m_DbeDlgBar.EnableDocking(CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT|CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
	DockControlBar(&m_DbeDlgBar, AFX_IDW_DOCKBAR_TOP);
    CString str;
    str.LoadString (IDS_DBEVENT_TITLE);
    m_DbeDlgBar.SetWindowText (str);
    CEdit* pEdit = m_DbeDlgBar.GetEditMaxLine();
    if (pEdit && IsWindow (pEdit->m_hWnd))
    {
        CString strFormat;
        strFormat.Format ("%d", m_iMaxLine);
        pEdit->SetLimitText  (4);
        pEdit->SetWindowText (strFormat);
    }
    CSpinButtonCtrl* pSpin = m_DbeDlgBar.GetSpinCtrl();
    if (pSpin && IsWindow (pSpin->m_hWnd))
        pSpin->SetRange(m_iMaxLineMin, m_iMaxLineMax);
    m_strCurrentDB = _T("");

    //
    // Handle command line input database:
    CDbeventDoc* pDoc = (CDbeventDoc*)GetActiveDocument();
    CComboBox* pComboDatabase = m_DbeDlgBar.GetComboDatabase();
    if (pDoc && !pDoc->m_strInputDatabase.IsEmpty() && pComboDatabase) 
    {
        RequeryDatabase();
        pComboDatabase->EnableWindow(FALSE);
        OnSelChangeDatabase();
    }
    return 0;
}

void CDbeventFrame::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd) 
{
	CMDIChildWnd::OnMDIActivate(bActivate, pActivateWnd, pDeactivateWnd);

  // maintain gateway type and oivers
  if (bActivate) {
    ASSERT (pActivateWnd == this);
    CDocument* pDoc = GetActiveDocument();
    ASSERT (pDoc);
    if (pDoc) {
      CDbeventDoc *pTheDoc = (CDbeventDoc *)pDoc;
      if (pTheDoc->m_OIVers != -1)
        SetOIVers(pTheDoc->m_OIVers);
    }
  }
}

BOOL CDbeventFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext)
{
     CRuntimeClass* pView = RUNTIME_CLASS(CDbeventView2);
    //
    // Create a splitter of 1 rows and 2 columns.
    //
	if (!m_wndSplitter.CreateStatic (this, 1, 2))
    {
        TRACE0 ("CDbeventFrame::OnCreateClient: Failed to create Splitter\n");
        return FALSE;
    }
    //
    // Add the first splitter pane - the default view (CDbeventView2) in column 0
    //
    if (!m_wndSplitter.CreateView (0, 0, pContext->m_pNewViewClass, CSize (120, 400), pContext))
    {
        TRACE0 ("CDbeventFrame::OnCreateClient: Failed to create first pane\n");
        return FALSE;
    }

    //
    // Add the second splitter pane - the view (CDbeventView2) in column 1
    //
    if (!m_wndSplitter.CreateView (0, 1, pView, CSize (400, 400), pContext))
    {
        TRACE0 ("CDbeventFrame::OnCreateClient: Failed to create second pane\n");
        return FALSE;
    }
    m_wndSplitter.RecalcLayout();
    m_bAllViewCreated = TRUE;
    SetActiveView ((CView*)m_wndSplitter.GetPane(0, 0));
    return TRUE;
}

void CDbeventFrame::OnSelChangeDatabase()
{
	int          index;
    CString      strNone;
    CString      strDB = "";
    CDbeventDoc* pDoc;
    pDoc = (CDbeventDoc*)GetActiveDocument();
    ASSERT (pDoc);
    CComboBox*   pComboDatabase = m_DbeDlgBar.GetComboDatabase();

    if (!IsAllViewCreated())
        return;
    CuDlgDBEventPane02* pDlpP2 = GetPaneRaisedDBEvent();
    if (pDlpP2->m_cListRaisedDBEvent.GetItemCount() > 0)
    {
        int res  = BfxMessageBox (VDBA_MfcResourceString(IDS_E_DB_EVENT_DELETED), MB_OKCANCEL);//"The Raised DB Events will be deleted"
        if (res != IDOK)
        {
            pComboDatabase->SelectString (-1, m_strCurrentDB);
            return;
        }
        pDlpP2->m_cListRaisedDBEvent.DeleteAllItems();
        pDoc->m_nCounter1 = 1;
        pDoc->m_nCounter2 = 0;
    }
    if (strNone.LoadString (IDS_DATABASE_NONE) == 0)
        strNone = "<None>";
    if (m_strCurrentDB != "" && m_strCurrentDB != strNone)
    {
        // 
        // Reset the Database ...
        if (pDoc->m_bDBInit && pDoc->m_nHandle != -1)
		{
            GetPaneRegisteredDBEvent()->UnregisterDBEvents();
//			DBETraceTerminate (pDoc->m_nHandle);
		}
        pDoc->m_bDBInit = FALSE;
        pDoc->m_nHandle = -1;
    }
    try
    {
	    index = pComboDatabase->GetCurSel ();
	    if (index != CB_ERR)
	    {
	    	pComboDatabase->GetLBText (index, strDB);
	    	GetPaneRegisteredDBEvent()->InitializeDBEvent (strDB);
	    }
    }
    catch (CMemoryException* e)
    {
        VDBA_OutOfMemoryMessage ();
        e->Delete();
    }
    catch(...)
    {
        throw;
    }

    if (strDB != strNone)
    {
        //
        // Initialize the new Database ...
        if (DBETraceInit (pDoc->m_hNode, (LPUCHAR)(LPCTSTR)strDB, this->m_hWnd, &(pDoc->m_nHandle)) == RES_SUCCESS)
            pDoc->m_bDBInit = TRUE;
        else
        {
            pDoc->m_bDBInit = FALSE;
            pDoc->m_nHandle = -1;
        }
    }
    m_strCurrentDB    = strDB;
    pDoc->m_strDBName = strDB;
    CTime   time = CTime::GetCurrentTime();
    CString strTime = time.Format ("%c");
    pDoc->m_strRaisedSince = strTime;
    GetPaneRaisedDBEvent()->SetHeader (strTime);
    TRACE0 ("CDbeventFrame::OnSelChangeDatabase() ...\n");
}

BOOL CDbeventFrame::RequeryDatabase ()
{
    int   index;
    int   ires;
    TCHAR buf       [MAXOBJECTNAME];
    TCHAR buffilter [MAXOBJECTNAME];
    CString strCurSel = "";
    CString strNone;
    CDbeventDoc* pDoc = (CDbeventDoc*)GetActiveDocument();
    ASSERT (pDoc);
    CWinApp* app = NULL;
    CComboBox* pComboDatabase = m_DbeDlgBar.GetComboDatabase();

    strNone.LoadString (IDS_DATABASE_NONE);
    index = pComboDatabase->GetCurSel ();
    if (index != CB_ERR)
    {
        pComboDatabase->GetLBText (index, strCurSel);
    }
    pComboDatabase->ResetContent ();
    pComboDatabase->AddString (strNone);
    app = AfxGetApp();
    app->DoWaitCursor (1); 
    memset (buf, 0, sizeof (buf));
    memset (buffilter, 0, sizeof (buffilter));
    ires    = DOMGetFirstObject (pDoc->m_hNode, OT_DATABASE, 0, NULL, TRUE, NULL, (LPUCHAR)buf, NULL, NULL);
    while (ires == RES_SUCCESS)
    {
        pComboDatabase->AddString ((LPCTSTR)buf);
        ires  = DOMGetNextObject ((LPUCHAR)buf, (LPUCHAR)buffilter, NULL);
    }
    if (index != CB_ERR)
    {
        //
        // Set back the previous selected item. 
        if (pComboDatabase->SelectString (-1, strCurSel) == CB_ERR)
        {
            //
            // The previous selected database has been dropped.
            pComboDatabase->SelectString (-1, strNone);
            app->DoWaitCursor (-1);
            return FALSE;
        }
    }
    else
    {
        pComboDatabase->SelectString (-1, strNone);
    }

    //
    // Handle command line input database:
    if (pDoc && !pDoc->m_strInputDatabase.IsEmpty())
    {
        pComboDatabase->SelectString (-1, pDoc->m_strInputDatabase);
    }

    index = pComboDatabase->GetCurSel ();
    if (index != CB_ERR)
    {
        pComboDatabase->GetLBText (index, m_strCurrentDB);
        pComboDatabase->SetCurSel (index);
    }
    app->DoWaitCursor (-1);
    return TRUE;
}

void CDbeventFrame::OnRequeryDatabase()
{
    SetExpandingCombobox();
    RequeryDatabase ();
    ResetExpandingCombobox();
    TRACE0 ("CDbeventFrame::OnRequeryDatabase() ...\n");
}



void CDbeventFrame::OnUpdateDbeventTraceDatabase(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	
}

void CDbeventFrame::OnUpdateDbeventTraceMaxline(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable (TRUE);
}

void CDbeventFrame::OnUpdateDbeventTracePopup(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable (TRUE);
}

void CDbeventFrame::OnUpdateDbeventTraceRefresh(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable (TRUE);
}

void CDbeventFrame::OnUpdateDbeventTraceReset(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable (TRUE);
}


void CDbeventFrame::OnDbeventTracePopup() 
{
    CDbeventDoc* pDoc = (CDbeventDoc*)GetActiveDocument();
    ASSERT (pDoc);
    CButton* pButton = m_DbeDlgBar.GetPopupButton();
    pDoc->m_bPopupOnRaise = (pButton->GetCheck() == 1)? TRUE: FALSE;
    TRACE0 ("CDbeventFrame::OnDbeventTracePopup() ...\n");
}

void CDbeventFrame::OnClearFirst()
{
    CDbeventDoc* pDoc = (CDbeventDoc*)GetActiveDocument();
    ASSERT (pDoc);
    CButton* pButton = m_DbeDlgBar.GetClearFirstButton();
    pDoc->m_bClearFirst = (pButton->GetCheck() == 1)? TRUE: FALSE;
    if (GetPaneRaisedDBEvent()->GetSpecialState())
    {
        CTime t = CTime::GetCurrentTime();
        CString strTime = t.Format ("%c");
        GetPaneRaisedDBEvent()->SetSpecialState (FALSE);
        GetPaneRaisedDBEvent()->IncomingDBEvent (pDoc, "", strTime, VDBA_MfcResourceString(IDS_RESTARTED), "", "");
    }
    TRACE0 ("CDbeventFrame::OnClearFirst() ...\n");
}

void CDbeventFrame::OnDbeventTraceRefresh() 
{
    TRACE0 ("CDbeventFrame::OnDbeventTraceRefresh() ...\n");
    //
    // Refresh the Database.
    if (!RequeryDatabase ())
    {
        //
        // The Database previously selected was not there any more.
        // It must be Terminated, how ???
        BfxMessageBox (VDBA_MfcResourceString(IDS_E_DB_DROPPED)); //"The previously selected Database has been dropped"
        return;
    }
    GetPaneRegisteredDBEvent()->ForceRefresh();
    GetPaneRegisteredDBEvent()->OnRefresh();
}

//#define UKS_TESTSERIALIZE
void CDbeventFrame::OnDbeventTraceReset() 
{
#ifdef UKS_TESTSERIALIZE
    CString strFile = "D:\\VdbaMfc\\MainMfc\\Debug\\F001.DAT";
    CDbeventDoc* pDoc = (CDbeventDoc*)GetActiveDocument();
    ASSERT (pDoc);
    {
    CFile f (strFile, CFile::modeCreate|CFile::modeWrite);
    CArchive ar (&f, CArchive::store, ARCHIVEBUFSIZE);
    pDoc->Serialize (ar);
    int k = 10;
    }
    {
    CFile f1 (strFile, CFile::modeRead);
    CArchive ar (&f1, CArchive::load, ARCHIVEBUFSIZE);
    pDoc->Serialize (ar);
    pDoc->DisplayDoc();
    }
#else
    GetPaneRaisedDBEvent()->ResetDBEvent();
#endif
}

void CDbeventFrame::OnEditChangeMaxLine()
{
    m_bMaxLineChanged = TRUE;
}


void CDbeventFrame::OnSetFocusMaxLine()
{
    m_bMaxLineChanged = FALSE;
}

void CDbeventFrame::OnKillFocusMaxLine()
{
    int nOldMax;
    CString strMax;
    CEdit* pEdit = m_DbeDlgBar.GetEditMaxLine();
    if (!(pEdit && IsWindow (pEdit->m_hWnd)) || !m_bMaxLineChanged)
        return;
    pEdit->GetWindowText (strMax);
    m_iMaxLine = atoi ((LPCTSTR)strMax);
    if (m_iMaxLine > m_iMaxLineMax)
    {
        m_iMaxLine = m_iMaxLineMax;
        strMax.Format ("%d", m_iMaxLine);
        pEdit->SetWindowText (strMax);
    }
    else
    if (m_iMaxLine < m_iMaxLineMin)
    {
        m_iMaxLine = m_iMaxLineMin;
        strMax.Format ("%d", m_iMaxLine);
        pEdit->SetWindowText (strMax);
    }
    CDbeventDoc* pDoc = (CDbeventDoc*)GetActiveDocument();
    ASSERT (pDoc);
    nOldMax = pDoc->m_nMaxLine;
    if (!GetPaneRaisedDBEvent()->OnMaxLineChange (m_iMaxLine))
    {
        strMax.Format ("%d", pDoc->m_nMaxLine);
        pEdit->SetWindowText (strMax);
    }
    else
        pDoc->m_nMaxLine = m_iMaxLine;
    if (GetPaneRaisedDBEvent()->GetSpecialState())
    {
        CTime t = CTime::GetCurrentTime();
        CString strTime = t.Format ("%c");
        CuListCtrl& pList = GetPaneRaisedDBEvent()->m_cListRaisedDBEvent;
        int nCount =pList.GetItemCount();
        if (nCount >= m_iMaxLine)   // Still not enough place to add new line.
            return;
        GetPaneRaisedDBEvent()->SetSpecialState (FALSE);
        GetPaneRaisedDBEvent()->IncomingDBEvent (pDoc, "?", strTime, VDBA_MfcResourceString(IDS_RESTARTED), "", "");
    }
}


LRESULT CDbeventFrame::OnRefresh (WPARAM wParam, LPARAM lParam)
{
    if (!RequeryDatabase ())
    {
        //
        // The Database previously selected was not there any more.
        // It must be Terminated, how ???
        BfxMessageBox (VDBA_MfcResourceString(IDS_E_DB_DROPPED));//"The previously selected Database has been dropped"
        return 0L;
    }
    GetPaneRegisteredDBEvent()->OnRefresh();
    return 0L;
}

void CDbeventFrame::OnSystemDBEvent()
{
    TRACE0 ("CDbeventFrame::OnSystemDBEvent() ...\n");
    CDbeventDoc* pDoc = (CDbeventDoc*)GetActiveDocument();
    ASSERT (pDoc);
    CButton* pButton = m_DbeDlgBar.GetSysDBEventButton();
    pDoc->m_bSysDBEvent = (pButton->GetCheck() == 1)? TRUE: FALSE; 
    GetPaneRegisteredDBEvent()->OnRefresh();
}


LRESULT CDbeventFrame::OnGetNodeHandle(WPARAM uu, LPARAM ll)
{
  CDocument* pDoc = GetActiveDocument();
  ASSERT (pDoc);
  if (pDoc) {
    CDbeventDoc *pTheDoc = (CDbeventDoc *)pDoc;
    return (LONG)pTheDoc->m_hNode;
  }
  else
    return -1L;
}

LRESULT CDbeventFrame::OnGetMfcDocType(WPARAM uu, LPARAM ll)
{
  CDocument* pDoc = GetActiveDocument();
  if (pDoc)
    return TYPEDOC_DBEVENT;
  else
    return TYPEDOC_UNKNOWN;
}

void CDbeventFrame::OnDestroy() 
{
  theApp.SetLastDocMaximizedState(IsZoomed());

    CMDIChildWnd::OnDestroy();
}

LRESULT CDbeventFrame::OnHasToolbar(WPARAM wParam, LPARAM lParam)
{
  return (LONG)TRUE;
}

LRESULT CDbeventFrame::OnIsToolbarVisible(WPARAM wParam, LPARAM lParam)
{
  return (LONG)GetDialogBar()->IsVisible();
}

LRESULT CDbeventFrame::OnSetToolbarState(WPARAM wParam, LPARAM lParam)
{
  // lParam : TRUE means UpdateImmediate
  BOOL bDelay = (lParam ? FALSE : TRUE);
  if (wParam)
    ShowControlBar(GetDialogBar(), TRUE, bDelay);
  else
    ShowControlBar(GetDialogBar(), FALSE, bDelay);
  return (LONG)TRUE;
}


LRESULT CDbeventFrame::OnSetToolbarCaption(WPARAM wParam, LPARAM lParam)
{
  m_wndToolBar.SetWindowText((LPCSTR)lParam);
  return (LONG)TRUE;
}

BOOL CDbeventFrame::PreCreateWindow(CREATESTRUCT& cs) 
{
  // if unicenter driven: preset maximized state, if requested
  if (IsUnicenterDriven()) {
    CuCmdLineParse* pCmdLineParse = GetAutomatedGeneralDescriptor();
    ASSERT (pCmdLineParse);
    if (pCmdLineParse->DoWeMaximizeWin()) {
      // Note: Maximize MUST be combined with VISIBLE
      cs.style |= WS_MAXIMIZE | WS_VISIBLE;
		if (!theApp.CanCloseContextDrivenFrame())
		{
			cs.style &=~WS_SYSMENU;
		}
    }
  }
  return CMDIChildWnd::PreCreateWindow(cs);
}

void CDbeventFrame::OnClose() 
{
	if (!theApp.CanCloseContextDrivenFrame())
		return;
	CMDIChildWnd::OnClose();
}
