/*
**	Copyright (c) 2004 Actian Corporation
**	All rights reserved.
*/

# include	<compat.h> 
# include	<st.h> 
# include	<er.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<fe.h>
exec sql include	<ui.sh>;
exec sql include 	<uigdata.sh>;

/**
** Name:	uirelhlp.sc -	Get Relation Information for Help Routine.
**
** History:
**	Revision 6.4  1991/05/05  wong
**	Replaced 'version' test in 'IIUIrel_help()' with 'catalog_level' test.
**	20-mar-1991 (kathryn)
**		Added IIUI64rel_help() - New query to get help information for 
**		versions 6.4 and later.  The column "key_is_compressed" was 
**		added to iitables in release 6.4, and the value of this column 
**		is needed by the TM help facility.
**	10-May-1990 (fredv)
**		Added NO_OPTIM hint for ris_us5; otherwise, tm will SEGV on
**		"help table XXX".
**	27-jul-1992 (rdrane)
**		Add 6.5 support for owner.tablename, delimited identifiers,
**		and synonyms.  Tagged IIUI64rel_help() as being static to this
**		module, and added static module IIUI65rel_help();
**      06-mar-1996 (stial01)
**              Added IIUI66rel_help
**	17-jul-1996 (ramra01)
**		Added relversion and reltotwid for 66rel_help.
**	29-jan-1997 (hanch04)
**		Changed UI_LEVEL_66 to UI_LEVEL_800
**	27-Mar-1997 (jenjo02)
**	    Table priority project:
**	    Added reltcpri (table cache priority).
**      02-Sep-1997 (carsu07)
**		Changed the format to 1/1/1970 from the old format which was
**		1-1-1970. The old format caused a problem when II_DATE_FORMAT 
**		was set to SWEDEN or FINLAND.  It is not possible to choose
**		from the list of date formats the format n-m-n (dmy).
**		Instead the format n-n-n (ymd) is always chosen and this   
**		results in an error, stating that 1970 is not a valid day.
**		(See common/adf/adu/adutabdate.roc for the table of 
**		SWEDEN/FINLAND valid date formats). (Bug #59756)
**      23-Sep-1997 (kosma01)
**              Added no optim hint for rs4_us5
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	16-aug-2001 (toumi01)
**	    speculative i64_aix NO_OPTIM change for beta xlc_r - FIXME !!!
**	2-Jun-2004 (schka24)
**	    r3 additions for partitioned tables.
**    25-Oct-2005 (hanje04)
**        Add prototype for IIUI66rel_help() to prevent compiler
**        errors with GCC 4.0 due to conflict with implicit declaration.
**	30-May-2006 (jenjo02)
**	    Backed out Ingres2007 change to pick up "clustered" table 
**	    structure - no longer necessary.
**      28-jan-2009 (stial01)
**          Use DB_MAXNAME for database objects.
**	25-mar-2010 (toumi01) SIR 122403
**	    Add IIUI100rel_help and encryption support.
**	22-mar-2011 (stial01)
**	    Check for view-base dependency in iidbdepends since
**	    the view-base bit has been removed from iirelation. (again)
**/

/*
NO_OPTIM=ris_us5 rs4_us5 i64_aix
*/
char	*IIUIscl_StdCatLevel();

bool	IIUIdct_use_iitables();

static	DB_STATUS	IIUI64rel_help();
static	DB_STATUS	IIUI65rel_help();
static	DB_STATUS	IIUI66rel_help();
static	DB_STATUS	IIUIr3rel_help();
static	DB_STATUS	IIUI100rel_help();


/*{
** Name:    IIUIrel_help() - get relation info for one relation.
**
** Description:
**	This function fills a a statically defined UI_HELP_INFO structure 
**	for one relation and returns a pointer to that static structure.  
**	This static structure is reused upon next call to the routine, so 
**	all information must be copied into local data structures in order 
**	for it to remain after another call to IIUIrel_help().  The user
**	passes in the full name of the relation (no wildcards allowed).
**	IIUIrel_help does all dis-ambiguation nessesary to differenciate
**	between user owned and DBA owned relations.  If there is no relation
**	found, then the pointer to the UI_HELP_INFO structure will be
**	NULL;
**	the following is the description of the UI_HELP_INFO structure
**	char	table_name[DB_MAXNAME+1];
**	char	table_owner[DB_MAXNAME+1];
**	char	create_date[UI_DATESIZE+1];
**	char	alter_date[UI_DATESIZE+1];
**	char	table_type[2];
**	char	table_subtype[2]; 
**	char	table_version[9];
**	char	system_use[2];
**	char	table_stats[2];
**	char	table_indexes[2];
**	char	is_readonly[2];
**	i4	num_rows;
**	char	storage_structure[16];
**	char	is_compressed[2];
**	char	duplicate_rows[2];
**	char	unique_rule[2];
**	i4	number_pages;
**	i4	overflow_pages;
**	char	expire_date[UI_DATESIZE + 1]; 
**	char	table_integrities[2]; 
**	char	table_permits[2];
**	char	all_to_all[2]; 
**	char	ret_to_all[2]; 
**	i4	row_width;
**	char	is_journalled[2];
**	char	view_base[2]; 
**	char	multi_locations[2];
**	char	location_name[DB_MAXNAME + 1]; 
**	char	key_is_compressed[2];		* version 6.4 and later *
**      i4      page_size;                
**	i4	rel_version;
**	i4	rel_totwid;
**	i2	cache_pri;
**	u_i2	phys_partitions;		* New for r3 *
**	i2	partition_dimensions;
**	i4	rel_datawid;			* new for 10.0 *
**	i4	rel_totdatawid;			* new for 10.0 *
**	char	encrypted_columns[2];		* new for 10.0 *
**	char	encryption_type[7];		* new for 10.0 *
** UI_HELP_INFO;
**
** Inputs:
**	relname		Qualification string to be used as a query restriction
**			on the namestrings returned.  Any single value string
**			which identifies only one relation may be used.
**			This generally means that the qualification should be
**			fully specified, having no wild cards.
**	relowner	Name of the owner of the relation you want the
**			attributes of.  This is also expected to be in
**			normalized form.  However, it may also be specified
**			as NULL or an empty string for pre-6.5 compatibility
**			or when the true owner is unknown or unimportant.
** Outputs:
**	UI_HELP_INFO	**help_ptr	
**			*help_ptr will point to the static structure
**			containing the requested relation information
**			if the relation was found, otherwise *help_ptr will
**			be NULL.
**			
** Returns:
**	{STATUS}	OK			successful.
**			other			DBMS error returned
** History:
**	12-mar-90 (teresal)
**		Modified so expire date will be converted into the correct
**		century. (Fix for Bug 8442)
**	20-mar-1991 (kathryn)
**		If running on DBMS release 6.4 or greater, call IIUI64rel_help()
**		to perform query. This new query includes "key_is_compressed" 
**		which was not available prior to 6.4
**	05-may-1991 (jhw) Replaced 'version' test with 'catalog_level' test.
**		Bug #36993.
**	17-may-1991 (kathryn)
**		Correct query against iiphysical_tables, which attempted to
**		select non-existent columns.
**	27-jul-1992 (rdrane)
**		Add 6.5 support for owner.tablename, delimited identifiers,
**		and synonyms.  Change parameterization to include owner.
**		Indicate that both relname and relowner are expected to be
**		normalized, and that owner may be NULL or an empty string
**		(relowner only used if 6.5).
**      06-mar-1996 (stial01)
**              Call IIUI66rel_help for 6.6 catalogs
**	27-Mar-1997 (jenjo02)
**	    Table priority project:
**	    Added reltcpri (table cache priority).
**	02-Sep-1997 (carsu07)
**		Changed the format to 1/1/1970 from the old format which was	
**		1-1-1970. The old format caused a problem when II_DATE_FORMAT 
**		was set to SWEDEN or FINLAND.  It is not possible to choose
**		from the list of date formats the format n-m-n (dmy).      
**		Instead the format n-n-n (ymd) is always chosen and this   
**		results in an error when the date is 1-1-1970 because 1970
**		is interpreted as a day.  To avoid this, the date format was
**		changed. (See common/adf/adu/adutabdate.roc for the table of 
**		SWEDEN/FINLAND valid date formats). (Bug #59756)
**      08-Feb-2000 (hanal04) Bug 99787 Problem INGSRV 1075.
**              Remove use of _date() and _time() functions in the 
**              computation of SAVE UNTIL (expires on) dates. Now use
**              gmt_timestamp(). Change as per natjo01 change 276883.
*/
EXEC SQL BEGIN DECLARE SECTION;
static	UI_HELP_INFO	help_info[2];
EXEC SQL END DECLARE SECTION;

DB_STATUS
IIUIrel_help(relname,relowner,help_ptr)
EXEC SQL BEGIN DECLARE SECTION;
char		*relname;
char		*relowner;
UI_HELP_INFO	**help_ptr;
EXEC SQL END DECLARE SECTION;
{
	EXEC SQL BEGIN DECLARE SECTION;
	UIDBDATA	*uidbdata;
	i4		errnum, i = 0;
	i4		save_date[2];
	float		ftemp;
	EXEC SQL END DECLARE SECTION;

	uidbdata = IIUIdbdata();

	/* Init page size in case level < UI_LEVEL_800 */
	help_info[0].page_size = help_info[1].page_size = 2048;
	help_info[0].rel_version = help_info[1].rel_version = 0;
	help_info[0].rel_totwid = help_info[1].rel_totwid = 0;
	help_info[0].rel_datawid = help_info[1].rel_datawid = 0;
	help_info[0].rel_totdatawid = help_info[1].rel_totdatawid = 0;
	help_info[0].cache_pri = help_info[1].cache_pri = 0;
	help_info[0].phys_partitions = help_info[1].phys_partitions = 0;
	help_info[0].partition_dimensions = help_info[1].partition_dimensions = 0;

	if  (STcompare(IIUIscl_StdCatLevel(),UI_LEVEL_1000) >= 0)
	{ /* 10.0 or later standard catalogs */
	    if  ((errnum = IIUI100rel_help(relname,relowner,&i,save_date,
					  uidbdata)) != OK)
		return(errnum);
	}
	else if  (STcompare(IIUIscl_StdCatLevel(),UI_LEVEL_900) >= 0)
	{ /* r3 or later standard catalogs */
	    if  ((errnum = IIUIr3rel_help(relname,relowner,&i,save_date,
					  uidbdata)) != OK)
		return(errnum);
	}
	else if  (STcompare(IIUIscl_StdCatLevel(),UI_LEVEL_800) >= 0)
	{ /* 6.6 or later standard catalogs */
	    if  ((errnum = IIUI66rel_help(relname,relowner,&i,save_date,
					  uidbdata)) != OK)
		return(errnum);
	}
	else if  (STcompare(IIUIscl_StdCatLevel(),UI_LEVEL_65) == 0)
	{ /* 6.5 or later standard catalogs */
	    if  ((errnum = IIUI65rel_help(relname,relowner,&i,save_date,
					  uidbdata)) != OK)
		return(errnum);
	}
	else if (STcompare(IIUIscl_StdCatLevel(), UI_LEVEL_64) == 0)
	{ /* 6.4 standard catalogs */
	    if (errnum = IIUI64rel_help(relname,&i,save_date,uidbdata) != OK)
		return(errnum);
	}
	else
	{
	EXEC SQL REPEATED SELECT 
			table_name,
			table_owner,
			create_date,
		 	table_type,
			table_subtype,
			table_version,
                	system_use,
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			table_integrities,
			table_permits,
			all_to_all,
			ret_to_all,
			row_width,
                	is_journalled,
			multi_locations,
			view_base,
			location_name,
			expire_date
		INTO
			:help_info[i].table_name,
			:help_info[i].table_owner,
			:help_info[i].create_date,
			:help_info[i].table_type,
			:help_info[i].table_subtype,
			:help_info[i].table_version,
			:help_info[i].system_use,
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].table_integrities,
			:help_info[i].table_permits,
			:help_info[i].all_to_all,
			:help_info[i].ret_to_all,
			:help_info[i].row_width,
			:help_info[i].is_journalled,
			:help_info[i].multi_locations,
			:help_info[i].view_base,
			:help_info[i].location_name,
			:save_date[i]
		FROM 
			iitables
		WHERE
			table_name = :relname
		    AND
			( table_owner = :uidbdata->suser
				OR table_owner = :uidbdata->sdba
				OR table_owner = :uidbdata->catowner
			);
	EXEC SQL BEGIN;
		STtrmwhite(help_info[i].table_name);
		STtrmwhite(help_info[i].table_owner);
		STcopy(help_info[i].create_date, help_info[i].alter_date);
		/* encryption project added logical widths for 10.0 */
		help_info[i].rel_datawid = help_info[i].row_width;
		i++;
	EXEC SQL END;
	EXEC SQL INQUIRE_INGRES (:errnum = errorno);
	if ( errnum != OK )
		return errnum;

	if ( !IIUIdct_use_iitables() )
	{
		EXEC SQL REPEATED SELECT 
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			row_width
			INTO
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].row_width
			FROM 
				iiphysical_tables
			WHERE
				table_name = :relname
		    	AND
				((table_owner = :uidbdata->suser) OR
				(table_owner = :uidbdata->sdba) OR
				(table_owner = :uidbdata->catowner));
		EXEC SQL BEGIN;
			STtrmwhite(help_info[i].table_name);
			STtrmwhite(help_info[i].table_owner);
			STcopy(help_info[i].create_date, help_info[i].alter_date);
			/* encryption project added logical widths for 10.0 */
			help_info[i].rel_datawid = help_info[i].row_width;
			i++;
		EXEC SQL END;
		EXEC SQL INQUIRE_INGRES (:errnum = errorno);
		if ( errnum != OK )
			return errnum;
	}
	}

	if ( i == 2 && STequal(uidbdata->suser, help_info[1].table_owner) )
	{
		if (save_date[1] > 0)
		{
			/* this is a terrible hack, and eventually a new
			** FE routine should be written to call ADF to
			** convert a _bintime into a gmt date, but this
			** code will ONLY be executed if a user wants
			** detailed information about a table with
			** an expiration date.  I am assuming that
			** this is a relatively rare occurance, and that
			** the increase in performance for the usual
			** case will balance out the performance hit
			** for the case with a table with an expire date
			**
			** Note there is a bug in _date() such that it doesn't
			** return the correct century (if >= 2000) _date can't
			** be changed (it's already published) so another
			** hack has been implemented here to convert to
			** the correct century. Assumptions: timestamps are
			** never older than 1970 and this hack only works until
			** 2069. (Bug fix 8442)
			*/
		 
                        /* Now use gmt_timestamp for this */
                        EXEC SQL SELECT gmt_timestamp(:save_date[1])
                                INTO :help_info[1].expire_date;
	
		}
		else
		{
			help_info[1].expire_date[0] = EOS;
		}
		*help_ptr = &(help_info[1]);
	}
	else if (i == 0)
	{
		*help_ptr = (UI_HELP_INFO *) NULL;
	}
	else
	{
		if (save_date[0] > 0)
		{
			/* this is a terrible hack, and eventually a new
			** FE routine should be written to call ADF to
			** convert a _bintime into a gmt date, but this
			** code will ONLY be executed if a user wants
			** detailed information about a table with
			** an expiration date.  I am assuming that
			** this is a relatively rare occurance, and that
			** the increase in performance for the usual
			** case will balance out the performance hit
			** for the case with a table with an expire date
			**
			** Note there is a bug in _date() such that it doesn't
			** return the correct century (if >= 2000) _date can't
			** be changed (it's already published) so another
			** hack has been implemented here to convert to
			** the correct century. Assumptions: timestamps are
			** never older than 1970 and this hack only works until
			** 2069. (Bug fix 8442)
			*/
			 
                        /* Now use gmt_timestamp to get the date+time */
                        EXEC SQL SELECT gmt_timestamp(:save_date[0])
                                INTO :help_info[0].expire_date;

		}
		else
		{
			help_info[0].expire_date[0] = EOS;
		}
		*help_ptr = &(help_info[0]);
	}
	return OK;
}

/*
** Name:  IIUI64rel_help - Query for relation help info - vers 6.4.
**
** Description:
**	Fills the  statically defined UI_HELP_INFO structure for one relation.
**
** Inputs:
**      relname         Qualification string to be used as a query restriction
**                      on the namestrings returned.  Any single value string
**                      which identifies only one relation may be used.
**                      This generally means that the qualification should be
**                      fully specified, having no wild cards.
**	ind:		Index of help_info structure to be filled.
**	uidbdata:	Current user/dba info.
**
** Ouputs:
**	save_date[]:	Expire_date of relation as retrieved from iitables.
**	ind:		Index of help_info structure is incremented.
**
**	Returns:
**		OK	successful.
**		other	DBMS error returned.
**
** Side Effects:
**	UI_HELP_INFO: 	Help_info structure contains the requested relation 
**			information.
**
** History:
**	20-mar-1991 (kathryn)
**		Written.
**	27-jul-1992 (rdrane)
**		Tag routine as being static.
*/

static
DB_STATUS
IIUI64rel_help(relname,ind,save_date,uidbdata)
EXEC SQL BEGIN DECLARE SECTION;
char		*relname;
i4		*ind;
i4		save_date[];
UIDBDATA	*uidbdata;
EXEC SQL END DECLARE SECTION;
{

	EXEC SQL BEGIN DECLARE SECTION;
		i4             errnum, i;
	EXEC SQL END DECLARE SECTION;

	i = *ind;
	
	EXEC SQL REPEATED SELECT 
			table_name,
			table_owner,
			create_date,
		 	table_type,
			table_subtype,
			table_version,
                	system_use,
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			table_integrities,
			table_permits,
			all_to_all,
			ret_to_all,
			row_width,
                	is_journalled,
			multi_locations,
			view_base,
			location_name,
			expire_date,
			key_is_compressed
		INTO
			:help_info[i].table_name,
			:help_info[i].table_owner,
			:help_info[i].create_date,
			:help_info[i].table_type,
			:help_info[i].table_subtype,
			:help_info[i].table_version,
			:help_info[i].system_use,
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].table_integrities,
			:help_info[i].table_permits,
			:help_info[i].all_to_all,
			:help_info[i].ret_to_all,
			:help_info[i].row_width,
			:help_info[i].is_journalled,
			:help_info[i].multi_locations,
			:help_info[i].view_base,
			:help_info[i].location_name,
			:save_date[i],
			:help_info[i].key_is_compressed
		FROM 
			iitables
		WHERE
			table_name = :relname
		    AND
			( table_owner = :uidbdata->suser
				OR table_owner = :uidbdata->sdba
				OR table_owner = :uidbdata->catowner
			);
	EXEC SQL BEGIN;
		STtrmwhite(help_info[i].table_name);
		STtrmwhite(help_info[i].table_owner);
		STcopy(help_info[i].create_date, help_info[i].alter_date);
		/* encryption project added logical widths for 10.0 */
		help_info[i].rel_datawid = help_info[i].row_width;
		i++;
	EXEC SQL END;
	EXEC SQL INQUIRE_INGRES (:errnum = errorno);
	if ( errnum != OK )
		return errnum;

	if ( !IIUIdct_use_iitables() )
	{
		EXEC SQL REPEATED SELECT 
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			row_width,
			key_is_compressed
			INTO
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].row_width,
			:help_info[i].key_is_compressed
			FROM 
				iiphysical_tables
			WHERE
				table_name = :relname
		    	AND
				((table_owner = :uidbdata->suser) OR
				(table_owner = :uidbdata->sdba) OR
				(table_owner = :uidbdata->catowner));
		EXEC SQL BEGIN;
			STtrmwhite(help_info[i].table_name);
			STtrmwhite(help_info[i].table_owner);
			STcopy(help_info[i].create_date, help_info[i].alter_date);
			/* encryption project added logical widths for 10.0 */
			help_info[i].rel_datawid = help_info[i].row_width;
			i++;
		EXEC SQL END;
		EXEC SQL INQUIRE_INGRES (:errnum = errorno);
		if ( errnum != OK )
			return errnum;
	}
	*ind = i;
	return OK;
}


/*
** Name:  IIUI65rel_help - Query for relation help info - vers 6.5 and later.
**
** Description:
**	Fills the  statically defined UI_HELP_INFO structure for one relation.
**	If the specified relation is a synonym, then the information returned
**	including the table name and owner will refect that of the base table.
**
** Inputs:
**      relname         Name of the relation for which information is to be
**                      returned.  This is expected to be normalized and to
**	 		not contain any wildcards.  It may be a synonym.
**	relowner	Name of the owner of the relation for which information
**			is to be returned.  This is also expected to be in
**			normalized form.  However, it may also be specified
**			as NULL or an empty string when the true owner is
**			unknown or unimportant.
**	ind:		Index of help_info structure to be filled.
**	uidbdata:	Current user/dba info.
**
** Ouputs:
**	save_date[]:	Expire_date of relation as retrieved from iitables.
**	ind:		Index of help_info structure is incremented.
**
**	Returns:
**		OK	successful.
**		other	DBMS error returned.
**
** Side Effects:
**	UI_HELP_INFO: 	Help_info structure contains the requested relation 
**			information.
**
** History:
**	27-jul-1992 (rdrane)
**		Created from IIUI64rel_help().  Invokes FE_resolve() to handle
**		any synonyms.  STtrmwhite() can return an empty string if all
**		whitespace - need to detect this and force the result to be
**		one space.  Note that information for only one relation
**		will be returned.
**	21-apr-1994 (connie) Bug #49807
**		If the relowner is NULL, the query result from iitables
**		should be the same as initial index value and should not
**		fail out in this case, so > 1 is used instead of != 1.
*/

static
DB_STATUS
IIUI65rel_help(relname,relowner,ind,save_date,uidbdata)
char		*relname;
char		*relowner;
EXEC SQL BEGIN DECLARE SECTION;
i4		*ind;
i4		save_date[];
UIDBDATA	*uidbdata;
EXEC SQL END DECLARE SECTION;
{
EXEC SQL BEGIN DECLARE SECTION;
i4              errnum, i;
char		relname_buf[(DB_MAXNAME + 1)];
char		relowner_buf[(DB_MAXNAME + 1)];
EXEC SQL END DECLARE SECTION;
FE_RSLV_NAME	w_frn;


	i = *ind;	/* Save initial value of help_info index	*/

	/*
	** Effect any synonym resolution, and determine any true owner.
	*/
	w_frn.owner_dest = &relowner_buf[0];
	w_frn.name_dest = &relname_buf[0];
	if  (!FE_resolve(&w_frn,relname,relowner))
	{
	    /*
	    ** No relations meet qualification
	    */
	    return(OK);
	}

	EXEC SQL REPEATED SELECT 
			table_name,
			table_owner,
			create_date,
		 	table_type,
			table_subtype,
			table_version,
                	system_use,
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			table_integrities,
			table_permits,
			all_to_all,
			ret_to_all,
			row_width,
                	is_journalled,
			multi_locations,
			view_base,
			location_name,
			expire_date,
			key_is_compressed
		INTO
			:help_info[i].table_name,
			:help_info[i].table_owner,
			:help_info[i].create_date,
			:help_info[i].table_type,
			:help_info[i].table_subtype,
			:help_info[i].table_version,
			:help_info[i].system_use,
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].table_integrities,
			:help_info[i].table_permits,
			:help_info[i].all_to_all,
			:help_info[i].ret_to_all,
			:help_info[i].row_width,
			:help_info[i].is_journalled,
			:help_info[i].multi_locations,
			:help_info[i].view_base,
			:help_info[i].location_name,
			:save_date[i],
			:help_info[i].key_is_compressed
		FROM 
			iitables
		WHERE
			table_name = :relname_buf
		    AND
			table_owner = :relowner_buf;
	EXEC SQL BEGIN;
		if  (STtrmwhite(help_info[i].table_name) == 0)
		{
		    STcopy(ERx(" "),help_info[i].table_name);
		}
		if  (STtrmwhite(help_info[i].table_owner) == 0)
		{
		    STcopy(ERx(" "),help_info[i].table_owner);
		}
		STcopy(help_info[i].create_date, help_info[i].alter_date);
		/* encryption project added logical widths for 10.0 */
		help_info[i].rel_datawid = help_info[i].row_width;
		i++;
	EXEC SQL END;
	EXEC SQL INQUIRE_INGRES (:errnum = errorno);
	if ( errnum != OK )
	{
	    return(errnum);
	}
	if  ((i - *ind) > 1)	/* Should never find more than one! */
	{
	    return(FAIL);
	}

	if ( !IIUIdct_use_iitables() )
	{
		EXEC SQL REPEATED SELECT 
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			row_width,
			key_is_compressed
			INTO
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].row_width,
			:help_info[i].key_is_compressed
			FROM 
				iiphysical_tables
			WHERE
				table_name = :relname_buf
			    AND
				table_owner = :relowner_buf;
		EXEC SQL BEGIN;
			if  (STtrmwhite(help_info[i].table_name) == 0)
			{
			    STcopy(ERx(" "),help_info[i].table_name);
			}
			if  (STtrmwhite(help_info[i].table_owner) == 0)
			{
			    STcopy(ERx(" "),help_info[i].table_owner);
			}
			STcopy(help_info[i].create_date,
			       help_info[i].alter_date);
			/* encryption project added logical widths for 10.0 */
			help_info[i].rel_datawid = help_info[i].row_width;
			i++;
		EXEC SQL END;
		EXEC SQL INQUIRE_INGRES (:errnum = errorno);
		if  (errnum != OK )
		{
		    return(errnum);
		}
		if  ((i - *ind) > 1)	/* Should never find more than one! */
		{
		    return(FAIL);
		}
	}

	*ind = i;
	return(OK);
}
/*
** Name:  IIUI66rel_help - Query for relation help info - vers 6.6 and later.
**
** Description:
**	Fills the  statically defined UI_HELP_INFO structure for one relation.
**	If the specified relation is a synonym, then the information returned
**	including the table name and owner will refect that of the base table.
**
** Inputs:
**      relname         Name of the relation for which information is to be
**                      returned.  This is expected to be normalized and to
**	 		not contain any wildcards.  It may be a synonym.
**	relowner	Name of the owner of the relation for which information
**			is to be returned.  This is also expected to be in
**			normalized form.  However, it may also be specified
**			as NULL or an empty string when the true owner is
**			unknown or unimportant.
**	ind:		Index of help_info structure to be filled.
**	uidbdata:	Current user/dba info.
**
** Ouputs:
**	save_date[]:	Expire_date of relation as retrieved from iitables.
**	ind:		Index of help_info structure is incremented.
**
**	Returns:
**		OK	successful.
**		other	DBMS error returned.
**
** Side Effects:
**	UI_HELP_INFO: 	Help_info structure contains the requested relation 
**			information.
**
** History:
**      06-mar-1996 (stial01)
**              Created from IIUI65rel_help().
**	27-Mar-1997 (jenjo02)
**	    Table priority project:
**	    Added reltcpri (table cache priority).
*/

static
DB_STATUS
IIUI66rel_help(relname,relowner,ind,save_date,uidbdata)
char		*relname;
char		*relowner;
EXEC SQL BEGIN DECLARE SECTION;
i4		*ind;
i4		save_date[];
UIDBDATA	*uidbdata;
EXEC SQL END DECLARE SECTION;
{
EXEC SQL BEGIN DECLARE SECTION;
i4              errnum, i;
char		relname_buf[(DB_MAXNAME + 1)];
char		relowner_buf[(DB_MAXNAME + 1)];
EXEC SQL END DECLARE SECTION;
FE_RSLV_NAME	w_frn;


	i = *ind;	/* Save initial value of help_info index	*/

	/*
	** Effect any synonym resolution, and determine any true owner.
	*/
	w_frn.owner_dest = &relowner_buf[0];
	w_frn.name_dest = &relname_buf[0];
	if  (!FE_resolve(&w_frn,relname,relowner))
	{
	    /*
	    ** No relations meet qualification
	    */
	    return(OK);
	}

	EXEC SQL REPEATED SELECT 
			table_name,
			table_owner,
			create_date,
		 	table_type,
			table_subtype,
			table_version,
                	system_use,
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			table_integrities,
			table_permits,
			all_to_all,
			ret_to_all,
			row_width,
                	is_journalled,
			multi_locations,
			view_base,
			location_name,
			expire_date,
			key_is_compressed,
			table_pagesize,
			table_relversion,
			table_reltotwid,
			table_reltcpri
		INTO
			:help_info[i].table_name,
			:help_info[i].table_owner,
			:help_info[i].create_date,
			:help_info[i].table_type,
			:help_info[i].table_subtype,
			:help_info[i].table_version,
			:help_info[i].system_use,
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].table_integrities,
			:help_info[i].table_permits,
			:help_info[i].all_to_all,
			:help_info[i].ret_to_all,
			:help_info[i].row_width,
			:help_info[i].is_journalled,
			:help_info[i].multi_locations,
			:help_info[i].view_base,
			:help_info[i].location_name,
			:save_date[i],
			:help_info[i].key_is_compressed,
			:help_info[i].page_size,
			:help_info[i].rel_version,
			:help_info[i].rel_totwid,
			:help_info[i].cache_pri
		FROM 
			iitables
		WHERE
			table_name = :relname_buf
		    AND
			table_owner = :relowner_buf;
	EXEC SQL BEGIN;
		if  (STtrmwhite(help_info[i].table_name) == 0)
		{
		    STcopy(ERx(" "),help_info[i].table_name);
		}
		if  (STtrmwhite(help_info[i].table_owner) == 0)
		{
		    STcopy(ERx(" "),help_info[i].table_owner);
		}
		STcopy(help_info[i].create_date, help_info[i].alter_date);
		/* encryption project added logical widths for 10.0 */
		help_info[i].rel_datawid = help_info[i].row_width;
		help_info[i].rel_totdatawid = help_info[i].rel_totwid;
		i++;
	EXEC SQL END;
	EXEC SQL INQUIRE_INGRES (:errnum = errorno);
	if ( errnum != OK )
	{
	    return(errnum);
	}
	if  ((i - *ind) > 1)	/* Should never find more than one! */
	{
	    return(FAIL);
	}

	if ( !IIUIdct_use_iitables() )
	{
		EXEC SQL REPEATED SELECT 
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			row_width,
			key_is_compressed
			INTO
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].row_width,
			:help_info[i].key_is_compressed
			FROM 
				iiphysical_tables
			WHERE
				table_name = :relname_buf
			    AND
				table_owner = :relowner_buf;
		EXEC SQL BEGIN;
			if  (STtrmwhite(help_info[i].table_name) == 0)
			{
			    STcopy(ERx(" "),help_info[i].table_name);
			}
			if  (STtrmwhite(help_info[i].table_owner) == 0)
			{
			    STcopy(ERx(" "),help_info[i].table_owner);
			}
			STcopy(help_info[i].create_date,
			       help_info[i].alter_date);
			/* encryption project added logical widths for 10.0 */
			help_info[i].rel_datawid = help_info[i].row_width;
			i++;
		EXEC SQL END;
		EXEC SQL INQUIRE_INGRES (:errnum = errorno);
		if  (errnum != OK )
		{
		    return(errnum);
		}
		if  ((i - *ind) > 1)	/* Should never find more than one! */
		{
		    return(FAIL);
		}
	}

	if (help_info[i].page_size == 0)
	    help_info[i].page_size = 2048;

	*ind = i;
	return(OK);
}
/*
** Name:  IIUIr3rel_help - Query for relation help info - release 3 and later.
**
** Description:
**	Fills the  statically defined UI_HELP_INFO structure for one relation.
**	If the specified relation is a synonym, then the information returned
**	including the table name and owner will refect that of the base table.
**
**	This clone is for release 3 catalogs which include partitioning info.
**	It would be slicker to come up with some kind of dynamic query,
**	but then it couldn't be REPEATED.
**
** Inputs:
**      relname         Name of the relation for which information is to be
**                      returned.  This is expected to be normalized and to
**	 		not contain any wildcards.  It may be a synonym.
**	relowner	Name of the owner of the relation for which information
**			is to be returned.  This is also expected to be in
**			normalized form.  However, it may also be specified
**			as NULL or an empty string when the true owner is
**			unknown or unimportant.
**	ind:		Index of help_info structure to be filled.
**	uidbdata:	Current user/dba info.
**
** Ouputs:
**	save_date[]:	Expire_date of relation as retrieved from iitables.
**	ind:		Index of help_info structure is incremented.
**
**	Returns:
**		OK	successful.
**		other	DBMS error returned.
**
** Side Effects:
**	UI_HELP_INFO: 	Help_info structure contains the requested relation 
**			information.
**
** History:
**	2-Jun-2004 (schka24)
**	    Yet another clone, for new r3 columns.
*/

static
DB_STATUS
IIUIr3rel_help(relname,relowner,ind,save_date,uidbdata)
char		*relname;
char		*relowner;
EXEC SQL BEGIN DECLARE SECTION;
i4		*ind;
i4		save_date[];
UIDBDATA	*uidbdata;
EXEC SQL END DECLARE SECTION;
{
EXEC SQL BEGIN DECLARE SECTION;
i4              errnum, i;
char		relname_buf[(DB_MAXNAME + 1)];
char		relowner_buf[(DB_MAXNAME + 1)];
EXEC SQL END DECLARE SECTION;
FE_RSLV_NAME	w_frn;


	i = *ind;	/* Save initial value of help_info index	*/

	/*
	** Effect any synonym resolution, and determine any true owner.
	*/
	w_frn.owner_dest = &relowner_buf[0];
	w_frn.name_dest = &relname_buf[0];
	if  (!FE_resolve(&w_frn,relname,relowner))
	{
	    /*
	    ** No relations meet qualification
	    */
	    return(OK);
	}

	EXEC SQL REPEATED SELECT 
			table_name,
			table_owner,
			create_date,
		 	table_type,
			table_subtype,
			table_version,
                	system_use,
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			table_integrities,
			table_permits,
			all_to_all,
			ret_to_all,
			row_width,
                	is_journalled,
			multi_locations,
			view_base,
			location_name,
			expire_date,
			key_is_compressed,
			table_pagesize,
			table_relversion,
			table_reltotwid,
			table_reltcpri,
			phys_partitions,
			partition_dimensions
		INTO
			:help_info[i].table_name,
			:help_info[i].table_owner,
			:help_info[i].create_date,
			:help_info[i].table_type,
			:help_info[i].table_subtype,
			:help_info[i].table_version,
			:help_info[i].system_use,
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].table_integrities,
			:help_info[i].table_permits,
			:help_info[i].all_to_all,
			:help_info[i].ret_to_all,
			:help_info[i].row_width,
			:help_info[i].is_journalled,
			:help_info[i].multi_locations,
			:help_info[i].view_base,
			:help_info[i].location_name,
			:save_date[i],
			:help_info[i].key_is_compressed,
			:help_info[i].page_size,
			:help_info[i].rel_version,
			:help_info[i].rel_totwid,
			:help_info[i].cache_pri,
			:help_info[i].phys_partitions,
			:help_info[i].partition_dimensions
		FROM 
			iitables
		WHERE
			table_name = :relname_buf
		    AND
			table_owner = :relowner_buf;
	EXEC SQL BEGIN;
		if  (STtrmwhite(help_info[i].table_name) == 0)
		{
		    STcopy(ERx(" "),help_info[i].table_name);
		}
		if  (STtrmwhite(help_info[i].table_owner) == 0)
		{
		    STcopy(ERx(" "),help_info[i].table_owner);
		}
		STcopy(help_info[i].create_date, help_info[i].alter_date);
		/* encryption project added logical widths for 10.0 */
		help_info[i].rel_datawid = help_info[i].row_width;
		help_info[i].rel_totdatawid = help_info[i].rel_totwid;
		i++;
	EXEC SQL END;
	EXEC SQL INQUIRE_INGRES (:errnum = errorno);
	if ( errnum != OK )
	{
	    return(errnum);
	}
	if  ((i - *ind) > 1)	/* Should never find more than one! */
	{
	    return(FAIL);
	}

	if ( !IIUIdct_use_iitables() )
	{
		EXEC SQL REPEATED SELECT 
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			row_width,
			key_is_compressed
			INTO
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].row_width,
			:help_info[i].key_is_compressed
			FROM 
				iiphysical_tables
			WHERE
				table_name = :relname_buf
			    AND
				table_owner = :relowner_buf;
		EXEC SQL BEGIN;
			if  (STtrmwhite(help_info[i].table_name) == 0)
			{
			    STcopy(ERx(" "),help_info[i].table_name);
			}
			if  (STtrmwhite(help_info[i].table_owner) == 0)
			{
			    STcopy(ERx(" "),help_info[i].table_owner);
			}
			STcopy(help_info[i].create_date,
			       help_info[i].alter_date);
			/* encryption project added logical widths for 10.0 */
			help_info[i].rel_datawid = help_info[i].row_width;
			help_info[i].rel_totdatawid = help_info[i].rel_totwid;
			i++;
		EXEC SQL END;
		EXEC SQL INQUIRE_INGRES (:errnum = errorno);
		if  (errnum != OK )
		{
		    return(errnum);
		}
		if  ((i - *ind) > 1)	/* Should never find more than one! */
		{
		    return(FAIL);
		}
	}

	/* Should never be true for an r3 database but I'll leave it */
	if (help_info[i].page_size == 0)
	    help_info[i].page_size = 2048;

	*ind = i;
	return(OK);
}
/*
** Name:  IIUI100rel_help - Query for relation help info - release 10 and later.
**
** Description:
**	Fills the  statically defined UI_HELP_INFO structure for one relation.
**	If the specified relation is a synonym, then the information returned
**	including the table name and owner will refect that of the base table.
**
**	This clone is for release 10 catalogs which include encryption info.
**	It would be slicker to come up with some kind of dynamic query,
**	but then it couldn't be REPEATED.
**
** Inputs:
**      relname         Name of the relation for which information is to be
**                      returned.  This is expected to be normalized and to
**	 		not contain any wildcards.  It may be a synonym.
**	relowner	Name of the owner of the relation for which information
**			is to be returned.  This is also expected to be in
**			normalized form.  However, it may also be specified
**			as NULL or an empty string when the true owner is
**			unknown or unimportant.
**	ind:		Index of help_info structure to be filled.
**	uidbdata:	Current user/dba info.
**
** Ouputs:
**	save_date[]:	Expire_date of relation as retrieved from iitables.
**	ind:		Index of help_info structure is incremented.
**
**	Returns:
**		OK	successful.
**		other	DBMS error returned.
**
** Side Effects:
**	UI_HELP_INFO: 	Help_info structure contains the requested relation 
**			information.
**
** History:
**	24-Mar-2010 (toumi01) SIR 122403
**	    Yet another clone clone, for new 10.0 columns.
**	13-may-2010 (miket) SIR 122403
**	    Fix net-change logic for width for ALTER TABLE.
*/

static
DB_STATUS
IIUI100rel_help(relname,relowner,ind,save_date,uidbdata)
char		*relname;
char		*relowner;
EXEC SQL BEGIN DECLARE SECTION;
i4		*ind;
i4		save_date[];
UIDBDATA	*uidbdata;
EXEC SQL END DECLARE SECTION;
{
EXEC SQL BEGIN DECLARE SECTION;
i4              errnum, i;
char		relname_buf[(DB_MAXNAME + 1)];
char		relowner_buf[(DB_MAXNAME + 1)];
i4		table_reltid;
i4		table_reltidx;
i4		cnt;
EXEC SQL END DECLARE SECTION;
FE_RSLV_NAME	w_frn;
static bool	iidbdepends_known = FALSE, iidbdepends_exists = FALSE;


	i = *ind;	/* Save initial value of help_info index	*/

	/*
	** Effect any synonym resolution, and determine any true owner.
	*/
	w_frn.owner_dest = &relowner_buf[0];
	w_frn.name_dest = &relname_buf[0];
	if  (!FE_resolve(&w_frn,relname,relowner))
	{
	    /*
	    ** No relations meet qualification
	    */
	    return(OK);
	}

	EXEC SQL REPEATED SELECT 
			table_name,
			table_owner,
			create_date,
		 	table_type,
			table_subtype,
			table_version,
                	system_use,
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			table_integrities,
			table_permits,
			all_to_all,
			ret_to_all,
			row_width,
                	is_journalled,
			multi_locations,
			view_base,
			location_name,
			expire_date,
			key_is_compressed,
			table_pagesize,
			table_relversion,
			table_reltotwid,
			table_reltcpri,
			phys_partitions,
			partition_dimensions,
			table_reldatawid,
			table_reltotdatawid,
			encrypted_columns,
			encryption_type,
			table_reltid,
			table_reltidx
		INTO
			:help_info[i].table_name,
			:help_info[i].table_owner,
			:help_info[i].create_date,
			:help_info[i].table_type,
			:help_info[i].table_subtype,
			:help_info[i].table_version,
			:help_info[i].system_use,
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].table_integrities,
			:help_info[i].table_permits,
			:help_info[i].all_to_all,
			:help_info[i].ret_to_all,
			:help_info[i].row_width,
			:help_info[i].is_journalled,
			:help_info[i].multi_locations,
			:help_info[i].view_base,
			:help_info[i].location_name,
			:save_date[i],
			:help_info[i].key_is_compressed,
			:help_info[i].page_size,
			:help_info[i].rel_version,
			:help_info[i].rel_totwid,
			:help_info[i].cache_pri,
			:help_info[i].phys_partitions,
			:help_info[i].partition_dimensions,
			:help_info[i].rel_datawid,
			:help_info[i].rel_totdatawid,
			:help_info[i].encrypted_columns,
			:help_info[i].encryption_type,
			:table_reltid,
			:table_reltidx
		FROM 
			iitables
		WHERE
			table_name = :relname_buf
		    AND
			table_owner = :relowner_buf;
	EXEC SQL BEGIN;
		if  (STtrmwhite(help_info[i].table_name) == 0)
		{
		    STcopy(ERx(" "),help_info[i].table_name);
		}
		if  (STtrmwhite(help_info[i].table_owner) == 0)
		{
		    STcopy(ERx(" "),help_info[i].table_owner);
		}
		STcopy(help_info[i].create_date, help_info[i].alter_date);
		i++;
	EXEC SQL END;
	EXEC SQL INQUIRE_INGRES (:errnum = errorno);
	if ( errnum != OK )
	{
	    return(errnum);
	}
	if  ((i - *ind) > 1)	/* Should never find more than one! */
	{
	    return(FAIL);
	}

	if ( !IIUIdct_use_iitables() )
	{
		EXEC SQL REPEATED SELECT 
			table_stats,
			table_indexes,
			is_readonly,
			num_rows,
			storage_structure,
			is_compressed,
			duplicate_rows,
			unique_rule,
			number_pages,
                	overflow_pages,
			row_width,
			key_is_compressed
			INTO
			:help_info[i].table_stats,
			:help_info[i].table_indexes,
			:help_info[i].is_readonly,
			:help_info[i].num_rows,
			:help_info[i].storage_structure,
			:help_info[i].is_compressed,
			:help_info[i].duplicate_rows,
			:help_info[i].unique_rule,
			:help_info[i].number_pages,
			:help_info[i].overflow_pages,
			:help_info[i].row_width,
			:help_info[i].key_is_compressed
			FROM 
				iiphysical_tables
			WHERE
				table_name = :relname_buf
			    AND
				table_owner = :relowner_buf;
		EXEC SQL BEGIN;
			if  (STtrmwhite(help_info[i].table_name) == 0)
			{
			    STcopy(ERx(" "),help_info[i].table_name);
			}
			if  (STtrmwhite(help_info[i].table_owner) == 0)
			{
			    STcopy(ERx(" "),help_info[i].table_owner);
			}
			STcopy(help_info[i].create_date,
			       help_info[i].alter_date);
			/* encryption project added logical widths for 10.0 */
			help_info[i].rel_datawid = help_info[i].row_width;
			i++;
		EXEC SQL END;
		EXEC SQL INQUIRE_INGRES (:errnum = errorno);
		if  (errnum != OK )
		{
		    return(errnum);
		}
		if  ((i - *ind) > 1)	/* Should never find more than one! */
		{
		    return(FAIL);
		}
	}

	if ( IIUIdct_use_iitables() )
	{
	    /* Figure out VBASE from iidbdepends, if it exists.
	    ** Use of static bools here OK, tm is single threaded client.
	    */
	    if (!iidbdepends_known)
	    {
		cnt = 0;
		EXEC SQL REPEATED SELECT any(1) into :cnt from iitables where
		    lowercase(table_name) = 'iidbdepends';
		iidbdepends_exists = (cnt > 0);
		iidbdepends_known = TRUE;
	    }
	    if (iidbdepends_exists)
	    {
		/* iidbdepends back end catalog exists */
		cnt = 0;

		/* DB_VIEW in dbdbms.h */
		EXEC SQL REPEATED SELECT any(1) into :cnt from iidbdepends 
		where inid1 = :table_reltid and inid2 = :table_reltidx
		and dtype = 17;		/* 17 == DB_VIEW == PSQ_VIEW */

		if (cnt > 0)
		    help_info[*ind].view_base[0] = 'Y';
		else
		    help_info[*ind].view_base[0] = 'N';
	    }
	}

	/* Should never be true for an r3 database but I'll leave it */
	if (help_info[i].page_size == 0)
	    help_info[i].page_size = 2048;

	*ind = i;
	return(OK);
}
