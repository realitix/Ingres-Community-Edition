/*
** Copyright (c) 1992, 2010 Actian Corporation
**
**
**  Name: cr.c -- configuration rule system interpreter functions 
**
**  Description:
**	The functions in this file constitute the intrepeter for the
**	configuration rules system.  They work by traversing the rule
**	trees generated by the parser (crparse.y).
**
**  History:
**	14-dec-92 (tyler)
**		Created.
**	16-feb-93 (tyler)
**		Added support for silent constraint checking and
**		resource calculation.
**	30-mar-93 (vijay)
**		Add no optim. AIX 3.2.2 compiler chokes on this file.
**	24-may-93 (tyler)
**		Removed debugging statements.
**	21-jun-93 (tyler)
**		The output generated by this module can now be sent to
**		an arbitrary file.  Also wwitched to new interface for
**		multiple context PM functions.
**	23-jul-93 (tyler)
**		Replaced embedded strings with message lookups.  Fixed
**		broken forms mode VALID set constraint validation.
**		Improved reporting of prime constraint violation to
**		include two primes nearest in value to the one entered.
**		Improved DMF cache resource processing.  Added integer
**		and boolean validation checks.
**	04-aug-93 (tyler)
**		CRsort() performance improved by omitting all non-derived
**		and unreferenced symbols from those which get sorted using 
**		insertion sort.  Insertion sort is slow (O(N^2)); however
**		it is necessary in this instance since configuration rules
**		may define a partially ordered set which can not be sorted
**		by a conventional "fast" sorting algorithm (which relies
**		on transitivity of comparison operations).  Added externally
**		callable CRdependsOn() and changed PMsymToCRidx() to
**		CRidxFromPMsym().
**      30-aug-93 (huffman)
**              Added <me.h>.
**	19-oct-93 (tyler)
**		Modified CRload() to return CR_NO_RULES_ERR when no rules
**		are loaded.  Also, shortened CR error status names.
**		Call PMhost() instead of GChostname().  Changed "dmf" to
**		"dbms" in dbms cache resources names.  Changed
**		ii.$.dbms.$.$.config.connect to ii.$.dbms.$.$.config.-
**		dmf_connect.  Modified CRderived() to detect symbols
**		referenced in REQUIRES clause. 
**	05-nov-93 (tyler)
**		Fixed BUG in get_derived_from() which prevented random
**		subsets of derived resources from being recomputed.
**		Modified CRvalidate() to return success if no rule
**		is found for a resource to be validated.  Modified
**		compute() to detect external procedure failures.
**	22-nov-93 (tyler)
**		Record all changes in the change log - even for resources
**		which don't have rules.
**	22-feb-94 (tyler)
**		Fixed BUG 54326: make sure CR_INTEGER values are >= 0
**		(not really integers)  Fixed BUG 59433 resulting from
**		improper handling of string comparison operator ("IS"). 
**	28-mar-94 (joplin)
**		Fixed a problem in compare logic.
**	28-apr-94 (vijay)
**		Change abs to fabs.
**	22-jul-94 (stephenb)
**		compute() may return NULL for an undefined resource of 
**		any type, we need to handle this in CRcompute() and return
**	 	NULL.
**      02-feb-95 (sarjo01) Bug 66333
**              Added CRresetcache() for use by restore function
**      10-feb-95 (chech02)
**              Added rs4_us5 for AIX 4.1.
**	23-may-95 (emmag)
**		Microsoft has its own qsort - rename ours to ii_qsort for
**		NT.
**      31-may-95 (johnst))
**              Integrated (mikem) change 414652 to fix bug #64261 that was 
**		applied to backend code only. We need it here too!:
**              bug #64261
**              Changed calls to fabs() to calls to CV_ABS_MACRO()
**              On some if not all UNIX's fabs() is an actual
**              routine call which takes a double as an argument and returns a
**              double.  Calls to this code did not have proper includes to
**              define the return type so the return code was assumed to be int
**              (basically returning random data), in adumoney.c this caused bug
**              #64261, in other files garbage return values from fabs would 
**              cause other problems.
**      01-aug-95 (sarjo01) Bugs 70242, 70251, 70248.
**              NT: exec_proc(): use II_TEMPORARY to build temp file path.
**		Cannot count on a #defined path (eg. /tmp/ ) existing.
**	31-oct-95 (nick)
**		Changed some constants to match redefines in cr.h.
**	07-nov-1995 (canor01)
**		A field with type _EXEC_TEXT that exists in config.cat with
**		an empty value was being parsed as an integer.  It should be
**		parsed as an empty string.
**	27-nov-1995 (canor01)
**		Added new type EXEC_TEXT_STR, which defaults to the
**		result from executing a program, but always parses result
**		as a string.
**	27-feb-1996 (canor01)
**		Added new types DIRECTORY and FILE.  DIRECTORY will 
**		verify path is a valid directory and attempt to create
**		it if the user so requests.  FILE will verify that the
**		value given is valid, either exists or can exist.
**	07-mar-1996 (canor01)
**		Call CRpath_constraint() to get a pointer to the functions
**		to verify validity of pathnames.
**	06-jun-1996 (thaju02)
**		Variable page size support:
**		Added scan_cache_params() for variable page size support.
**		When turning cache sharing ON/OFF (private to shared, and
**		vice versa) or editing cache name, need to scan existing 
**		buffer cache resources for 4k, 8k, 16k, 32k and 64k, to
**		copy, rename or remove parameters.
**		Increased MAX_SYMBOL from 500 to 750.
**		Modified CRsetPMval() to account for special case of 
**		when modifying max_tuple_parameter.
**	27-jun-1996 (canor01)
**		Modified CRsetPMval() logic for max_tuple_parameter special
**		case.  Special case code was not getting hit.
**	27-jun-1996 (canor01)
**		Add special case in CRsetPMval() for async_io and
**		gather_write parameters.
**	02-aug-1996 (mcgem01)
**		Rewrote the binary search used in symbol_index as the
**		previous version neglected to include the last entry in 
**		an even numbered array.
**	10-oct-1996 (canor01)
**		Replace hard-coded 'ii' prefixes with SystemCfgPrefix.
**	31-jan-1997 (thaju02)
**	        bug #80370 - parameters dependent on protected resources
**		are using protected resources' default values for
**		calculations.  Modified CRsetPMval such that if 
**		resource is protected use the protected value for
**		calculations.
**	08-apr-1997 (thaju02)
**		When cache_sharing is toggled, protected resources are not
**		preserved. (e.g. edit and protect dmf_cache_size, toggle
**		cache_sharing and note dmf_cache_size is reset to default
**		value.)  Modified scan_cache_params() to scan protect.dat 
**		for cache resources, and for all cache resources found to 
**		create and delete the resource for the new cache type 
**		(shared/private). Modified CRsetPMval() such that upon 
**		modifying resource value in the config.dat, if the resource
**		is also protected (listed in protect.dat) then modify
**		the resource parameter in protect.dat too.
**	18-apr-1997 (funka01)
**		Updated to display 2k for jasmine.
**      30-may-1997 (muhpa01)
**              Add hp8_us5 to platforms needing to rename qsort
**	07-aug-1997 (funka01)
**		Corrected 2k display for jasmine, it had 4k instead.
**	25-aug-97 (mcgem01)
**		Allocate space for the warning message returned when the
**		max_tuple_length is decreased.        
**	23-sep-1997 (kosma01)
**		Remove no optim for AIX 4.x.
**	09-jul-1998 (kosma01)
**		Add no optim for sgi_us5 IRIX64 6.4. 
**	01-apr-1999 (somsa01)
**		Localized printable strings. Also, removed variables which
**		were not being used anymore.
**      01-apr-1999 (stial01)
**              Removed 'max_tuple_length' from recovery server, therefore
**              it no longer needs to be updated when 'max_tuple_length'
**              is changed for a star/dbms server.
**      08-apr-1999 (stial01)
**              Added missing paren for previous change
**	09-jun-1999 (somsa01)
**		In CRsetPMval(), added a rule for server_class. It is
**		uppercased, and it must not be the same as an existing
**		server class name for another server type.
**	11-Jun-1999 (jenjo02)
**	    Do not propagate server's GatherWrite setting to the RCP. 
**	    Each can be set independently.
**	20-jul-1999 (popri01)
**		Unixware (usl_us5) has its own sort.
**	10-aug-1999 (kinte01)
**		Increased MAX_SYMBOL from 750 to 850 to handle all of the
**		rules added with the RMS (98235) & RDB (98243) gateways.
**      15-feb-2000 (musro02)
**            nc4_us5 also has it own sort
**	04-may-2000 (toumi01)
**		Add int_lnx to platforms needing to rename qsort
**	15-aug-2000 (somsa01)
**		Added ibm_lnx to platforms needing to rename qsort.
**	28-Aug-2000 (hanje04)
**		In CRsetPMval, disabled ability to turn on cache_sharing
**		and added error	message for user to explain this. This is 
**		stop user from encountering bug 102438, which causes the 
**		session (or sometimes the server) to hang if a consistency 
**		point is written to disk when using multi-server-shared-cache.
**		THIS SHOULD BE REMOVED WHEN BUG IS FIXED. - DONE
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**      25-feb-1999 (hanch04)
**            Solaris 7 has it own qsort
**	11-Oct-2000 (hanje04)
**		Removed workaround for bug 102438 since it has been fixed by
**		change 446794.
**      22-Jun-2000 (hanal04) Bug 104838 INGCBT 356
**            Ensure the dbms.crs rule for fast_commit is applied
**            to the current DBMS server definition not the
**            default definition.
**	21-dec-2000 (somsa01)
**	    Corrected #ifdef statement.
**	30-Jan-2001 (hanje04)
**	    Added Alpha Linux (axp_lnx) to list of platforms needing rename
**	    of qsort
**	23-feb-2001 (kinte01)
**	    Increased MAX_SYMBOL from 850 to 900 to handle the new
**	    symbol definitions added for GCF security
**	07-jul-2001 (somsa01)
**	    In exec_proc(), on NT, after getting the location of the
**	    temporary file, put it in quotes.
**	08-jan-2001 (devjo01)
**	    Removed conditional rename of qsort based on platform.  Our
**	    implementation is inconsistent with XPG4 standards, and
**	    the stdlib.h on Tru64 UNIX, and rather than add axp_osf as
**	    one more platform on which we change the name, I've simply
**	    renamed this local static function to cr_qsort, fixing
**	    this once and for all.  Also cast param to all MEfree calls
**	    which needed it, and fixed declare of depends_on_node().
**	16-aug-2001 (toumi01)
**	    speculative i64_aix NO_OPTIM change for beta xlc_r - FIXME !!!
**     17-aug-2001 (wansh01)  
**          In CRsetPMval(), Changed to be able to handle the add/delete 
**          operation for cbf bridge configuration create/destroy vnode. 
**      14-Nov-2001 (hanal04) Bug 106315 INGSRV 1589.
**              Prevent SIGFPE in compute() by checking for divide by
**              zero in the ND_MATH_OP case.
**	04-jun-2002 (somsa01)
**	    Corrected prior change by checking the right part of the variable.
**      15-apr-2003 (hanch04)
**          Changed CRsetPMval to take an extra parameter.
**	    CRsetPMval currently will print out to a file or
**	    stdout if that is passed.  CRsetPMval show always be passwd the
**	    config.log file to write to.  It may allow tee the output to 
**	    stdout if TRUE is passed as the new flag.
**	    The wrapper CRF_FPRINT and CRFPRINT should be used to do any
**	    output.
**          This change fixes bug 100206.
**      24-apr-2003 (hanch04)
**	    The wrapper CRF_FPRINT can only take one value to print.  When
**	    Changing the STprintf to use the macro, it need to be printed
**	    to a temp buffer first.
**	    Removed extra comma from the CRFPRINT macro.
**          This change fixes bug 100206.
**	27-may-2003 (drivi01)
**	    In CRsetPMval procedure protect.dat gets updated with a protected
**	    parameter and its new value even though the inserted value might 
**	    violate constraints. Added code to update protect.dat if inserted 
**	    value violates constraints and protect.dat needs to be updated to 
**	    the value in config.dat.
**      20-Jun-2003 (hweho01)
**          Fixed SIGSEGV when cache_sharing was selected in "DBMS Server    
**          Parameters" of cbf. It was caused by the duplicate buffer       
**          names 'temp' in scan_cache_params().  
**	08-aug-2003 (devjo01)
**	    One CRF_FPRINT with extra params was somehow left in place
**	    after previous bug 100206 fixes.  Corrected this.
**      24-sep-2003 (chash01)
**          Bump MAX_SYM t0 1200.
**	15-March-2004 (gorvi01)-- SRS section 3.1.30
**	    In CRValidate(), added cases for negative
**	    and decimal constraints.The negative constraint checks
**	    if the value passed is negative and handles the same. The decimal
**	    constraint checks for floating point values.  
**	15-March-2004 (gorvi01)-- SRS section 3.1.30
**	    In compute(), added check for decimal and negative constraint.
**	    If SIGNED_INT or DECIMAL constraint exists, it calculates the 
**	    correct value as per the constraint.
**	10-Jun-2004 (gorvi01)-- BUG 112430
**	    Modifed CRvalidate() to properly accept integer values. EDITCOUNT
**	    for any server now accepts correct values. Modified output statement
**	    format for CRvalidate().
**	14-jun-2004 (somsa01)
**	    Cleaned up code for Open Source.
**	17-Jun-2004 (schka24)
**	    Avoid a buffer overrun in exec-proc.
**	15-Jul-2004 (gorvi01)
**	    Modified the output statements that are displayed when errors occur in 
**	    CRvalidate() due to invalid input. Removed all exclamation marks and
**	    added display of entered value as appropriate. 
**	02-aug-2004 (somsa01)
**	    Added ability to specify a VALID list for boolean values.
**	24-aug-2004 (thaju02)
**	    Cap derived parameters at MAXI4 for now with the exception of dmf_memory. 
**	    This will be revisited when SIZE_TYPE is addressed. 
**	23-Sep-2004 (schka24)
**	    The special-casing in CRsetPMval for the cache stuff assumed that
**	    the special cache and connect-related symbols would always be
**	    independent parameters.  Rearrange to handle the present situation
**	    where cache_sharing is a derived parameter.
**	15-oct-2004 (thaju02) 
**	    In CRvalidate() & CRcompute(), added constraint for SIZE_TYPE.
**	18-feb-2005 (devjo01)
**	    Replace S_ST0333_private & S_ST0332_shared with hard coded
**	    english strings, as config.dat parameters should not be
**	    localized.
**      24-Feb-2005 (gorvi01)
**          Modified occurences of SSIZE_TYPE with SSIZE_TYPE to allow signed
**          parameters to be handled correctly in cbf.
**      02-Mar-2005 (gorvi01)
**          Modified occurences of SSIZE_TYPE with i8 and MAX_SSIZE_TYPE
**	    with MAXI8.
**      31-Mar-2005 (srisu02)
**          Changed ld to lld in STprintf of max_val as max_val has been
**          changed recently to an i8 
**	11-Aug-2005 (mutma03)
**	    Added code to check the retval from PMmGetElem for NULL in function **	    CRsetPMval to prevent SEG fault.
**	04-Jan-2007 (kibro01) b117214
**	    Reworked automatic changes surrounding cache parameters
**	31-Jan-2007 (kibro01) b117603
**	    Allow '?' in a rule's allowed value, which matches any character
**	    Allow '#' in a rule's allowed value, which matches any number
**	04-Jan-2008 (kiria01) b119694
**	    Correct handling of MAXI8 and MINI8 in CVal8.
**	    Overflow and underflow are now reported so MINI8
**	    and MAXI8 may now be used as I8 values and the status returns now
**	    include CV_OVERFLOW and CV_UNDERFLOW.
**	03-jun-2008 (joea)
**	    In scan_cache_params, call NMloc/LOcopy prior to calling PMmWrite.
**	26-May-2009 (kschendel) b122041
**	    Compiler warning fixes.
**	20-Jul-2009 thaju02 (B122325)
**	    Removed cap on memory-related params.
**	24-Nov-2009 (frima01) Bug 122490
**	    Included 5 header files and moved IIUGhfHtabFind declaration to
**	    ug.h to eliminate gcc 4.3 warnings.
**     16-Feb-2010 (hanje04)
**         SIR 123296
**         Add LSB option, writable files are stored under ADMIN, logs under
**         LOG and read-only under FILES location.
**	02-Apr-2010 (thaju02) Bug 122528
**	    Added check_cache_name() to validate cache_name value.
**	08-Mar-2010 (thaju02)
**	    Modified CRsetPMval(); remove max_tuple_length.
**      04-Apr-2011 (horda03) b125213
**          Don't delete old cache details (for a shared cache rename) if
**          these exists 1 or more other servers which reference the
**          cache.
**	17-May-2011 (kschendel) b125366
**	    i8's need %lld/%llu, not %ld or %lu.
*/

/* NO_OPTIM = ris_us5 sgi_us5 i64_aix */

# include <compat.h>
# include <gl.h>
# include <pc.h>
# include <cv.h>
# include <qu.h>
# include <lo.h>
# include <me.h>
# include <st.h>
# include <er.h>
# include <cm.h>
# include <cv.h>
# include <nm.h>
# include <pm.h>
# include <pmutil.h>
# include <util.h>
# include <uf.h>
# include <stdprmpt.h>
# include <si.h>
# include <simacro.h>
# include <erst.h>
# include <ctype.h>
# include <equel.h>
# include <iicommon.h>
# include <gcccl.h>
# include <fe.h>
# include <ug.h>
# include "cr.h"

# define MAX_SYMBOL	1200	/* maximum number of symbols I can handle */
# define MAX_ELEM	10	/* maximum symbol name components */
# define MAX_VALUE	512 	/* maximum length of computed value */

GLOBALDEF PTR tab;		/* hash table handle */

static char *sym[ MAX_SYMBOL ];	/* stores symbol names */

static i4  num_sym;		/* symbol counter */

static u_i4 expr_type;		/* current expression type */ 

static u_i4 save_type;		/* used in conditional expr processing */ 

static char *null_str = ""; 	/* null string buffer */

static PM_CONTEXT *pm_context;	/* PM control block pointer */

static char *localhost;		/* local host name */

static i4  cache_idx = -1;	/* index of most recently computed symbol */

static PTR cache_ptr = NULL;	/* PTR to most recently computed value */

GLOBALREF char *rulemap_path;

static bool is_prime( i8 n );
static bool tee_stdout = FALSE;

static LOCATION   protect_file;
static PM_CONTEXT *protect_data;

void scan_cache_params(char *, char *, char *, char *, char *, char *, 
			FILE *, bool);
static void scan_ports_and_change(char *host, char *serverType, char *instance, 
                           char *countStr, FILE *output);
static void special_rules(char *, char *, FILE *, i4, char *, char *);
static char * get_cache_name(char *host, char *instance);
bool check_cache_name(char *value);

# define CRF_FPRINT( FP, F_MSG, ARG ) \
        { \
		F_FPRINT( FP, F_MSG, ARG ); \
		if( tee_stdout ) \
                    F_FPRINT( stdout, F_MSG, ARG ); \
        }
# define CRFPRINT( FP, MSG ) \
        { \
                FPRINT( FP, MSG ); \
		if( tee_stdout ) \
                    FPRINT( stdout, MSG ); \
        }

/*
**  Allocates and returns a pointer to a configuration rule tree node.
**
**  History:
**	02-aug-96 (mcgem01)
**	    Initialize index.
*/
CR_NODE
*CRnode( void )
{
	CR_NODE *n;

	if( (n = (CR_NODE *) MEreqmem( 0, sizeof( CR_NODE ), FALSE, NULL ))
		== NULL )
	{
		SIprintf( "%s", ERget( S_ST0635_reqmem_fail2 ) );
		PCexit( FAIL );
	}
	n->symbol = NULL;
	n->type = ND_VOID;
	n->str_val = NULL;
	n->num_val = 0;
	n->sym_val = NULL;
	n->list = NULL;
	n->constraint = NULL;
	n->child0 = NULL;
	n->child1 = NULL;
	n->test = FALSE;
	n->index = 0;
	n->reference = FALSE;
	return( n );
}

/* forward declaration */
static bool is_recursive();

FUNC_EXTERN STATUS IIUGhiHtabInit();


/*
**  This function is used to recursively visit all nodes in a rule tree
**  to detect (illegal) rule recursion.
*/
static bool
visit( CR_NODE *n )
{
	bool result;

	if( n == NULL )
		return( FALSE );
	if( n->test )
		return( TRUE );
	result = is_recursive( n->sym_val );
	result = result || visit( n->constraint );
	result = result || visit( n->child0 );
	result = result || visit( n->child1 );
	result = result || visit( n->list );
	return( result );
}


/*
**  Detects whether a rule tree is recursive. 
*/
static bool
is_recursive( CR_NODE *n )
{
	bool old_state, result;

	if( n == NULL )
		return( FALSE );
	if( n->test )
		return( TRUE );
	old_state = n->test;
	n->test = TRUE;
	result = is_recursive( n->sym_val );
	result = result || visit( n->constraint );
	result = result || visit( n->child0 );
	result = result || visit( n->child1 );
	result = result || visit( n->list );
	n->test = old_state;
	return( result );
}


/*
**  Performs a quicksort on an array of strings (char * pointers).
*/
static void
cr_qsort( char **a, i4  n )
{
	i4 test = n / 2;
	i4 i, j;
	char *temp;

	if( n < 2 )
		return;
	if( n == 2 )
	{
		if( STcompare( a[ 0 ], a[ 1 ] ) > 0 )
		{
			temp = a[ 0 ];
			a[ 0 ] = a[ 1 ];
			a[ 1 ] = temp;
		}
		return;
	}
	for( i = 0, j = n - 1; i < j - 1; )
	{
		for( ; i < test; i++ )
		{
			if( STcompare( a[ i ], a[ test ] ) >= 0 )
				break;
		}
		for( ; j > test; j-- )
		{
			if( STcompare( a[ j ], a[ test ] ) < 0 )
				break;
		}
		if( i == j )
			break;
		temp = a[ i ];
		a[ i ] = a[ j ];
		a[ j ] = temp;
		if( test == i )
			test = j;
		else if( test == j )
			test = i; 
	}
	cr_qsort( a, test );
	cr_qsort( a + test, n - test ); 
}


/*
**  Initializes internal hash table and specifies the PM context to use.
*/
void CRinit( PM_CONTEXT *context )
{
	pm_context = context;

	/* initialize the UG hash table manager */
	if( IIUGhiHtabInit( MAX_SYMBOL, NULL, NULL, NULL, &tab )
		== FAIL )
	{
		SIprintf( "%s", ERget( S_ST0636_ughash_fail ) );
		PCexit( FAIL );
	}

	localhost = PMhost();
}


/*
**  Resets the PM context.
*/
void CRsetPMcontext( PM_CONTEXT *context )
{
	pm_context = context;
}


/*
** Returns index of symbol given its name.
** 
** History:
**	02-aug-96 (mcgem01)
**	    Rewrote the binary search so that it now includes the last
**	    element in an even numbered array.  
*/
static i4
symbol_index( char *symbol )
{
	i4 current, offset, result, direction = 1;
	i4 low = -1, high = num_sym;

	/* do a binary search */

	offset = (high -  low) / 2; 
	if (offset == 0)
	    return -1;
	current = (offset == 1) ? 0 : offset;

	for (;;)
	{
		result = STbcompare(symbol, 0, sym[ current ], 0, TRUE);
		if (result == 0)
			return (current); 
		direction = ( result > 0 ) ? 1 : -1;
		if (direction < 0)
		    high = current;
		else
		    low = current;
		if (low + 1 == high)
		    return( -1 );
		offset = (high -low)/2;
		    current +=direction * offset;
	}
}


/*
** Initializes the CR hash table.  Returns number of rules processed in
** the info parameter.
*/
STATUS
CRload( char *path, i4  *info )
{
	i4 IIUGhsHtabScan();
	CR_NODE *n;
	char *foo;
	i4 i;
	
	rulemap_path = path;

	*info = -1;

	/* initialize input stream */
	yyinit();

	/* parse the file and build the rule tree */ 
	yyparse();

	/* initialize sym[] */ 
	for( i = 0; i < MAX_SYMBOL; i++ )
		sym[ i ] = NULL;

	/* initialize num_sym */ 
	num_sym = 0;

	/* scan the hash table, counting and saving symbol names) */
	if( IIUGhsHtabScan( tab, FALSE, &sym[ num_sym ], &n ) > 0 ) 
	{
		++num_sym;
		if( num_sym >= MAX_SYMBOL )
		{
			*info = num_sym;
			return( CR_RULE_LIMIT_ERR );
		}
		if( is_recursive( n ) )
		{
			*info = num_sym - 1;
 			return( CR_RECURSION_ERR );
		}
		while( IIUGhsHtabScan( tab, TRUE, &sym[ num_sym ], &n )
			> 0 ) 
		{
			if( num_sym >= MAX_SYMBOL )
			{
				*info = num_sym + 1;
				return( CR_RULE_LIMIT_ERR );
			}
			if( is_recursive( n ) )
			{
				*info = num_sym;
 				return( CR_RECURSION_ERR );
			}
			++num_sym;
		}
		cr_qsort( sym, num_sym ); 
	}
	*info = num_sym;

	if( num_sym == 0 )
		return( CR_NO_RULES_ERR );

	/* scan the hash table a second time to precompute indexes */
	for( i = IIUGhsHtabScan( tab, FALSE, &foo, &n ); i > 0;
		i = IIUGhsHtabScan( tab, TRUE, &foo, &n )
	)
		n->index = symbol_index( n->symbol );

	return( OK );
}


/*
** Returns the string associated with a symbol given its given index.
*/
char *
CRsymbol( i4  idx )
{
	if( idx < 0 || idx >= MAX_SYMBOL )
		return( NULL );
	return( sym[ idx ] );
}

static PTR compute();


/*
** Returns type of configuration rule.  Returns CR_VOID if a bogus index
** is passed.  The other return values are CR_INTEGER and CR_BOOLEAN.
*/
u_i4
CRtype( i4  idx )
{
	CR_NODE *s;

	if( idx < 0 || idx >= MAX_SYMBOL )
		return( CR_VOID );
	if( IIUGhfHtabFind( tab, sym[ idx ], (PTR *) &s ) == FAIL )
		return( CR_VOID );
	cache_idx = idx;
	cache_ptr = compute( s );
	return( expr_type );
}


/*
** Returns the minimum integer constraint if one is set, given the rule
** tree node corresponding to the symbol.
*/
static PTR
compute_min( CR_NODE *n )
{
	if( n == NULL )
		return( (PTR) NULL );
	if( n->type == ND_MIN )
		return( compute( n->child0 ) );
	return( compute_min( n->constraint ) );
}


/*
** Checks an integer value against constraints for minimum values if any
** exist in a given configuration rule tree.
*/
static STATUS
check_min( CR_NODE *n, i8 val, char **constraint, FILE *output )
{
	i8 min_val;
	static char min_str[ BIG_ENOUGH ];

	if( n == NULL )
		return( OK );
	if( n->type == ND_MIN )
	{
		min_val = (i8) *((f8 *) compute( n->child0 ));

		if( val < min_val )
		{
			if( output != (FILE *) NULL )
				CRF_FPRINT( output,
					ERget( S_ST0400_mimimum_value ),
					min_val );
			STprintf( min_str, ERx( "%lld" ), min_val );
			*constraint = min_str;
			return( FAIL );
		}
		return( OK );
	}
	else
		return( (STATUS) check_min( n->constraint, val, constraint, output ) );
}


/*
** Returns the maximum integer constraint if one is set, given the rule
** tree node corresponding to the symbol.
*/
static PTR
compute_max( CR_NODE *n )
{
	if( n == NULL )
		return( (PTR) NULL );
	if( n->type == ND_MAX )
		return( compute( n->child0 ) );
	return( compute_max( n->constraint ) );
}


/*
** Checks an integer value against constraints for maximum values if any
** exist in a given configuration rule tree.
*/
static STATUS
check_max( CR_NODE *n, i8 val, char **constraint, FILE *output )
{
	i8 max_val;
	static char max_str[ BIG_ENOUGH ];

	if( n == NULL )
		return( OK );
	if( n->type == ND_MAX )
	{
		max_val = (i8) *((f8 *) compute( n->child0 ));
		if( val > max_val )
		{
			if( output != (FILE *) NULL )
			{
				CRF_FPRINT( output,
					ERget( S_ST0401_maximum_value ),
					max_val );
			}
			STprintf( max_str, ERx( "%lld" ), max_val );
			*constraint = max_str;
			return( FAIL );
		}
		return( OK );
	}
	return( check_max( n->constraint, val, constraint, output ) );
}


/*
** The following data structure is used to build set of values used by 
** VALID constraint checking code.
*/
typedef struct m {
	u_i4 type;
	PTR value;
	u_i4 length;
	struct m *next;
} MEMBER;

/*
** Recursively builds list of VALID values for constraint violation. 
*/
static MEMBER
*member_list( CR_NODE *n )
{
	MEMBER *member;

	if( n == NULL )
		return( (MEMBER *) NULL );

	/* allocate MEMBER and compute its value */
	member = (MEMBER *) MEreqmem( 0, sizeof( MEMBER ), FALSE, NULL );
	
	member->value = compute( n ); 
	member->type = expr_type;

	if( member->type == CR_STRING )
	{
		if( member->value == NULL )
			member->length = 0;
		else
			member->length = STlength( (char *) member->value );
	}

	/* set pointer to next list member */ 
	if( n->list == NULL )
		member->next = NULL;
	else
		member->next = member_list( n->list ); 

	/* return (sub)list */
	return( member );	
}


/*
** Free a list of VALID values.
*/
static void
free_list( MEMBER *m )
{
	if( m == NULL )
		return;
	free_list( m->next );
	MEfree( (PTR) m );
}


/*
** Returns the member of a VALID set which is closest to (but less than)
** a given integer value.  This routine might not crash and would probably
** behave strangely if applied to string sets. 
*/
static PTR
closest_member( CR_NODE *n, PTR value )
{
	if( n == NULL )
		return( (PTR) NULL );

	if( n->type == ND_SET_MEMBER )
	{
		MEMBER *list, *m;
		PTR closest;

		/* build list of valid set members */
		if( (list = member_list( n->list )) == NULL )
			return( (PTR) NULL );

		/* return NULL if not an integer list */
		if( list->type != CR_INTEGER )
			return( (PTR) NULL );

		/* scan list to find closest match */
		closest = list->value;
		for( m = list->next; m != NULL; m = m->next )
		{
			if( CV_ABS_MACRO( *((f8 *) m->value) - *((f8 *) value) )
			   < CV_ABS_MACRO( *((f8 *) closest) - *((f8 *) value) )
			)
				closest = m->value;
		} 
		free_list( list );
		return( closest );
	}
	return( closest_member( n->constraint, value ) );
}


/*
** This routine is used for formatting output during constraint validation.
*/
static void
print_space( i4  n, FILE *output )
{
	i4 i;

	if( output != (FILE *) NULL )
	{
		for( i = 0; i < n; i++ )
			CRFPRINT( output, " " );	
	}
}


#define TERM_ROWS	21	/* number of rows on standard terminal */
#define TERM_COLS	80	/* number of columns on standard terminals */

/*
** Check case-blind comparison with '?' for any character and '#' for numbers
*/
static bool
values_match(char *target, char *value)
{
	char *t_ptr = target;
	char *v_ptr = value;

	while (*t_ptr && *v_ptr)
	{
		switch (*t_ptr)
		{
		case '?':	/* Anything matches '?' */
			v_ptr++;
			break;
		case '#':	/* Must match at least one digit */
			if (!isdigit(*v_ptr))
				return (FALSE);
			while (*v_ptr && isdigit(*v_ptr))
				v_ptr++;
			break;
		default:
			if (CMcmpnocase(v_ptr,t_ptr))
				return (FALSE);
			v_ptr++;
			break;
		}
		t_ptr++;
	}
	/* If we dealt with all of both strings, this is a match */
	if (*t_ptr == '\0' && *v_ptr == '\0')
		return (TRUE);
	return (FALSE);
}

/*
** Check for membership in a VALID constraint set.
*/
static STATUS
check_member( CR_NODE *n, char *value, FILE *output )
{
	i4 num_val, max_len, out_row, out_col, col_siz, i;

	if( n == NULL )
		return( OK );

	if( n->type == ND_SET_MEMBER )
	{
		MEMBER *list, *m;
		bool found = FALSE;

		/* build list of valid set members */
		if( (list = member_list( n->list )) == NULL )
			return( OK );

		/* scan list for val */
		for( m = list; m != NULL; m = m->next )
		{
			if( m->type == CR_STRING )
			{
			    if( m->value != NULL &&
			        values_match((char *) m->value, value))
					found = TRUE;
			}
			else
			{
			    i4 number;

			    if (m->type == CR_BOOLEAN)
			    {
				if (STbcompare(value, 0, "ON", 0, TRUE) == 0)
				    number = 1;
				else
				    number = 0;
			    }
			    else
				CVal( value, &number );
			    if( (i4) (*(f8 *) m->value) == number )
				found = TRUE; 
			}
		} 

		if( found )
		{
			free_list( list );
			return( OK );
		}

		/* get max length and count values to format output */ 
		for( num_val = 0, max_len = 0, m = list; m != NULL;
			m = m->next, num_val++ )
		{
			if( m->type == CR_STRING && m->length > max_len )
				max_len = m->length;
		}

		out_row = TERM_ROWS - 10;
		out_col = num_val / out_row;
		if( out_col == 0 )
			out_col = 1;
		if( num_val % num_val != 0 )
			++out_col;
		if( max_len == 0 )
			max_len = 6;
		col_siz = max_len + 4;

		if( output != (FILE *) NULL )
			CRFPRINT( output, ERget( S_ST0402_valid_values ) );
		for( m = list, i = 1; m != NULL; m = m->next, i++ )
		{
			i4 nspaces;
			char buf[ 512 ];

			if( m->type == CR_STRING )
			{
				if( m->length == 0 )
				{
					i--;
					continue;
				}
				STprintf( buf, "%s", (char *) m->value );
				nspaces = col_siz - m->length;	
				if( nspaces < 0 )
					nspaces *= -1;
			}
			else
			{
				if( m->type == CR_BOOLEAN )
				{
				    if ((i4) *(f8 *) m->value == 1)
					STprintf( buf, "ON");
				    else
					STprintf( buf, "OFF");
				}
				else
				{
				    if( output != (FILE *) NULL )
					STprintf( buf, "%d",
						(i4) *(f8 *) m->value );
				}

				nspaces = col_siz - STlength( buf );
			}
			if( output != (FILE *) NULL )
			{
				print_space( nspaces, output );	
				CRF_FPRINT( output, ERx( "%s" ), buf );
				if( i % out_col == 0 )
					CRFPRINT( output, ERx( "\n" ) );
			}
		}
		if( output != (FILE *) NULL )
		{
			CRFPRINT( output, ERx( "\n" ) );
			if( out_col != 1 && i % out_col != 1 )
				CRFPRINT( output, ERx( "\n" ) );	
		}
		free_list( list );
		return( FAIL );
	}
	return( check_member( n->constraint, value, output ) );
}


/*
** Returns TRUE if n is prime.
*/
static bool
is_prime( i8 n )
{
	i8 i;

	if( n % 2 == 0 )
		return( FALSE );
	for( i = 3; i < n / 2; i += 2 )
	{
		if( n % i == 0 )
			return( FALSE );
	}
	return( TRUE );
}


/*
** Returns TRUE if rule tree contains the specified unary constraint (e.g.
** PRIME, POWER2).
*/
bool
unary_constraint( CR_NODE *n, u_i4 constraint_id )
{
	if( n == NULL )
		return( FALSE );
	if( n->type == constraint_id )
		return( TRUE );
	return( unary_constraint( n->constraint, constraint_id ) );
}


/*
** Checks a value again any configuration rule constraints and prints out
** an explanation of the first violation detected. 
*/
STATUS
CRvalidate( char *name, char *value, char **constraint, FILE *output )
{
	CR_NODE *n;
	i4 i, idx, len; 
	i4 number = 0;
	f8 ftemp = 0;
	char *symbol, *s, *def[ 100 ];
	BOOLFUNC *confirmpath;
	enum  NUM_FLAG {NOT_A_NUMBER, INT_VALUE, FLOAT_VALUE, OUT_OF_RANGE} ;
	enum NUM_FLAG flag;
	i8		num8 = 0;
	i8	stnum = 0;

	flag = NOT_A_NUMBER;

	if( (idx = CRidxFromPMsym( name )) < 0 )
		return( OK );

	symbol = CRsymbol( idx );

	if( IIUGhfHtabFind( tab, symbol, (PTR *) &n ) == FAIL )
		return( OK );

	/* extract default program name */
	len = PMmNumElem( pm_context, name );
	for( i = 0; i < len; i++ )
	{
		if( STcompare( PMmGetElem( pm_context, i, symbol ),
			ERx( "$" ) ) == 0 && STcompare(
			(s = PMmGetElem( pm_context, i, name )),
			ERx( "*" ) ) != 0
		) 
			def[ i ] = s;
		else
			def[ i ] = NULL;
	}

	/* set defaults before constraint check */
	for( i = 0; i < len; i++ )
		PMmSetDefault( pm_context, i, def[ i ] );

	*constraint = NULL;

	switch( CRtype( idx ) )
	{

		case CR_INTEGER:
			
			
			if (value != NULL && *value != EOS) 
			{
				if (unary_constraint( n->constraint, ND_SIZETYPE))
				{
				    switch (CVal8(value, &num8))
				    {
				    case OK:
					if (num8 < 0)
					{
					    CRF_FPRINT(output,
                                                "\n The value (\"%s\") is invalid for this parameter.\n This parameter cannot be negative.\n\n", value);
					    return ( FAIL );
					}
					flag = INT_VALUE;
					stnum = num8;
					break;

				    case CV_UNDERFLOW:
				    case CV_OVERFLOW:
					CRF_FPRINT(output,
					    "\n The value (\"%s\") is out of range.\n\n", value);
					return ( FAIL );

				    default:
					flag = NOT_A_NUMBER;
				    }
				}
				else
				{
				    switch (CVal( value, &number ))
				    {
				    case OK:
					flag = INT_VALUE; /* integer */
					stnum = number;
				        break;

				    case CV_OVERFLOW:
				    case CV_UNDERFLOW:
					flag = OUT_OF_RANGE; /* integer overflow, underflow */
					break;
					
				    default:
					if (CVaf(value, '.',&ftemp) == OK ) 
					    flag = FLOAT_VALUE; /* floating point no */
					else
					   flag = NOT_A_NUMBER; /* neither */
				    }
				}
			}

			if (flag == NOT_A_NUMBER)
			{
				if (output != (FILE *) NULL )
				{
					CRF_FPRINT(output,
						"\nThe value (\"%s\") is invalid. \nThe value of this setting must have a numeric value.\n\n", value);
				}
				return( FAIL );
			}
			
			if( n->constraint == NULL)
			{
				if (flag == INT_VALUE)
				{	
					if( number >= 0)
						return( OK );
					else if(number < 0)
					{
					CRF_FPRINT(output,
						"\n The value (\"%s\") is invalid for this parameter.\n This parameter cannot be negative.\n\n", value);
					return ( FAIL );
					}
				}
				else if (flag == FLOAT_VALUE)	
				{
					CRF_FPRINT(output,
						"\n The value (\"%s\") is invalid for this parameter.\n This parameter cannot have a float value.\n\n", value);
					return ( FAIL );
				}
				else if (flag == OUT_OF_RANGE)
				{
					
					CRF_FPRINT(output,
						"\n The value (\"%s\") is out of range.\n\n", value);
					return ( FAIL );
				}
			}

			/* if unary_constraint absent but the value is negative */

			if( !unary_constraint( n->constraint, ND_SIGNED_INT ) && (stnum < 0 || ftemp < 0 ) )
			{
				CRF_FPRINT(output,
					"\n The value (\"%s\") is invalid for this parameter. \nThis parameter cannot be negative.\n\n", value);
				return ( FAIL );
			}

			/* if unary constraint absent but the value is float */

			if( !unary_constraint( n->constraint, ND_DECIMAL ) && ( flag == FLOAT_VALUE) )
			{
				CRF_FPRINT(output,
					"\n The value (\"%s\") is invalid for this parameter. \nThis parameter cannot have a float value.\n\n", value);
				return ( FAIL );
			}

			/* check for MIN constraint violation */
			if( check_min( n->constraint, stnum, constraint,
				output ) != OK
			)
				return( FAIL );

			/* check for MAX constraint violation */
			if( check_max( n->constraint, stnum, constraint,
				output ) != OK
			)
				return( FAIL );

			/* check for PRIME number violation */
			if( unary_constraint( n->constraint, ND_PRIME ) &&
				! is_prime( stnum ) )
			{
				i8 smaller, larger;

				/* find next smaller prime */
				for( smaller = stnum - 1; smaller > 1;
					smaller-- )
				{
					if( is_prime( smaller ) )
						break;
				}					

				/* find next larger prime */
				for( larger = stnum + 1; ; larger++ )
				{
					if( is_prime( larger ) )
						break;
				}					

				if( output != (FILE *) NULL )
				{
					CRFPRINT( output, ERget(
						S_ST0404_value_not_prime ) );
					CRF_FPRINT( output, ERx( "\t%lld\n" ),
						smaller );
					CRF_FPRINT( output, ERx( "\t%lld\n" ),
						larger );
				}
				return( FAIL );
			}
				
			/* check for POWER2 violation */
			if( unary_constraint( n->constraint, ND_POWER2 ) ) 
			{
				i8 p;

				for( p = 1; p <= stnum; p *= 2 )
				{
					if( p == stnum )
						return( OK );
				}					
				if( output != (FILE *) NULL )
				{
					CRFPRINT( output, ERget(
						S_ST0405_value_not_power2 ) );
				}
				return( FAIL );
			}

			/* the lack of a "break" here is intentional */
		case CR_STRING:		
			if ((len == 5) && 
			    !STcompare(PMmGetElem(pm_context, 4, name),
				ERx("cache_name")) &&
			    (check_cache_name(value) == FAIL))
			{
			    CRFPRINT( output, ERget(S_ST0408_invalid_cache_name));
			    return(FAIL);
			}
			
			/*
			** check for VALID set member violation - this
			** applies to both CR_STRING and CR_INTEGER types,
			** which is why the CR_INTEGER case has no break
			** at the end.
			*/
			if( check_member( n->constraint, value, output )
				!= OK )
			{
				return( FAIL );
			}

			/* check for DIRECTORY violation */
			if( confirmpath = 
			    CRpath_constraint( n->constraint, ND_DIRECTORY ) )
			{
			    bool canceled;

			    if ( !(*confirmpath)( value, &canceled ) ) 
			    {
				if( output != (FILE *) NULL )
				{
				    if( canceled == FALSE )
				    {
					CRF_FPRINT( output, "\nUnable to create directory %s.\nPerhaps higher-level directory structure does not exist?\n\n", value );
				    }
				    else
				    {
					CRF_FPRINT( output, "\n\nDirectory %s not created.\n\n", value );
				    }
				}
				return( FAIL );

			    }
			}

			/* check for FILE violation */
			if( (confirmpath = 
			    CRpath_constraint( n->constraint, ND_FILESPEC )) &&
			    ! (*confirmpath)( value ) ) 
			{
				if( output != (FILE *) NULL )
				{
					CRF_FPRINT( output, "\n%s is not a valid file.\nPerhaps the directory does not exist.\nVerify and try again.\n\n", value );
				}
				return( FAIL );
			}

			return( OK );

		case CR_BOOLEAN:		

			if( !ValueIsBool( value ) )
			{
				if( output != (FILE *) NULL )
				{
					CRFPRINT( output, ERget(
						S_ST0406_value_not_boolean ) );
				}
				return( FAIL );
			}

			if (check_member(n->constraint, value, output) != OK)
			    return(FAIL);

		default:
			return( OK );
	}
}


/*
** Converts a boolean configuration rule value ("on" or "off") to an f8.
*/
static f8
bool_val( char *s )
{
	if( STbcompare( s, 0, ERx( "on" ), 0, TRUE ) == 0 )
		return( 1 );
	else
		return( 0 );
}


/*
** Executes and returns the return value produced by an "external procedure"
** specified by a configuration rule.
*/
static char
*exec_proc( char *cmd )
{
	LOCATION fileloc;
	char *locpath, *c, *host;
	char tempbuf[ MAX_LOC + 1 ];
	char pathbuf[ MAX_LOC + 1 ];
	char cmdbuf[ BIG_ENOUGH ];
	CL_ERR_DESC cl_err;
	FILE *fp;
	static char result[ MAX_VALUE ];
	char *temp, temp_dir[ MAX_LOC ];

# ifdef NT_GENERIC
        NMgtAt( ERx("II_TEMPORARY"), &temp );
        if( temp == NULL || *temp == EOS )
        {
            temp = ".";
        }
        STlcopy(temp, temp_dir, sizeof(temp_dir)-1-1);
        STcat(temp_dir, ERx("\\"));
# else
        STcopy(TEMP_DIR, temp_dir);
# endif

	/* prepare temporary file LOCATION */
	STcopy( ERx( "" ), tempbuf );
	LOfroms( FILENAME, tempbuf, &fileloc );
	LOuniq( SystemVarPrefix, NULL, &fileloc );
	LOtos( &fileloc, &locpath );
	STlpolycat(2, sizeof(pathbuf)-1, temp_dir, locpath, pathbuf );
# ifdef VMS
        STcat( pathbuf, ERx( ".TMP" ) );
# endif /* VMS */
	LOfroms( PATH & FILENAME, pathbuf, &fileloc );

	/* write out config.dat */
	PMmWrite( pm_context, NULL );

	/* prepare cmdbuf for execution */

#ifdef NT_GENERIC
	STprintf( cmdbuf, ERx( "%s \"%s\"" ), cmd, pathbuf );
#else
	STprintf( cmdbuf, ERx( "%s %s" ), cmd, pathbuf );
#endif  /* NT_GENERIC */

	if( (host = PMmGetDefault( pm_context, HOST_PM_IDX )) == NULL )
		host = localhost;
	STcat( cmdbuf, ERx( " " ) );
	STcat( cmdbuf, host );

	/* execute command */ 
	if( PCcmdline( NULL, cmdbuf, PC_WAIT, NULL, &cl_err ) != OK )
		return( NULL );

	/* extract the return value from first line of temp file */
	if( SIfopen( &fileloc , ERx("r"), SI_TXT, MAX_VALUE, &fp ) != OK )
		return( NULL );

	*result = '\0';
	SIgetrec( result, MAX_VALUE, fp );
	for( c = result; *c != EOS && *c != '\n'; CMnext( c ) );
	*c = EOS;
	SIclose( fp );
	LOdelete( &fileloc );

	return( result );
}


/*
** Recursive computes a value given the root of a configuration rule tree.
*/
static PTR
compute( CR_NODE *n )
{
	i4 *nptr;
	f8 *numptr;
	PTR child0, child1, ptr, *ptr_list;
	char *value;

	if( n == NULL )
		return( (PTR) NULL);

	switch( n->type )
	{
		case ND_UNDEFINED:
			/*
			** undefined expression - set expr_type to
			** CR_UNDEFINED if not already set.
			*/
			if( expr_type == CR_VOID )
				expr_type = CR_UNDEFINED;
			return( NULL );

		case ND_NUM_VAL:
			expr_type = CR_INTEGER;
 			/*
			 * Use value stored in PM facility if one exists,
			 * instead of the value derived from the rule-base. 
			 */
			if( n->symbol != NULL && PMmGet( pm_context,
				n->symbol, &value ) == OK )
			{
				/* PM value was found - return it */
				numptr = (f8 *) MEreqmem( 0, sizeof( f8 ),
					FALSE, NULL );
				if( numptr == NULL )
					return( (PTR) NULL );
				CVaf( value, ERx( '.' ), numptr );
				ptr = (PTR) numptr;
			}
			else
				/* not a symbol or no PM value found */
				ptr = (PTR) &n->num_val;
			break;

		case ND_STR_VAL:
			expr_type = CR_STRING;
 			/*
			 * Use value stored in PM facility if one exists,
			 * instead of the value derived from the rule-base. 
			 */
			if( n->symbol != NULL && PMmGet( pm_context,
				n->symbol, &value ) == OK )
			{
				/* PM value was found - return it */
				return( (PTR) STalloc( value ) );
			}
			else
				/* not a symbol or no PM value found */
				return( (PTR) n->str_val );	
			break;

		case ND_BOOL_VAL:
			expr_type = CR_BOOLEAN;
			if( n->symbol != NULL && PMmGet( pm_context,
				n->symbol, &value ) == OK )
			{
				/* PM value was found - return it */
				numptr = (f8 *) MEreqmem( 0, sizeof( f8 ),
					FALSE, NULL );
				if( numptr == NULL )
					return( (PTR) NULL );
				*numptr = bool_val( value ); 
				return( (PTR) numptr );
			}
			else
				/* no PM value found - use rule-value */
				return( (PTR) &n->num_val );	
			break;

		case ND_SYM_VAL:
		{
			if( n->sym_val->symbol != NULL &&
				PMmGet( pm_context, n->sym_val->symbol,
				&value ) != OK )
			{
				return( compute( n->sym_val ) );
			}

			/* if here, use stored value */
			if( ValueIsInteger( value ) )
			{
				expr_type = CR_INTEGER;
				numptr = (f8 *) MEreqmem( 0,
					sizeof( f8 ), FALSE, NULL );
				if( numptr == NULL )
					return( (PTR) NULL );
				CVaf( value, ERx( '.' ), numptr );
				return( (PTR) numptr );
			}
			if( ValueIsBool( value ) )
			{	
				expr_type = CR_BOOLEAN;
				numptr = (f8 *) MEreqmem( 0,
					sizeof( f8 ), FALSE, NULL );
				if( numptr == NULL )
					return( (PTR) NULL );
				*numptr = bool_val( value ); 
				return( (PTR) numptr );
			}

			/* if here, it must be a string */
			expr_type = CR_STRING;
			return( (PTR) STalloc( value ) );
		}
			break;

		case ND_MATH_OP:
			child0 = compute( n->child0 );
			child1 = compute( n->child1 );
			if( child0 == NULL || child1 == NULL )
			{
				expr_type = CR_VOID;
				return( (PTR) NULL );
			} 
			switch( *n->str_val )
			{
				case '+':
					n->num_val = *(f8 *) child0 +
						*(f8 *) child1;
					break;
				case '-':
					n->num_val = *(f8 *) child0 -
						*(f8 *) child1;
					break;
				case '*':
					n->num_val = *(f8 *) child0 *
						*(f8 *) child1;
					break;
				case '/':
                                        /* Don't divide by zero */
                                        if (*(f8 *)child1 != 0.0)
                                        {
                                            n->num_val = *(f8 *) child0 /
                                                *(f8 *) child1;
                                        }
                                        else
                                        {
                                            n->num_val = *(f8 *) child0;
                                        }
					break;
				default:
					return( (PTR) NULL );
			}
			ptr = (PTR) &n->num_val;
			break;

		case ND_COMPARE_OP:
			child0 = compute( n->child0 );
			child1 = compute( n->child1 );
			if( child0 == NULL || child1 == NULL )
			{
				expr_type = CR_VOID;
				return( (PTR) NULL );
			} 
			nptr = (i4 *) MEreqmem( 0, sizeof( i4  ), FALSE,
				NULL );
			if( nptr == NULL )
				return( (PTR) NULL );
			switch( *n->str_val )
			{
				case 'I':
					/*
					** This is meant to check for the
					** string comparison operator "IS".
					*/
					if( STbcompare( (char *) child0, 0,
						(char *) child1, 0, TRUE ) == 0
					)
						*nptr = (i4) TRUE;
					else
						*nptr = (i4) FALSE;
					break;

				case '=':
					*nptr = (i4)( *(f8 *) child0 ==
						*(f8 *) child1 );
					break;

				case '>':
					if( n->str_val[ 1 ] != '\0' )
					{
						*nptr = (i4)( *(f8 *)
							child0 >= *(f8 *)
							child1 ); 
						break;
					}
					*nptr = (i4)( *(f8 *) child0 >
						*(f8 *) child1 );
					break;

				case '<':
					if( n->str_val[ 1 ] != '\0' )
					{
						*nptr = (i4)( *(f8 *)
							child0 <= *(f8 *)
							child1 ); 
						break;
					}
					*nptr = (i4)( *(f8 *) child0 <
						*(f8 *) child1 );
					break;

				default:
					return( (PTR) NULL );
			}
			ptr = (PTR) nptr;
			break;

		case ND_LOGIC_OP:
			child0 = compute( n->child0 );
			child1 = compute( n->child1 );
			if( child0 == NULL || child1 == NULL )
			{
				expr_type = CR_VOID;
				return( (PTR) NULL );
			} 
			nptr = (i4 *) MEreqmem( 0, sizeof( i4  ), FALSE,
				NULL );
			if( nptr == NULL )
				return( (PTR) NULL );
			switch( *n->str_val )
			{
				case '&':
					*nptr = ( * (i4 *) child0) &&
						( * (i4 *) child1);
					break;

				case '|':
					*nptr = ( * (i4 *) child0) ||
						( * (i4 *) child1);
					break;	

				default:
					return( (PTR) NULL );
			}
			ptr = (PTR) nptr;
			break;

		case ND_COND1:
			nptr = (i4 *) compute( n->child0 );
			save_type = expr_type;
			ptr_list = (PTR *) compute( n->child1 );
			if( nptr == NULL )
				return( (PTR) NULL );
			if( *nptr )
			{
				if( ptr_list[ 0 ] == NULL )
					return( (PTR) NULL );
				ptr = ptr_list[ 0 ];
				expr_type = save_type;
			}
			else
			{
				if( ptr_list[ 1 ] == NULL )
					return( (PTR) NULL );
				ptr = ptr_list[ 1 ];
			}
			break;

		case ND_COND2:
			ptr_list = (PTR *) MEreqmem( 0, 2 * sizeof( PTR ),
				FALSE, NULL );
			if( ptr_list == NULL )
				return( (PTR) NULL );
			ptr_list[ 0 ] = compute( n->child0 );
			save_type = expr_type;
			ptr_list[ 1 ] = compute( n->child1 );
			ptr = (PTR) ptr_list;
			break;

		case ND_SUM:
			{
			PM_SCAN_REC state1;
			char *exp, *name, *value;
			STATUS status;

			expr_type = CR_INTEGER;
			/*
			** argument refers to startup data, so return
			** sum of all occurences.
			*/
			exp = PMmExpToRegExp( pm_context, n->str_val );
			status = PMmScan( pm_context, exp, &state1, NULL,
				&name, &value );

			n->num_val = 0;
			while( status == OK )
			{
				f8 temp;

				CVaf( value, ERx( '.' ), &temp );
				n->num_val += temp;
				status = PMmScan( pm_context, NULL, &state1,
					NULL, &name, &value ); 
			}
			return( (PTR) &n->num_val );
			}

		case ND_VOID:
			/* undefined symbol encountered */	
			{
			char *msg = NULL;

			/* undefined symbol */
			expr_type = CR_VOID;
			return( (PTR) NULL );
			}

		case ND_EXEC_TEXT:
		{	
			char *c;
			bool is_number = TRUE;

			/* use PM value first if there is one */
			if( n->symbol != NULL &&
				PMmGet( pm_context, n->symbol, &value ) == OK )
			{
				/* use PM value */
				if( (ptr = value) == NULL )
				{
					expr_type = CR_STRING;
					return( (PTR) null_str );
				}
			}
			else
			{
				/* get value from external procedure */
				if( (ptr = exec_proc( n->str_val )) == NULL )
					return( NULL );
			}

			/*
			** The return value might be string or numeric - so
			** we must test it to determine the type.
			*/
			c = (char *) ptr;
			if ( *c == EOS )
			    is_number = FALSE;
			for( ; *c != EOS; CMnext( c ) )
			{
				/* decide whether it's a number */ 
				if( !CMdigit( c ) && *c != '.' )
					is_number = FALSE;  
			}
			if( is_number )
			{
				expr_type = CR_INTEGER;
				CVaf( (char *) ptr, ERx( '.' ), &n->num_val );
				ptr = (PTR) &n->num_val;
				/* it's an integer, so do validation  */
				break;
			}
			else
			{
				/* assume it's a string and return */
				expr_type = CR_STRING;
				return( ptr );
			}
		}
		case ND_EXEC_TEXT_STR:
		{	
			/* use PM value first if there is one */
			if( n->symbol != NULL &&
				PMmGet( pm_context, n->symbol, &value ) == OK )
			{
				/* use PM value */
				if( (ptr = value) == NULL )
				{
					expr_type = CR_STRING;
					return( (PTR) null_str );
				}
			}
			else
			{
				/* get value from external procedure */
				if( (ptr = exec_proc( n->str_val )) == NULL )
					return( NULL );
			}

			/*
			** The return value must be a string.
			*/
			expr_type = CR_STRING;
			return( ptr );
		}

		default:
			/* this shouldn't happen */
			SIprintf( "%s", ERget( S_ST0637_compute_fail ) );
			PCexit( FAIL );
	}		
	if( n->constraint != NULL )
	{
		PTR opt_ptr;

		/* check MIN */
		if( (opt_ptr = compute_min( n->constraint )) != NULL )
		{
			if( *(f8 *) opt_ptr > *(f8 *) ptr )
				ptr = opt_ptr;
		} 
		/* check MAX */
		if( (opt_ptr = compute_max( n->constraint )) != NULL )
		{
			if( *(f8 *) opt_ptr < *(f8 *) ptr )
				ptr = opt_ptr;
		} 
		/* check VALID set member constraint */
		if( (opt_ptr = closest_member( n->constraint, ptr) ) != NULL )
			ptr = opt_ptr;
		/* check PRIME */
		if( unary_constraint( n->constraint, ND_PRIME ) )
		{
			i4 i;

			for( i = (i4) *(f8 *) ptr; i > 3; i-- )
			{
				if( is_prime( i ) )
					break;
			}
			*(f8 *) ptr = (f8) i;
		}
		/* check POWER2 */
		else if( unary_constraint( n->constraint, ND_POWER2 ) )
		{
			i4 n, p = 1;

			n = (i4) *(f8 *) ptr;	
			for(;;)
			{
				/*
				** if n isn't a power of 2, then return the
				** next power of 2 which is larger than n.
				*/ 
				if( p == n )
					break;
				if( (p *= 2) > n )
					break;
			}				
			*(f8 *) ptr = (f8) p;
		}
		/* check SIGNED_INT */
		else if ( unary_constraint( n->constraint, ND_SIGNED_INT ) && ValueIsSignedInt(opt_ptr) )
		{
			ptr = opt_ptr;
		}

		/* check DECIMAL */
		else if ( unary_constraint( n->constraint, ND_DECIMAL ) && ValueIsFloat(opt_ptr))
		{
			ptr = opt_ptr;
		}
		else if (unary_constraint( n->constraint, ND_SIZETYPE))
		{
			if (*(f8 *)ptr > MAXI8)
				*(f8 *)ptr = (f8)MAXI8;
		}
	}
	return( ptr );
}


/* forward declaration */
static bool depends_on_node();

/*
** Returns TRUE if a specified rule symbol is referenced by a rule sub-tree. 
*/
static bool
node_in_subtree( CR_NODE *n, CR_NODE *s, bool *visited )
{
	if( s == NULL )
		return( FALSE );

	switch( s->type )
	{
		case ND_SYM_VAL:
			if( s->sym_val == n )
				return( TRUE );
			if( ! visited[ s->sym_val->index ] && 
				depends_on_node( s->sym_val, n, visited )
			)
				return( TRUE );
			break;

		case ND_SUM:
		case ND_REQUIRES:
		{
			i4 i;
			char *n_elem, *s_elem;
			i4 len = PMmNumElem( pm_context, n->symbol );
			bool found = FALSE;

			if( len == PMmNumElem( pm_context, s->str_val ) )
			{
				found = TRUE;
				for( i = 0; i < len; i++ )
				{
					n_elem = PMmGetElem( pm_context, i,
						n->symbol );
					s_elem = PMmGetElem( pm_context, i,
						s->str_val );
					if( STcompare( s_elem, ERx( "%" ) )
						!= 0 && STbcompare( n_elem,
						0, s_elem, 0, TRUE ) != 0 )
					{
						found = FALSE;
					}
				}
			}
			if( found )
				return( TRUE );
		}
	}
	if( s->child0 != NULL &&
		node_in_subtree( n, s->child0, visited )
	)
		return( TRUE );
	if( s->child1 != NULL &&
		node_in_subtree( n, s->child1, visited )
	)
		return( TRUE );
	if( s->constraint != NULL &&
		node_in_subtree( n, s->constraint, visited )
	)
		return( TRUE );
	if( s->list != NULL &&
		node_in_subtree( n, s->list, visited )
	)
		return( TRUE );
	return( FALSE );
}


/*
** Returns TRUE if symbol represented by node1 depends on the symbol
** represented by node2.
*/
static bool
depends_on_node ( CR_NODE *node1, CR_NODE *node2, bool *visited )
{
	if( node1 == node2 )
		return( FALSE );
	visited[ node1->index ] = TRUE;
	return( node_in_subtree( node2, node1, visited ) );
}



/*
** Returns TRUE if CRsymbol(idx1) depends on CRsymbol(idx2).  Returns
** FALSE if either idx1 or idx2 are invalid.
*/
static bool
depends_on_idx( i4  idx1, i4  idx2, bool *visited )
{
	CR_NODE *node1, *node2;

	if( IIUGhfHtabFind( tab, CRsymbol( idx1 ),
		(PTR *) &node1 ) == FAIL ||
		IIUGhfHtabFind( tab, CRsymbol( idx2 ),
		(PTR *) &node2 ) == FAIL )
	{
		/* undefined symbol */
		return( FALSE );
	}
	return( depends_on_node( node1, node2, visited ) );
}

bool
CRdependsOn( i4  sym1, i4  sym2 )
{
	bool visited[ MAX_SYMBOL ];
	i4 i;

	for( i = 0; i < MAX_SYMBOL; i++ )
		visited[ i ] = FALSE;
	return( depends_on_idx( sym1, sym2, visited ) );
}


/*
** The following data structure is used to build linked lists of
** configuration rule symbols.
*/
typedef struct slist {
	i4		sym;
	struct slist	*next;
	struct slist	*prev;
} SLIST;


/*
** Allocate an SLIST record and return a pointer to it.
*/
static SLIST
*alloc_SLIST( void )
{
	return( (SLIST *) MEreqmem( 0, sizeof( SLIST ), FALSE, NULL ) );
}


/*
** Perform insertion sort on n members of array list starting at member i. 
*/
insertion_sort( i4  *list, i4  len )
{
	i4 i, j, k, tmp;
	bool visited[ MAX_SYMBOL ];

	for( i = 0; i < len; i++ )
	{
		for( j = i + 1; j < len; j++ )
		{
			for( k = 0; k < num_sym; k++ )
				visited[ k ] = FALSE;
			if( depends_on_idx( list[ i ], list[ j ], visited ) )
			{
				tmp = list[ i ];	
				list[ i ] = list[ j ];
				list[ j ] = tmp;	
			}
		}
	}
}


/*
** Returns TRUE if the subtree references any symbol or symbol pattern.
*/
static bool
subtree_references_symbol( CR_NODE *n, bool init )
{
	if( n == (CR_NODE *) NULL )
		return( FALSE );
	if( !init && n->type == ND_SYM_VAL )
		return( TRUE );	
	if( n->reference )
		return( TRUE );
	if( n->sym_val != (CR_NODE *) NULL )
		return( TRUE );
	if( subtree_references_symbol( n->child0, FALSE ) )
		return( TRUE );
	if( subtree_references_symbol( n->child1, FALSE ) )
		return( TRUE );
	if( subtree_references_symbol( n->list, FALSE ) )
		return( TRUE );
	if( subtree_references_symbol( n->constraint, FALSE ) )
		return( TRUE );
	return( FALSE );
}


/*
** Sort a list of CR symbol indexes into computation order.
*/ 
void
CRsort( i4  *list, i4  len )
{
	SLIST *s, *head, *tail, *tmp;
	i4 i, unreferenced = 0;
	
	/*
	** create doubly linked list containing all ecords in the unsorted
	** array.
	*/ 
	tail = (SLIST *) NULL;
	for( s = head = alloc_SLIST(), i = 0; i < len; i ++, s = s->next )
	{
		s->sym = list[ i ];
		s->next = alloc_SLIST();
		s->prev = tail;
		tail = s;
	}
	/* remove extra record at the end */
	MEfree( (PTR) s );
	if( tail != (SLIST *) NULL )
		tail->next = (SLIST *) NULL;
	else
		head = (SLIST *) NULL;

	for( s = head, i = 0; i < len; i++ )
	{
		CR_NODE *n;
		STATUS IIUGhfHtabFind();

		if( IIUGhfHtabFind( tab, CRsymbol( s->sym ), (PTR *) &n )
			== FAIL )
		{
			SIprintf( "%s", ERget( S_ST0636_ughash_fail ) );
			PCexit( FAIL );
		}

		if( !n->reference &&
			!subtree_references_symbol( n, TRUE ) )
		{
			/*
			** This symbol does not reference and is not
			** referenced by other symbols, so it goes to 
			** the end of the list. 
			*/
			++unreferenced;

			/* rule is unrelated to any others */ 
			if( head == s ) 
			{
				head = s->next;
				head->prev = (SLIST *) NULL;
			}
			else
			{
				s->prev->next = s->next;	
			}

			if( s->next != (SLIST *) NULL )
				s->next->prev = s->prev;

			tmp = s;

			s = s->next;

			tail->next = tmp;
			tmp->prev = tail;
			tmp->next = (SLIST *) NULL;
			tail = tmp;
		}	
		else
			s = s->next;
	}
	
	for( i = 0, s = head, tmp = (SLIST *) NULL; i < len; i++, s = s->next )
	{
		list[ i ] = s->sym;	
		if( tmp != (SLIST *) NULL )
			MEfree( (PTR) tmp );	
		tmp = s;
	}
	if( tmp != (SLIST *) NULL )
		MEfree( (PTR) tmp );	

	/* sort the first (len - unreferenced) members of the array */ 
	insertion_sort( list, len - unreferenced );
}


/*
** This function is called by CRsetPMval() to build a complete list of
** derived resource symbols, given an arbitrary rule symbol.
*/
static SLIST
*get_derived_from( i4  idx, bool init )
{
	i4 i, j;
	SLIST *cur, *list = NULL;
	bool visited[ MAX_SYMBOL ];
	static bool visited_me[ MAX_SYMBOL ];
	static bool derived[ MAX_SYMBOL ];

	/* mark all symbols not visited or derived on init */
	if( init )
	{
		for( i = 0; i < num_sym; i++ )
			visited_me[ i ] = FALSE;
		for( i = 0; i < num_sym; i++ )
			derived[ i ] = FALSE;
	}

	/* skip this symbol if already checked */
	if( visited_me[ idx ] )
		return( NULL );

	visited_me[ idx ] = TRUE;

	for( i = 0; i < num_sym; i++ )
	{
		if( i == idx )
			continue;

		/* initialize visited[] */
		for( j = 0; j < num_sym; j++ )
			visited[ j ] = FALSE;

		if( depends_on_idx( i, idx, visited ) )
		{
			SLIST *new;

			if( !derived[ i ] )
			{
				/* mark symbol derived */
				derived[ i ] = TRUE;

				/* add symbol to list */ 
				new = (SLIST *) MEreqmem( 0, sizeof( SLIST ),
					FALSE, NULL );
				new->sym = i;
				new->next = NULL;
				if( list == NULL )
					cur = list = new;
				else
				{
					cur->next = new;
					cur = new;
				}

				/* call get_derived_from() recursively */
				new = get_derived_from( i, FALSE );
				if( new != NULL )
				{
					/* concatenate lists */
					cur->next = new;

					/* advance cur to last element */
					while( cur->next != NULL )
						cur = cur->next;
				}
			}
		}
	}
	return( list );
}


/*
** Returns TRUE if any symbols are referenced in the subtree.
*/
static bool
subtree_contains_roots( CR_NODE *n )
{
	if( n == NULL )
		return( FALSE );
	switch( n->type )
	{
		case ND_SUM:
		case ND_SYM_VAL:
		case ND_REQUIRES:
			return( TRUE );
	}
	if( n->child0 != NULL && subtree_contains_roots( n->child0 ) )
		return( TRUE );
	if( n->child1 != NULL && subtree_contains_roots( n->child1 ) )
		return( TRUE );
	if( n->list != NULL && subtree_contains_roots( n->list ) )
		return( TRUE );
	if( n->constraint != NULL && subtree_contains_roots( n->constraint ) )
		return( TRUE );
	return( FALSE );
}


/*
** Returns TRUE if value of the named symbol is derived.
*/
bool
CRderived( char *s )
{
	CR_NODE *n;
	STATUS IIUGhfHtabFind();
	i4 idx;

	if( (idx = CRidxFromPMsym( s )) < 0 )
		return( FALSE );
	if( IIUGhfHtabFind( tab, CRsymbol( idx ), (PTR *) &n ) == FAIL )
		return( FALSE );
	return( subtree_contains_roots( n ) );
}
/*
 * Reset cache value index
 */
STATUS
CRresetcache()
{
        cache_idx = -1;
        return(OK);
}

/*
 * Compute and return the string representation of a CR value. 
 */
STATUS
CRcompute( i4  idx, char **result )
{
	CR_NODE *n;
	STATUS IIUGhfHtabFind();
	static char value[ 50 ];
	PTR val;
	f8 *ftemp;

	/* check for cached value before recomputing */ 
	if( idx == cache_idx )
		val = cache_ptr;
	else
	{
		if( IIUGhfHtabFind( tab, CRsymbol( idx ), (PTR *) &n ) == FAIL )
		{
			/* symbol not defined in hash table */
			*result = NULL;
			return( FAIL );
		}
		expr_type = CR_VOID;
		val = compute( n );
	}
	if (val == NULL)
	{
	    *result = NULL;
	    return(OK);
	}
	switch( expr_type )
	{
		case CR_INTEGER:
			STprintf( value, "%.0f", (double) *(f8 *) val );
			*result = value;
			break;

		case CR_BOOLEAN:
			if( (bool) *(f8 *) val )
				*result = ERx( "ON" );
			else
				*result = ERx( "OFF" );
			break;

		case CR_STRING:
			*result = (char *) val; 
			break;

		case CR_UNDEFINED:
			*result = NULL;
			break;
		
		default: /* CR_VOID */
			*result = NULL;
			return( FAIL );
	}
	return( OK );
} 


/*
** This routine uses an inverted counter to exhaustively generate all 
** possible rule-symbols for given a PM resource name, until a valid
** rule-symbol is found.  The lowest order bits of the counter are used
** to generate components of an "experimental" rule-symbol - which is
** then checked for existence.
*/
i4
CRidxFromPMsym( char *s )
{
	i4 len, count, i, j;
	char **elem, *buf;
	STATUS IIUGhfHtabFind();
	bool done;
	/*
	** The following array must contain increasing powers of 2 in
	** order for this function to work.
	*/
	static i4  mask[] = {
		1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096
	};

	len = PMmNumElem( pm_context, s );
	if( len > sizeof( mask ) / sizeof( i4  ) )
	{
		SIprintf( "%s", ERget( S_ST0638_PMnumelem_over ) );
		PCexit( FAIL );
	}

	/* create array of PM symbol components */
	elem = (char **) MEreqmem( 0, len * sizeof( char * ), FALSE, NULL );
	for( i = 0; i < len; i++ )
		elem[ i ] = PMmGetElem( pm_context, i, s );

	/* create buffer for testing possible rule symbols */
	buf = (char *) MEreqmem( 0, STlength( s ) + 1, FALSE, NULL );

	done = FALSE;
	for( count = 0; !done; count++ )
	{
		/* if lowest n bits are 0, then we're done */
		done = TRUE;
		for( i = 0; i < len; i++ )
		{
			if( (i4) (count & mask[ i ]) != 0 )
				done = FALSE;
		}

		/* if count is 0, ignore previous result */
		if( count == 0 )
			done = FALSE;

		/*
		** scan counter (lower order bits to higher) in order to
		** generate a string to test. 
		*/
		*buf = EOS;
		for( i = len - 1; i >= 0; i-- )
		{
			if( i < len - 1 )
				STcat( buf, ERx( "." ) );

			/* use j to "invert" the counter */
			j = len - 1 - i;
			if( j < 0 )
				j = -1 * j;
			if( (i4) (count & mask[ j ]) != 0 )
				STcat( buf, ERx( "$" ) );
			else if( elem[ j ] != NULL )
				STcat( buf, elem[ j ] );
		}

		/* test the generated string */
		if( (i = symbol_index( buf )) >= 0 )
			return( i );
	}
	return( -1 );
}


/*
** This function fills a paased buffer with the number of DBMS server
** connections which must be supported by a DBMS cache.
**
**	18-feb-2005 (devjo01)
**	     Remove hideous use of huge static buffer to pass 
**	     connections value.  Change API so caller passes buffer in.
*/
static void 
getDMFconnect( char *host, char *cache_type, char *cache_id, char *value )
{
	PM_SCAN_REC state;
	STATUS status;
	char temp[ BIG_ENOUGH ], *regexp, *scan_name, *scan_value;
	i4 connect_sum = 0;

	/* first check for easy case (private cache) */
	if( STcompare( cache_type, ERx("private") ) == 0 )
	{
		/* cache is private, so return ii.$.dbms.$.connect_limit */
		STprintf( temp, ERx( "%s.%s.dbms.%s.connect_limit" ),
			  SystemCfgPrefix, host, cache_id );
		if( PMmGet( pm_context, temp, &scan_value ) != OK )
			STcopy(ERx( "32" ), value );
		else
			STcopy(scan_value, value );
		return;	
	}
	/*
	** if here, cache is shared, so scan ii.$.dbms.$.cache_sharing
	** resources and examine ii.$.ingstart.$.dbms to deterine how
	** many connections this cache must support.
	*/ 

	STprintf( temp, ERx( "%s.%s.dbms.%%.cache_sharing" ), 
		  SystemCfgPrefix, host );

	regexp = PMmExpToRegExp( pm_context, temp );

	for( status = PMmScan( pm_context, regexp,
		&state, NULL, &scan_name, &scan_value );
		status == OK; status = PMmScan(
		pm_context, NULL, &state, NULL,
		&scan_name, &scan_value ) )
	{
		char *instance, *cache_name, *connect, *startup;
		i4 nconnect, nstartup;

		instance = PMmGetElem( pm_context, 3, scan_name );

		/* skip server definitions with private caches */
		if( ! ValueIsBoolTrue( scan_value ) )
			continue;	

		/* look up ii.$.dbms.$.cache_name */
		STprintf( temp, ERx( "%s.%s.dbms.%s.cache_name" ),
			  SystemCfgPrefix, host, instance );
		if( PMmGet( pm_context, temp, &cache_name ) != OK )
			continue;

		/* skip server definitions which don't use this cache */
		if( STcompare( cache_name, cache_id ) != 0 )
			continue;

		/* look up ii.$.ingstart.$.dbms */
		STprintf( temp, ERx( "%s.%s.ingstart.%s.dbms" ),
			  SystemCfgPrefix, host, instance );
		if( PMmGet( pm_context, temp, &startup ) != OK )
			continue;
		if( startup == NULL )
			startup = ERx( "0" );
		if( CVan( startup, &nstartup ) != OK )
			nstartup = 0;

		/* look up ii.$.dbms.$.connect_limit */
		STprintf( temp, ERx( "%s.%s.dbms.%s.connect_limit" ),
			  SystemCfgPrefix, host, instance );
		if( PMmGet( pm_context, temp, &connect ) != OK )
			continue;
		if( connect == NULL )
			connect = ERx( "0" );
		if( CVan( connect, &nconnect ) != OK )
			nconnect = 0;

		connect_sum += nstartup * nconnect;
	}

	STprintf( value, ERx( "%d" ), connect_sum );
}


/*
** This is the all important function which sets the named PM resource
** and recalculates the derived resources.
*/
char *
CRsetPMval( char *name, char *value, FILE *output, bool print_stdout, bool report )
{
	i4 i, j, k, len, len2;
	char *prog, *result, *orig_val, *new_val;
	char *prog_def[ 100 ];
	char *host;
	char *instance;
	bool add_del_mod = FALSE;
	SLIST *list, *prev;
	i4 cmpt[ MAX_SYMBOL ]; 

	char	tempbuf[BIG_ENOUGH];
	char	*owner;
	i4	old_intval;
	i4 new_intval;
	char	warnmsg[BIG_ENOUGH];
	char	*warn = 0;

	PM_SCAN_REC	state;
	char		*regexp, *scan_name, *scan_value;
	char		protect_buf[ MAX_LOC +1 ];

	tee_stdout = print_stdout;

	/* load protect.dat file */
	NMloc( ADMIN, FILENAME, ERx( "protect.dat" ), &protect_file );
	LOcopy( &protect_file, protect_buf, &protect_file );
	PMmInit(&protect_data);
	PMmLowerOn(protect_data);
	PMmLoad(protect_data, &protect_file, NULL);

	/* reset value used for dmf cache users calculation */
	if( PMmGet( pm_context, name, &orig_val ) != OK )
		orig_val = ERx( "0" );

	/* delete old value */
	if( PMmDelete( pm_context, name ) == PM_NOT_FOUND )  
	   add_del_mod = TRUE;

	/* get new value which takes effect if any */
	if( PMmGet( pm_context, name, &new_val ) != OK )
		new_val = ERx( "0" );
	
	/* insert new value if not null */
	if( value != NULL )
	{
   	    PMmInsert( pm_context, name, value );
	    if ( (add_del_mod) && output != (FILE *) NULL)
	    {
		STprintf( tempbuf, "%s ... (%s)", name, value );
		CRF_FPRINT( output, "\nADD %s\n", tempbuf );
	    }
        }
	else
	if( output != (FILE *) NULL )
	{
    	    CRF_FPRINT( output, "\nDELETE %s\n", name );
            add_del_mod = TRUE; 
	}

	/* 
	** 08-apr-1997 (thaju02)
	** need to update protect.dat file with new resource value if 
	** resource being modified is also protected.
	*/
	if (PMmGet(protect_data, name, &orig_val) == OK)
	{
            PMmDelete( protect_data, name );
 
            /* insert new value if not null */
            if( value != NULL )
                PMmInsert( protect_data, name, value );

	    PMmWrite(protect_data, &protect_file);
	}

	host  = PMmGetElem( pm_context, 1, name );
	owner = PMmGetElem( pm_context, OWNER_PM_IDX, name );
	instance = PMmGetElem( pm_context, 3, name );

	/*
	** Special case for async_io parameter:
	**	if default dbms server, set parameter for
	**	recovery server as well.
	*/
	if ( PMmNumElem( pm_context, name ) == 5 &&
	     !STcompare( owner, ERx("dbms")) )
	{
	    char *parmname = PMmGetElem( pm_context, 4, name );

	    if ( !STcompare( parmname, ERx("async_io")) &&
	         !STcompare(PMmGetElem(pm_context, 3, name), "*") )
	    {
		/* 
		** Setting async_io for default server sets it for recovery
		*/
		STprintf( tempbuf, ERx("%s.%s.%s.*.%s"),
		          SystemCfgPrefix, host, ERx("recovery"), parmname );
		if( PMmGet( pm_context, tempbuf, &orig_val ) == OK )
		{
                    PMmDelete( pm_context, tempbuf );
                    PMmInsert( pm_context, tempbuf, value );
                    if( report && output != (FILE *) NULL )
                    {
			char temp[BIG_ENOUGH];
			STprintf( temp, 
				   ERx( "\nCHANGE %s: (%s)...(%s)\n\n" ),
				   name, orig_val, value );
                	CRFPRINT( output, temp);
                    }
		}
	    }
	}

	/*
	** If we are changing server_class, it needs to be upper case.
	** Also, if it is an existing server class id, then it can only
	** be accepted if it is within the same type of server type
	** (DBMS, STAR).
	*/
	if (PMmNumElem(pm_context, name) == 5 &&
	    !STcompare(PMmGetElem(pm_context, 4, name),ERx("server_class")))
	{
	    char	*className = NULL;
	    STATUS	status;
	    PM_SCAN_REC	state;
	    bool	ClassExists = FALSE;
	    char	*regexp, *name1;

	    CVupper(value);
	    PMmDelete( pm_context, name );
	    PMmInsert( pm_context, name, value );

	    if (!STcompare(owner,ERx("dbms")))
	    {
		STprintf( tempbuf, "%s.%s.star.%%.server_class",
			  SystemCfgPrefix, host );
	    }
	    else
	    {
		STprintf( tempbuf, "%s.%s.dbms.%%.server_class",
			  SystemCfgPrefix, host );
	    }

	    regexp = PMexpToRegExp (tempbuf);
	    for (
		    status = PMscan(regexp, &state, NULL, &name1, &className);
		    status == OK;
		    status = PMscan(NULL, &state, NULL, &name1, &className) )
	    {
		if (!STcompare(value, className))
		{
		    ClassExists = TRUE;
		    break;
		}
	    }

	    if (ClassExists)
	    {
		/*
		** print out warning
		*/
		if (!STcompare(owner,ERx("dbms")))
		{
		    STprintf(warnmsg, ERget( S_ST063A_bad_srv_class ),
			     value, ERx("STAR"));
		}
		else
		{
		    STprintf(warnmsg, ERget( S_ST063A_bad_srv_class ),
			     value, ERx("DBMS"));
		}
		warn = STalloc (warnmsg);

		/*
		** Reset back to old value.
		*/
		PMmDelete( pm_context, name );
		STcopy( orig_val, value );
		PMmInsert( pm_context, name, value );
	    }
        }

	if( report && output != (FILE *) NULL  && !add_del_mod)
	{
            char temp[BIG_ENOUGH];
	    STprintf( temp, ERx( "\nCHANGE %s: (%s)...(%s)\n\n"),
		name, orig_val, value  );
            CRFPRINT( output, temp);
	}

	/* return now if there is no rule for this symbol */
	if( (j = CRidxFromPMsym( name )) < 0 )
		return(warn);

	/* extract default program name */
	prog = PMmGetElem( pm_context, OWNER_PM_IDX, name );
	len = PMmNumElem( pm_context, name );
	for( i = 0; i < len; i++ )
	{
		char *p=PMmGetElem(pm_context, i, name );
		char *q=PMmGetElem(pm_context, i, CRsymbol( j ));
		if (p && q )
		{
		    if ((STcompare(q, ERx( "$" ))==0) &&
		       (STcompare(p, ERx( "*" ))!=0)) 
			prog_def[ i ] = p;
		    else
			prog_def[ i ] = NULL;
		}
		else
		    return(warn);
	}

	/* set defaults before constraint check */
	for( i = 0; i < len; i++ )
		PMmSetDefault( pm_context, i, prog_def[ i ] );

	/* check whether inserted value violates constraint */
	if( value != NULL && CRvalidate( name, value, &result, output )
		!= OK )

	{ 
		STATUS status = OK;

		if( result == NULL ) 
			status = CRcompute( j, &result ); 
		if( status == OK && STcompare( value, result ) != 0 )
		{
			PMmDelete( pm_context, name );
			PMmInsert( pm_context, name, result );
			if (PMmGet( protect_data, name, &orig_val)==OK)
			{
				PMmDelete( protect_data, name);
				PMmInsert( protect_data, name, result );
				PMmWrite( protect_data, &protect_file);
			}
			if( output != (FILE *) NULL )
			{
				CRF_FPRINT( output, ERx( "The value you entered was changed to %s to satisfy a configuration rule.\n" ), result );
			}
			value = result;
		}
	}

	special_rules(host, instance, output, j, orig_val, value);


	/* build and sort derived resource list */
	for( i = 0, len2 = 0, list = get_derived_from( j, TRUE ), prev = NULL;
		list != NULL; prev = list, list = list->next, i++, len2++ )
	{
		if( prev != NULL )
			MEfree( (PTR) prev );	
		cmpt[ i ] = list->sym;
	}
	cmpt[ i ] = -1;
	CRsort( cmpt, len2 );

	/* recompute sorted list of resources */
	for( i = 0; cmpt[ i ] != -1; i++ )
	{
		char *s;

		/* set defaults for prog resources */
		/* added OR condition specifically for recovery server
		** buffer cache parameters, in support of variable
		** page size project.  The rcp buffer cache parameters
		** are derived parameters dependent on the dbms
		** 4,8,16,32,64k cache status parameter, thus we
		** need to maintain the defaults for elements 3+.
		*/
		if((STcompare( PMmGetElem( pm_context, OWNER_PM_IDX,
			CRsymbol( cmpt[ i ] ) ), prog ) == 0) ||
                    (STcompare(PMmGetElem(pm_context, OWNER_PM_IDX,
                          CRsymbol(cmpt[i])), ERx("dbms")) == 0 &&
                        (PMmNumElem( pm_context, CRsymbol(cmpt[i])) > 4) &&
                        (STcompare(PMmGetElem(pm_context, 4,
                          CRsymbol(cmpt[i])), ERx("fast_commit")) == 0)) ||
		    (STcompare(PMmGetElem(pm_context, OWNER_PM_IDX, 
			  CRsymbol(cmpt[i])), ERx("rcp")) == 0 &&
		        (STcompare(PMmGetElem(pm_context, 3, 
			  CRsymbol(cmpt[i])), ERx("dmf_cache_size")) == 0 ||
			 STcompare(PMmGetElem(pm_context, 3,
			  CRsymbol(cmpt[i])), ERx("dmf_cache_size4k")) == 0 ||
			 STcompare(PMmGetElem(pm_context, 3,
			  CRsymbol(cmpt[i])), ERx("dmf_cache_size8k")) == 0 ||
			 STcompare(PMmGetElem(pm_context, 3,
			  CRsymbol(cmpt[i])), ERx("dmf_cache_size16k")) == 0 ||
			 STcompare(PMmGetElem(pm_context, 3,
			  CRsymbol(cmpt[i])), ERx("dmf_cache_size32k")) == 0 ||
			 STcompare(PMmGetElem(pm_context, 3,
			  CRsymbol(cmpt[i])), ERx("dmf_cache_size64k")) == 0)))
		{
			for( k = 3; k < len; k++ )
				PMmSetDefault( pm_context, k, prog_def[ k ] );
		}
		else
		{
			for( k = 3; k < len; k++ )
				PMmSetDefault( pm_context, k, NULL );
		}

		/* display resource name */
		if( output != (FILE *) NULL )
		{
			CRF_FPRINT( output, ERx( "%s:" ),
				PMmExpandRequest( pm_context,
				CRsymbol( cmpt[ i ] ) ) );
		}

		s = NULL;
		PMmGet( pm_context, CRsymbol( cmpt[ i ] ), &s ); 
		if( output != (FILE *) NULL )
		{
			CRF_FPRINT( output, ERx( " (%s)..." ), s );
		}

		/*
		** bug #80370 - if derived resource is protected,
		** use protected value instead of the default value.
		*/ 
		regexp = PMmExpToRegExp(protect_data, 
			    PMmExpandRequest(pm_context, CRsymbol(cmpt[i])));

		if ( PMmScan(protect_data, regexp, &state, NULL, &scan_name, 
			&scan_value) != OK ) 
		{
		    /* delete old value, recompute, and display value */
		    PMmDelete( pm_context, CRsymbol( cmpt[ i ] ) );
		    if( CRcompute( cmpt[ i ], &result ) != OK )
		    {
			if( output != (FILE *) NULL )
			{
			    CRF_FPRINT( output,
					ERx( "\n%s is undefined.\n\n" ),
					CRsymbol( cmpt[ i ] ) );
			}
			PCexit( FAIL );
		    }
		    if( result == NULL )
		    {
			if( output != (FILE *) NULL )
			{
			    CRFPRINT( output, ERx( "(none)\n" ) );
			}
			continue;
		    }

		    if( output != (FILE *) NULL )
		    {
			CRF_FPRINT( output, ERx( "(%s)\n" ), result );
		    }
		    PMmInsert( pm_context, CRsymbol( cmpt[ i ] ), result );
		    special_rules(host, instance, output, cmpt[i], s, result);

		}
		else
                    if( output != (FILE *) NULL )
                    {
                        CRF_FPRINT( output, ERx( "(%s)\n" ), scan_value );
                    }
	}
	return(warn);
}

void
scan_cache_params(char *host, char *old_cachetype, char *new_cachetype, 
char *old_cacheid, char *new_cacheid, char *elem6, FILE *output,
bool cache_used)
{
    STATUS	status;
    PM_SCAN_REC state;
    char	*regexp, *last, *scan_name, *scan_value;
    char	temp[ BIG_ENOUGH ];
    char	*param;
    char	protect_buf[ MAX_LOC +1 ];

    if (elem6 == NULL)
	STprintf( temp, ERx( "%s.%s.dbms.%s.%s.%%" ), SystemCfgPrefix,
		  host, old_cachetype, old_cacheid);
    else
	STprintf( temp, ERx( "%s.%s.dbms.%s.%s.%s.%%" ), SystemCfgPrefix,
		  host, old_cachetype, old_cacheid, elem6);

    regexp = PMmExpToRegExp( pm_context, temp );
 
    status = PMmScan( pm_context, regexp, &state, NULL, 
		    &scan_name, &scan_value );
    for( status = PMmScan( pm_context, regexp, &state, NULL, 
		    &scan_name, &scan_value ), last = scan_name; 
		status == OK;
		status = PMmScan( pm_context, NULL, &state, last, 
		    &scan_name, &scan_value ), last = scan_name )
    {
	/* compose shared cache resource name */
	if (elem6 == NULL)
	{
	    param = PMmGetElem( pm_context, 5, scan_name);
	    STprintf( temp, ERx( "%s.%s.dbms.%s.%s.%s" ), SystemCfgPrefix,
		      host, new_cachetype, new_cacheid, param );
	}
	else
	{
	    param = PMmGetElem( pm_context, 6, scan_name );
	    STprintf( temp, ERx( "%s.%s.dbms.%s.%s.%s.%s" ), SystemCfgPrefix,
		      host, new_cachetype, new_cacheid, elem6, param );
	}
  
	/* try to insert - failure is OK */
	if( PMmInsert( pm_context, temp, scan_value ) == OK &&
		output != (FILE *) NULL )
	{
	    char temp_buf[BIG_ENOUGH];
	    STprintf( temp_buf, ERx( "CREATE %s: (%s)\n" ), 
			PMmExpandRequest( pm_context, temp ), scan_value );
	    CRFPRINT( output, temp_buf );
	}
 
	/* delete existing private cache resource */
	if (!cache_used)
	{
	    if( PMmDelete( pm_context, scan_name ) == OK && 
			output != (FILE *)NULL )
	    {
	    	CRF_FPRINT( output, ERx( "DELETE %s\n" ), scan_name );
	    }
	}
    }

    /* 
    ** 08-apr-1997 (thaju02)
    ** scan protect.dat for all cache resources.
    ** for all cache resources found, create new parameter for
    ** the new cache type and then delete present parameter for
    ** the old cache type.
    ** Write out changes to protect.dat file.
    */
    for( status = PMmScan( protect_data, regexp, &state, NULL,
                    &scan_name, &scan_value ), last = scan_name;
                status == OK;
                status = PMmScan( protect_data, NULL, &state, last,
                    &scan_name, &scan_value ), last = scan_name )
    {
        /* compose shared cache resource name */
        if (elem6 == NULL)
        {
            param = PMmGetElem( protect_data, 5, scan_name);
            STprintf( temp, ERx( "%s.%s.dbms.%s.%s.%s" ), SystemCfgPrefix,
                      host, new_cachetype, new_cacheid, param );
        }
        else
        {
            param = PMmGetElem( protect_data, 6, scan_name );
            STprintf( temp, ERx( "%s.%s.dbms.%s.%s.%s.%s" ), SystemCfgPrefix,
                      host, new_cachetype, new_cacheid, elem6, param );
        }
 
        (void) PMmInsert(protect_data, temp, scan_value);
 
        /* delete existing private cache resource */
        if (!cache_used)
            (void) PMmDelete(protect_data, scan_name);
    }

    NMloc(ADMIN, FILENAME, ERx("protect.dat"), &protect_file);
    LOcopy(&protect_file, protect_buf, &protect_file);
    PMmWrite(protect_data, &protect_file);

}


/*
** Name: scan_caches_and_change - Change many caches from/to private/shared
**
** Description:
**	When cache_sharing change is triggered by the sum of dbms startups
**	changing, it is necessary to go through all the servers to change
**	their cache_sharing parameters - otherwise you end up with the cache
**	having changed but the cache_sharing not having done so.  This is
**	because the cache_sharing parameter of the server where the startup
**	is being changed is regarded as a dependency, but the other servers'
**	cache_sharing parameter is not a dependency.
**
** Inputs:
**	symbol		The item in config.dat which is being amended
**	to_value	The value the item is being amended to (ON or OFF)
**	output		FILE * for output file
**
** Outputs:
**	None
**
** Side Effects:
**	Can delete/insert (cache) parameters
**
** History:
**	04-Jan-2007 (kibro01) b117214
**	    Created
**
*/

static void
scan_caches_and_change(char *symbol, char *to_value, FILE *output)
{
/* Now go through any other caches where they are unprotected */
	char *exp, *name, *value, *dummy;
	PM_SCAN_REC state1;
	char temp[ BIG_ENOUGH ];
	STATUS status;

	STcopy(symbol,temp);
	dummy=STstrindex(temp,"$.cache_sharing",0,FALSE);
	*dummy='%';

	exp = PMmExpToRegExp( pm_context, temp);
	status = PMmScan( pm_context, exp, &state1, NULL, &name, &value );

	while( status == OK )
	{
	    status = PMmScan( pm_context, NULL, &state1, NULL, &name, &value ); 
	    if (ValueIsBoolTrue(value) != ValueIsBoolTrue(to_value))
	    {
		(void)CRsetPMval( name, to_value, output, tee_stdout, FALSE );
	    }
					
	}
}

/*
** Name: check_if_shared_cache_used
**
** Description:
**	Checks if the listed shared cache is used anywhere else
**
** Inputs:
**
** Outputs:
**	Returns TRUE if shared cache is used, FALSE if not
**
** Side Effects:
**	None
**
** History:
**	04-Jan-2007 (kibro01) b117214
**	    Created
**      04-Apr-2011 (horda03) b125213
**          Exit the loop if a cache is being used by another
**          DBMS definition,
**
*/

static bool
check_if_shared_cache_used( char *host, char *instance, char *cache_name )
{
	bool cache_used = FALSE;
	char temp[ BIG_ENOUGH ];
	char *regexp;
	i4 status;
	PM_SCAN_REC state;
	char *scan_name, *scan_value;

	/*
	** determine whether other DBMS definitions
	** reference the existing shared cache.
	*/
	STprintf( temp, ERx( "%s.%s.dbms.%%.cache_name" ),
			      SystemCfgPrefix, host );

	regexp = PMmExpToRegExp( pm_context, temp );

	for( status = PMmScan( pm_context, regexp,
		    &state, NULL, &scan_name, &scan_value );
		    status == OK; status = PMmScan(
		    pm_context, NULL, &state, NULL,
		    &scan_name, &scan_value ) )
	{
		char *dbms_instance, *cache_sharing;

		dbms_instance = PMmGetElem( pm_context, 3, scan_name );

		STprintf( temp, ERx( "%s.%s.dbms.%s.cache_sharing" ),
		    SystemCfgPrefix, host, dbms_instance );

		if( PMmGet( pm_context, temp, &cache_sharing ) != OK )
		{
			continue;
		}

		/*
		** skip data which belongs to the DBMS
		** definition being changed.
		*/
		if( STcompare( dbms_instance, instance ) == 0 )
		{
			continue;
		}

		if( STcompare( cache_name, scan_value ) == 0 &&
				ValueIsBoolTrue( cache_sharing ) )
		{
			cache_used = TRUE;
                        break;
		}
	}
	return (cache_used);
}

/*
** Name: get_cache_name
**
** Description:
**	Get the cache name for the host/instance, or "cach_def" if not set
**
** Inputs:
**	host		Host name
**	instance	DB instance
**
** Outputs:
**	Returns cache name
**
** Side Effects:
**	None
**
** History:
**	04-Jan-2007 (kibro01) b117214
**	    Created
**
*/
static char *
get_cache_name(char *host, char *instance)
{
    char *retval;
    char temp[ BIG_ENOUGH ];

    STprintf( temp, ERx( "%s.%s.dbms.%s.cache_name" ),
			      SystemCfgPrefix, host, instance );
    if( PMmGet( pm_context, temp, &retval ) != OK )
	    retval = ERx( "cach_def" );	
    return (retval);
}

/*
** Name: special_rules -- Handle special cache related derivations
**
** Description:
**	When cache name or sharing related parameters are changed, we have to
**	potentially delete old cache parameter definitions and invent new ones
**	that reflect the new sharing / name situation.  This sort of thing can't
**	be expressed in rules, so it's built into the CR-set-value routine.
**
**	There's also a special builtin parameter (dmf_connect) that has to be
**	reset, and all dependent values updated, if we mess with anything cache,
**	startup-count, or connect-limit related.  Since some of the dependent
**	values are cache parameters, we'll check for sharing and name changes
**	first.  (That will generate the proper cache parameter set.)  We'll
**	check for dmf-connect related stuff second.
**
**	Note that this gets called from CRsetPMval, inside the new-value
**	loop after it's decided on all dependencies.   We assume that
**	a dependency chain will affect a cache-name or cache-sharing symbol,
**	or a cache parameter, but not both.  In other words we don't have to
**	worry about some cache parameter being changed out from underneath
**	an already computed dependency list, by the actions of this routine. 
**	Also, the new value should already be written into the PM config.
**
** Inputs:
**	host		Name of config host ([1] element of param names)
**	instance	DBMS config instance (ie the [3] element of the original
**			parameter name)
**	output		FILE * for output file
**	idx		Index of symbol to check for special treatment
**	orig_val	The old value of the parameter if any
**	value		The new value of the parameter
**
**	module locals pm_context, tee_stdout must be set.
**
** Outputs:
**	None
**
** Side Effects:
**	Can delete/insert (cache) parameters, fire dependencies on dmf_connect
**
** History:
**	23-Sep-2004 (schka24)
**	    Separate out of CRsetPMval so that it can be called for
**	    dependent symbols too.
**	06-Feb-2005 (gupsh01)
**	    Cache name is restricted to 10 characters, this causes a segv
**	    for other languages when translated name could be more than
**	    10 characters. Increased the cache name buffer to avoid segv.
**	18-Feb-2005 (devjo01)
**	    Change curr_cache & new_cache to string pointers since "private"
**	    or "shared" do not get localized.  Don't bother allocating memory
**	    for constant string values.  Pass FALSE instead of NULL where
**	    appropriate to quell compiler warnings.
**	04-Jan-2007 (kibro01) b117214
**	    Extensive reworking to make amendments to startup count work
**	    across all servers rather than changing incorrect cache 
**	    parameters, including leaving the cache invalid or wiping out
**	    the cache parameters for the default server altogether.
**	12-Mar-2007 (toumi01)
**	    For extensive rework fix fall through logic that affected situation
**	    where "the existing cache is private - so do nothing special."
**	    This corrects a problem of config.dat being corrupted by iimkcluster.
**	03-May-2007 (kibro01) b118256
**	    cbf crashes on an attempt to change the name of cache when
**	    not using shared caching (which could be useful if you were
**	    doing that and intending to change to shared caching afterwards)
**       4-Nov-2010 (hanal04) Bug 124655
**          Update port values in-line with CBF when the gcd startup count
**          is changed.
**      04-Apr-2011 (horda03) b125213
**          Use original cache_name when checking for other DBMS server
**          definitions still using the cache. Also only delete the dmf_connect
**          entry if no other server using the cache.
*/

static void
special_rules(char *host, char *instance, FILE *output,
	i4 idx, char *orig_val, char *value)
{
    bool cache_mod;			/* TRUE if need to redo dmf_connect */
    char *curr_cache, *new_cache;	/* "private" or "shared" */
    char *new_cachename, *old_cachename;	/* Cache names */
    char *tmp_cachename;		/* Temp cache names */
    char *cache_type;			/* Shared or private */
    char *regexp;
    char *scan_name;
    char *scan_value;
    char *symbol;
    bool cache_used = FALSE;
    char *cache_list[]={ NULL, ERx("cache"), ERx("p4k"),
		ERx("p8k"), ERx("p16k"), ERx("p32k"), ERx("p64k") };
    i4 ncache_list=sizeof(cache_list)/sizeof(char*);
    i4 i;
    char temp[ BIG_ENOUGH ];

    cache_mod = FALSE;

    /* Defensive... */
    if (orig_val == NULL)
	orig_val = "0";

    /* If the second $, the third parameter, is NULL, that means
    ** this is the "*", or default server.  Since the change may
    ** be triggered by a change to the startup count in a different
    ** instance, we need to remember to change this one correctly
    */
    if (pm_context->def_elem[3] == NULL)
	instance = "*";

    symbol = CRsymbol( idx );

    /*
    ** if ii.$.dbms.$.cache_sharing or ii.$.dbms.$.cache_name are
    ** being set, create and/or delete DBMS cache resources as necessary.
    */
    if ( STcompare( symbol + STlength(SystemCfgPrefix), 
	 ERx(".$.dbms.$.cache_sharing") ) == 0 )
    {
	    /* ii.$.dbms.$.cache_sharing is being set */
	    tmp_cachename = get_cache_name(host, instance);

	    if ( ValueIsBoolTrue( orig_val ) != ValueIsBoolTrue ( value ) )
	    {
	        cache_mod = TRUE;

	        /* scan existing private cache resources */
		if ( ValueIsBoolTrue(value) ) /* private -> shared */
		{
	            curr_cache = ERx("private");
	            new_cache = ERx("shared");
		    new_cachename = tmp_cachename;
		    old_cachename = instance;
		    cache_used = FALSE;
		} else /* shared -> private */
		{
	            curr_cache = ERx("shared");
	            new_cache = ERx("private");
		    new_cachename = instance;
		    old_cachename = tmp_cachename;
		    cache_used = check_if_shared_cache_used(
				host, instance, old_cachename);
		}
		for (i = 0; i < ncache_list; i++)
		{
	            scan_cache_params(host, curr_cache, new_cache, 
		        old_cachename, new_cachename, 
			cache_list[i], output, cache_used);
		}
		    
		/* delete ii.$.dbms.$.$.config.dmf_connect */
		STprintf( temp,
		    ERx( "%s.%s.dbms.%s.%s.config.dmf_connect" ),
		    SystemCfgPrefix,
		    host, curr_cache, old_cachename );
		(void) PMmDelete( pm_context, temp );	
	    }

	    /* b117214 (kibro01)
	    ** Now work through any other dbms servers to change
	    ** them too since we're triggering a change from
	    ** private to shared cache based on the total number
	    ** of servers (as per the rule for cache_sharing in
	    ** dbms.crs)
	    */
	    scan_caches_and_change(symbol, value, output);
    }
    else if ( STcompare( symbol + STlength(SystemCfgPrefix), 
	      ERx( ".$.dbms.$.cache_name" ) ) == 0 )
    {
	    /*
	    ** ii.$.dbms.$.cache_name is being changed, so check
	    ** whether or not existing cache is shared, and delete/
	    ** create shared cache resources if required.
	    */ 

	    cache_mod = TRUE;

	    /*
	    ** assume cache is private if ii.$.dbms.$.cache_sharing
	    ** doesn't exist.
	    */
	    STprintf( temp, ERx( "%s.%s.dbms.%s.cache_sharing" ),
		      SystemCfgPrefix, host, instance );

	    if( PMmGet( pm_context, temp, &cache_type ) != OK || 
		    ValueIsBoolTrue( cache_type ) )
	    {
		    /* existing DBMS cache is shared */
		    bool cache_used;

		    curr_cache = ERx("shared");
		    old_cachename = orig_val;
		    new_cache = ERx("shared");
		    new_cachename = value;

		    cache_used = check_if_shared_cache_used(
				host, instance, old_cachename);

		    for (i = 0; i < ncache_list; i++)
		    {
	                scan_cache_params(host, curr_cache, new_cache, 
		            orig_val, value, cache_list[i], output, cache_used);
		    }

                    if (!cache_used)
                    {
		       /* delete ii.$.dbms.$.$.config.dmf_connect */
		       STprintf( temp,
			    ERx( "%s.%s.dbms.shared.%s.config.dmf_connect" ),
			    SystemCfgPrefix, host, orig_val );
		       (void) PMmDelete( pm_context, temp );	
                    }
	    }
	    else
	    {
		    /*
		    ** the existing cache is private - so do nothing
		    ** special.
		    */
		    curr_cache = ERx("private");
		    old_cachename = orig_val;
		    new_cache = ERx("private");
		    new_cachename = instance;
	    }
    }
    else if ( STcompare( symbol + STlength(SystemCfgPrefix), 
	              ERx( ".$.dbms.$.connect_limit" ) ) == 0 || 
	      STcompare( symbol + STlength(SystemCfgPrefix), 
	              ERx( ".$.ingstart.$.dbms" ) ) == 0 )
    {
	    /*
	    ** set up cache_mod, cache_type, and cache_id for  
	    ** ii.$.dbms.$.$.config.dmf_connect recalculation.
	    */

	    char *cache_sharing;
	    
	    cache_mod = TRUE;
	    
	    STprintf( temp, ERx( "%s.%s.dbms.%s.cache_sharing" ),
		      SystemCfgPrefix, host, instance );
	    if( PMmGet( pm_context, temp, &cache_sharing ) != OK ||
		    ! ValueIsBoolTrue( cache_sharing ) ) 
	    {
		    /* cache is private */
		    new_cache = ERx("private");
		    new_cachename = instance;
	    }
	    else
	    {
		    /* cache is shared */
		    new_cache = ERx("shared");
		    new_cachename = get_cache_name(host, instance);
	    }
    }

    if( cache_mod )
    {
	    /*
	    ** ii.$.dbms.$.connect_limit, ii.$.dbms.$.cache_name,
	    ** or ii.$.dbms.$.cache_sharing are being changed, so
	    ** reset ii.$.dbms.$.$.config.dmf_connect explictly.
	    **
	    ** assume that the expected cache resources have been
	    ** created at this point.
	    */

	    char resource[ BIG_ENOUGH ], value[ BIG_ENOUGH ];

	    /* get new value for ii.$.dbms.$.$.config.dmf_connect */
	    getDMFconnect( host, new_cache, new_cachename, value );

	    /* compose hidden dmf connect limit resource name */
	    STprintf( resource,
		    ERx( "%s.%s.dbms.%s.%s.config.dmf_connect" ),
		    SystemCfgPrefix, host, new_cache, new_cachename );

	    /* now set it and everything it depends on */ 
	    (void)CRsetPMval( resource, value, output, tee_stdout, FALSE );
    }

    if ( STcompare( symbol + STlength(SystemCfgPrefix), 
	 ERx(".$.ingstart.$.gcd") ) == 0 )
    {
        /* Need to update the ports */
        char *serverType;

        serverType = PMmGetElem(pm_context, 4, symbol);       
        scan_ports_and_change(host, serverType, instance, value, output);
    }
} /* special_rules */

bool
check_cache_name(char   *value)
{
    char        *p;

    p = value;

    if ((*p == EOS))
        return(FAIL);

    if (!CMalpha(p))
        return(FAIL);

    for (CMnext(p); *p != EOS; CMnext(p))
    {
        if (CMoper(p) || CMwhite(p))
            return(FAIL);
    }
    return(OK);
}

/*
** Name: scan_ports_and_change - Change ports values.
**
** Description:
**	Indicate that port rollups are supported for DAS or GCC
**      TCP ports with the syntax XXnn or numeric ports.  A plus
**      sign ("+") is appended to the port code if this format is
**      detected and no plus sign already exists.
**
** Inputs:
**      host		The config host being updated.
**	serverType	The server type being updated. gcd only for now.
**	instance	The instance being updated.
**      countStr	The value being set.
**	output		FILE * for output file
**
** Outputs:
**	None
**
** Side Effects:
**	May update port parameters.
**
** History:
**	 4-Nov-2010 (hanal04) Bug 124655
**	    Created from format_port_rollups() used in CBF.
**
*/

static void
scan_ports_and_change(char *host, char *serverType, char *instance, 
                      char *countStr, FILE *output)
{
    char temp[ BIG_ENOUGH ], expbuf[ BIG_ENOUGH ];
    char *regexp, *last, *name, *value;
    char *startCntBuff;
    char *gcd_warnmsg = "Setting startup count to one";
    char *protocol;
    char *type;
    STATUS status;
    char newPort[GCC_L_PORT];
    u_i2 offset = 0;
    u_i2 portNum = 0;
    u_i2 numericPort = 0;
    u_i2 startCount = 0;
    u_i2 startOffset = 0;
    PM_SCAN_REC state;
    typedef struct
    {
        QUEUE port_q;
        char *port;
        char *protocol;
    }  PORT_QUEUE;
    PORT_QUEUE pq, *pp;
    QUEUE *q;

    startCntBuff = countStr;
    QUinit ( &pq.port_q );

    STprintf( expbuf, ERx( "%s.%s.%s.%s.%%.port" ),
        SystemCfgPrefix, host, serverType, instance );

    regexp = PMmExpToRegExp( pm_context, expbuf );

    /*
    ** Search for items pertaining to the present server type and
    ** instance with a TCP protocol and port.
    */
    for( status = PMmScan( pm_context, regexp, &state, NULL,
        &name, &value ); status == OK; status =
        PMmScan( pm_context, NULL, &state, NULL, &name,
        &value ) )
    {
        /* extract protocol name */
        protocol = PMmGetElem( pm_context, 4, name );

        /* extract port */
        type = PMmGetElem( pm_context, 5, name );

        if ( !STcompare(protocol, "tcp_ip" ) ||
             !STcompare(protocol, "wintcp" ) ||
             !STcompare(protocol, "tcp_wol" ) ||
             !STcompare(protocol, "tcp_dec" ))
        {
            pp = (PORT_QUEUE *)MEreqmem( 0,
                sizeof(PORT_QUEUE), TRUE, NULL );
            pp->port = STalloc( value );
            pp->protocol = STalloc( protocol );
            QUinsert( (QUEUE *)pp, &pq.port_q );

            /*
            ** Check for a numeric port.
            **
            ** If input is not strictly numeric, input is
            ** ignored.
            **
            ** Extract the numeric port and check for expected
            ** syntax: n{n}+.
            */
            numericPort = 0;
            if ( portNum == 0 )
                for( offset = 0; CMdigit( &value[offset] ); offset++ )
                    numericPort = (numericPort * 10) + (value[offset] - '0');
            /*
            ** Extract the startup count.
            */
            for( startOffset = 0, startCount = 0;
                CMdigit( &startCntBuff[startOffset] ); startOffset++ )
            {
                startCount = (startCount * 10) +
                    (startCntBuff[startOffset] - '0');
            }

            /*
            ** If the port is explicitly numeric, the user may
            ** not want the port number to increment.  Skip
            ** the change the user will need to manually
            ** set the port number.
            */
            if ( ! value[ offset ] && numericPort && startCount > 1)
            {
                STprintf( expbuf, ERx( "%s.%s.%s.%s.%s.%s" ),
                          SystemCfgPrefix, host, serverType,
                          instance, pp->protocol, type );
                STprintf( temp, ERx( "\nUNCHANGED %s: (%s)\n\n" ),
                                   expbuf, pp->port );
                CRFPRINT( output, temp);
                startCount = 1;
            }
        } /* if (!STcompare("tcp_ip"... */
    } /* for( status = PMmScan( pm_context... */

    /*
    ** Go through the queue and re-write the ports
    ** with the rollup indicator if the startup count is greater
    ** than one and no indicator exists.  If the startup count
    ** is less than 2, remove the indicator if it exists.
    */
    for (q = pq.port_q.q_prev; q != &pq.port_q;
        q = q->q_prev)
    {
        pp = (PORT_QUEUE *)q;
        for( portNum = 0, offset = 0; CMalpha( &pp->port[0] )
           && (CMalpha( &pp->port[1] ) ||
              CMdigit( &pp->port[1] )); )
        {
            /*
            ** A two-character symbolic port permits rollup
            ** without special formatting.
            */
            offset = 2;
            if ( ! pp->port[offset] )
                break;

            /*
            ** A one or two-digit base subport may be
            ** specified.
            */
            if ( CMdigit( &pp->port[offset] ) )
            {
                portNum = (portNum * 10) + (pp->port[offset++] - '0');

                if ( CMdigit( &pp->port[offset] ) )
                {
                    portNum = (portNum * 10) + (pp->port[offset++] - '0');

                    /*
                    ** An explicit base subport must be in
                    ** the range [0,15].  A minimum of
                    ** 14 is required to support
                    ** rollup.
                    */
                    if ( portNum > 14 )
                    {
                        offset = 0;
                        break;
                    }
                }
            } /* if ( CMdigit ( &pp->port[offset] ) */

            /*
            ** Unconditionally break from this loop.
            */
            break;

        } /* for( ; CMalpha( &pp->port[0] ) ... */

        /*
        ** Subport values greater than 14 cannot roll up.  Ignore them.
        */
        if ( portNum > 14 )
           continue;

        /*
        ** Check for a numeric port.
        **
        ** If input is not strictly numeric, input is
        ** ignored.
        **
        ** Extract the numeric port and check for expected
        ** syntax: n{n}+.
        */
        numericPort = 0;
        if ( portNum == 0 )
        {
            for( offset = 0; CMdigit( &pp->port[offset] ); offset++ )
                numericPort = (numericPort * 10) + (pp->port[offset] - '0');
        }

        /*
        ** Ports with the format "XX" are ignored.
        */
        if ( offset < 3 && !numericPort )
            continue;

        /*
        ** Existing ports with rollups are ignored if the startup count
        ** is greater the one.
        */
        if ( startCount > 1 && ( pp->port[ offset ] == '+' ) )
            continue;

        /*
        ** If no rollup indicator is present, and no multiple startups
        ** have been specified, ignore.
        */
        if ( startCount < 2 && ! pp->port[ offset ] )
            continue;

        /*
        ** If multiple startups are not specified, remove the rollup
        ** indicator if it exists.
        **
        ** After this, all exceptions should have been handled and
        ** the port is re-written with the plus indicator.
        */
        if ( startCount < 2 && pp->port[ offset ] == '+' )
        {
            STprintf( newPort, "%s", pp->port );
            newPort[ offset ] = '\0';
        }
        else
            STprintf( newPort, "%s+", pp->port );

        STprintf( expbuf, ERx( "%s.%s.%s.%s.%s.%s" ),
            SystemCfgPrefix, host, serverType,
                instance, pp->protocol, type );

        STprintf( temp, ERx( "\nCHANGE %s: (%s)...(%s)\n\n" ),
                                   expbuf, pp->port, newPort );
        CRFPRINT( output, temp);
        (void)CRsetPMval( expbuf, newPort, output, tee_stdout, FALSE );

    } /* for ( q = pq.port... */

    /*
    ** De-allocate any items in the port queue.
    */
    for (q = pq.port_q.q_prev; q != &pq.port_q;
        q = pq.port_q.q_prev)
    {
        pp = (PORT_QUEUE *)q;
        MEfree((PTR)pp->port);
        MEfree((PTR)pp->protocol);
        QUremove (q);
        MEfree((PTR)q);
    }
}
