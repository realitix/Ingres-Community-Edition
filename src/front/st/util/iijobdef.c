# ifdef VMS
/*
**  Copyright (c) 1992, 2008 Actian Corporation
**
**  Name: iijobdef.c -- defines JOB level logicals for VMS INGRES
**	installations which use GROUP level logicals.
**
**  Usage:
**	iijobdef
**
**  Description:
**	The iijobdef executable replaces the iijobdef.com script
**	generated by iibuild.com in pre-6.4+1 releases.  It scans
**	config.dat for entries in the form "ii.(host).lnm.(logical)",
**	defining a JOB logical for each entry if the value of
**	ii.(host).lnm.table.id is "LNM$GROUP".  Otherwise, the
**	program exits quietly.
**
**  Exit Status:
**	OK	JOB logicals were set successfully or they are not needed. 
**	FAIL	Unable to set at a logical.	
**
**  History:
**	1-mar-93 (tyler)
**		Created.	
**	15-mar-93 (tyler)
**		Removed code which created II_JOBDEF_RUN (logical used
**		by external script to avoid running iijobdef twice). 
**		This turns out to be a bad idea since it means that
**		config.dat changes made after iijobdef is run the first
**		time never make it into the JOB logical table.	
**	22-mar-93 (tyler)
**		Added main() declaration and a print statement to
**		non-VMS code (formerly nothing but blank lines) so as
**		not to generate build errors on non-VMS platforms.
**	24-may-93 (tyler)
**		Fixed VMS code broken by previous change and added
**		argument to PMmInit() call.  Switched to new interface 
**		for multiple context PM functions.
**	21-jun-93 (tyler)
**		JOB logicals are now created in supervisor rather than
**		executive mode (BUG #52803).  Also, switched to new
**		interface for multiple context PM functions.
**	23-jul-93 (tyler)
**		PMmInit() interface changed.  PMerror() is now passed
**		to PMmLoad() for better error reporting. 
**      14-sep-93 (smc)
**          	Moved <cs.h> for CS_SID.
**	19-oct-93 (tyler)
**		Call PMhost() instead of GChostname().
**	1-may-95 (dougb)
**		Use lib$set_logical() so that logicals are really created in
**		supervisor mode.  sys$crelnm() ignores specified access mode
**		unless user currently has the SYSNAM privilege.  Also, use
**		"real" descriptor class and types.
**	1-jun-95 (dougb)
**		Add ability to remove logicals.  Done whenever *any*
**		parameter is found on the command line (value is ignored).
**		Convert to use lib$match_cond() throughout.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	11-jun-2001 (kinte01)
**	    Add  multiple product build support
**      29-Apr-2003 (ashco01) Bug: 110139
**		Moved check of lnm_table_name for system-level installation to 
**		earlier in the code, prior to the variables re-use to hold
**		the target logical name table name. Premature re-use of this 
**		variable was causing the installation level check to return 
**		FALSE in all installation types, causing the JOB level logicals
**		to be defined even in SYSTEM level installations.
**	17-sep-2003 (abbjo03)
**	    Changes to use VMS headers provided by HP. Remove duplicate loop to
**	    define the VMS logicals using wildcard (*.lnm) syntax since the
**	    node-specific ($.lnm) syntax covers it.
**      12-May-2004 (ashco01) Bug 112293/INGSRV2824
**              IIJOBDEF.EXE must define the logicals for SYSTEM level
**              installations otherwise (following a system reboot) INGSTART
**              will fail because (for example) II_COMPATLIB is not defined,
**              if SYSCHECK_MODE is ON (because SYSCHK.COM uses FE tools).
**              Also, it is permissible for a user to use a SYSTEM level
**              installation in preference to a GROUP level installation;
**              which won't occur if the user is in the same GROUP as an
**              Ingres installation; the SYSTEM level logical values won't
**              be used. Removed the redundant check for SYSTEM level
**              installation.
**	11-Jun-2004 (somsa01)
**	    Cleaned up code for Open Source.
**      31-aug-2004 (sheco02)
**          X-integrate change 468773 to main.
**	09-oct-2008 (stegr01/joea)
**	    Replace II_VMS_ITEM_LIST_3 by ILE3.
**      19-Jul-2011 (horda03) b125458
**         iicommon.h required before cs.h
*/

# endif /* VMS */
# include <compat.h>
# ifdef VMS
# include <iicommon.h>
# include <gl.h>
# include <cs.h>
# include <sl.h>
# include <me.h>
# include <lo.h>
# include <pc.h>
# endif /* VMS */
# include <si.h>
# ifdef VMS
# include <cv.h>
# include <nm.h>
# include <er.h>
# include <cm.h>
# include <st.h>
# include <pm.h>
# include <pmutil.h>
# include <util.h>
# include <simacro.h>

# include <ssdef.h>
# include <iledef.h>
# include <libdef.h>
# include <descrip.h>
# include <lnmdef.h>
# include <psldef.h>
# include <starlet.h>

# define F_PRINT2( F_MSG, ARG, ARG2 )  SIprintf( ERx( F_MSG ), ARG, ARG2 );

/*
PROGRAM =	iijobdef
**
NEEDLIBS =	UTILLIB MALLOCLIB COMPATLIB GLLIB
**
UNDEFS =	II_copyright
**
DEST =		utility
*/

# endif /* VMS */
main( i4  argc, char **argv)
{
# ifdef VMS
	char *host;
	i4 i;
	PM_SCAN_REC state;
	STATUS status;
	char *lnm_table_name;
	struct dsc$descriptor lnm_table;
	char *regexp;
	char *name, *value;
	PM_CONTEXT *config;
	struct dsc$descriptor lnm_name;
	ILE3 item_list[ 2 ];
	long access_mode = PSL$C_SUPER;

	bool failed_once = FALSE;		/* lib$set_logical works? */
	const match_1 = LIB$_NOCLI;		/* Process has no CLI. */
	const match_2 = LIB$_UNECLIERR;		/* Unexpected CLI error
						 * (non-standard CLI?).
						 */
	const match_3 = SS$_NORMAL;		/* Normal return. */
	const match_4 = SS$_SUPERSEDE;		/* Replaced old value. */
	const match_5 = SS$_NOLOGNAM;		/* Not currently defined. */

	bool delete_logs = FALSE;		/* What are we doing? */
	char *act_str;				/* String for action. */
	char *err_str;				/* String for error exit. */
	char *log_str;				/* String to log action. */
        char tmp_buf[BIG_ENOUGH];

	MEadvise( ME_INGRES_ALLOC );

	if( argc != 1 )
		delete_logs = TRUE;

	(void) PMmInit( &config );

	if( PMmLoad( config, NULL, PMerror ) != OK )
		PCexit( FAIL );

	host = PMmHost( config );

	PMmSetDefault( config, HOST_PM_IDX, host );

	/* get logical table name */ 

	STprintf (tmp_buf , ERx( "%s.$.lnm.table.id" ), SystemCfgPrefix);

	if( PMmGet( config, tmp_buf , &lnm_table_name )
		!= OK )
	{
		F_ERROR( "%s not found.", PMmExpandRequest( config,
			tmp_buf ) );
	}

	/* set logical name table */
	lnm_table_name = ERx( "LNM$JOB" );

	/* compose string descriptor for logical table name */
	lnm_table.dsc$w_length = STlength( lnm_table_name );
	lnm_table.dsc$a_pointer = lnm_table_name; 
	lnm_table.dsc$b_class = DSC$K_CLASS_S;
	lnm_table.dsc$b_dtype = DSC$K_DTYPE_T;

	if ( delete_logs ) {
	    act_str =  ERx( "\nDeleting %s logicals...\n\n(%s)\n\n" );
	    err_str = ERx( "Unable to deassign %s.\n\n" );
	    log_str = ERx( "" );
	} else {
	    act_str = ERx( "\nDeleting %s logicals...\n\n(%s)\n\n" );
	    err_str = ERx( "Unable to set %s to \"%s\".\n\n" );
	    log_str = ERx( "\"%s\" = \"%s\"\n" );
	}

	F_PRINT2( act_str, SystemDBMSName, lnm_table_name );

	/* scan and set node-specific logicals */

	regexp = PMmExpToRegExp( config, ERx( "ii.$.lnm.%") );
	for(
		status = PMmScan( config, regexp, &state, NULL, &name,
		&value ); status == OK; status = PMmScan( config,
		NULL, &state, NULL, &name, &value ) )
	{
		name = PMmGetElem( config, 3, name );

		lnm_name.dsc$w_length = STlength( name );
		lnm_name.dsc$a_pointer = name;
		lnm_name.dsc$b_class = DSC$K_CLASS_S;
		lnm_name.dsc$b_dtype = DSC$K_DTYPE_T;

		item_list[ 0 ].ile3$w_length = STlength( value );
		item_list[ 0 ].ile3$w_code = LNM$_STRING; 
		item_list[ 0 ].ile3$ps_bufaddr = value; 
		item_list[ 0 ].ile3$ps_retlen_addr = NULL; 
		item_list[ 1 ].ile3$w_length = 0;
		item_list[ 1 ].ile3$w_code = 0;

		if ( !failed_once ) {
		    if ( delete_logs )
			status = lib$delete_logical( &lnm_name, &lnm_table );
		    else
			status = lib$set_logical( &lnm_name, NULL, &lnm_table,
						 NULL, item_list );
		    if ( lib$match_cond( &status, &match_1, &match_2 ))
			failed_once = TRUE;
		}
		if ( failed_once ) {
		    if ( delete_logs )
			status = sys$dellnm( &lnm_table, &lnm_name,
					    &access_mode );
		    else
			status = sys$crelnm( NULL, &lnm_table, &lnm_name,
					    &access_mode, item_list );
		}

		if ( !lib$match_cond( &status, &match_3, &match_4, &match_5 ))
		{
			SIfprintf( stderr, err_str, name, value );
			PCexit( FAIL );
		}

		SIprintf( log_str, name, value );
	}

	PCexit( OK );
# else /* VMS */
	SIprintf( "\nThis doesn't do much.\n\n" );
# endif /* VMS */
}
