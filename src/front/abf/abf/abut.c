/*
** Copyright (c) 1990, 2008 Actian Corporation
*/

# include	<compat.h>
# include       <lo.h>
# include	<pe.h>		 
# include	<cv.h>		 
# include	<er.h>
# include	<ol.h>
# include       <ci.h>
# include       <st.h>
# include       <nm.h>
# include       <si.h>
# include       <ut.h>
# include       <tm.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<fe.h>
# include	<ug.h>
# include	<eqlang.h>
# include	<eqrun.h>
# include	"abut.h"
# include	<abfcnsts.h>
# include	"erab.h"

#ifdef SEP_SYNC
# include       "tc_sync.h"
GLOBALREF       TCFILE  *IIFTcommfile;
#endif

/**
** Name:	abut.c		- UT-like routines for compilation
**
** Description:
**	This file defines:
**
**	IIUTlang	Check the language of a file
**	IIUTdml		Return the DML for the source-code file
**	IUTcompile	Compile a Source File to an object file
**	IIUTdbCompile	Compile A Source File into the Database.
**
** History:
**	7/90 (Mike S)	Removed from "abfcom.c"
**	11-march-91 (blaise)
**	    Integrated desktop porting changes
**	03/17/91 (emerson)
**		Added logic to print IL generated by 4GL compiler
**		if II_4GL_PRINT_IL defined.  The listing is placed 
**		in the object directory.  The filename is derived
**		from the source file name; the extension is ".il"
**		(instead of ".osq").  This feature is undocumented;
**		It's for testing and problem diagnosis.
**		Note: Requires new entry " illist -t%S " be added to
**		osl and oslsql in utexe.def.
**	16-aug-91 (leighb)
**		File extension for IBM/PC (PMFE) for compiled forms is "fmc".
**	02-dec-91 (bentley)
**		Added COBOL support for dr6_us5 and dra_us5.
**	26-feb-1992 (mgw) Bug #38790
**		Report OS level error messages from failed compiles if
**		available in IIUTcompile() and IIUTdbCompile().
**	22-may-1992 (mgw)
**		Change ERlookup() call to not request a timestamp. It messes
**		up Testing canons and seems to cause ERlookup to report
**		success when it shouldn't on Unix.
**	20-Jul-92 (fredb)
**		Add language extension defines for MPE (hp9_mpe), remove
**		Pascal from UTsuffix table as it is not supported.
**	19-Jan-93 (fredb)
**		Porting changes for hp9_mpe; described in detail in the
**		individual function headers.
**	26-jan-93 (leighb) DeskTop Porting Change:
**		"fmc" file extension used for DOS only - not for MS-Win.
**	04-Feb-93 (fredb)
**		Changed the length of LOdetail buffers to avoid overruns in
**		IIUTlang(), IIUTdml(), IIUTcompile(), and IIUTdbCompile().
**	20-May-1993 (fredb)
**		IFDEF my prior changes to LO buffer sizes.  The relationship
**		between the defined sizes is different between MPE & UNIX.
**		Bug #51560
**  	21-May-93 (william)
**      	some of the semi-colon were missed; added back
**      29-jan-93 (pauland)
**              Added usl_us5 support as per dra_us5.
**       2-dec-1993 (smc)
**		Bug #58882
**          	Removed truncating cast of args in calls to UTexe.
**	08-feb-94 (rudyw)
**		Fix bug 41621. Added suffix 'qsc' to the list in utsuffix
**		so that it could be found during search via IIUTdml routine.
*  15-feb-95 (nick) (x-int angusm)
**      Variable basename in IIUTdbCompile() was overflowing as it
**      was being declared as LO_FPREFIX_MAX rather than LO_NM_LEN
**      - bug 56774
**	15-may-97 (mcgem01)
**	    Clean up compiler warnings - order of includes.
**	10-may-1999 (walro03)
**	    Remove obsolete version string dra_us5.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	12-feb-2003 (abbjo03)
**	    Remove PL/1 as a supported language.
**      11-Jun-2004 (hanch04)
**          Removed reference to CI for the open source release.
**      17-dec-2008 (joea)
**          Replace READONLY/WSCREADONLY by const.
**	26-May-2009 (kschendel) b122041
**	    Compiler warning fixes.
**/

/* # define's */
#define UT_NODML        0
#define UT_QUEL         1
#define UT_SQL          2

#ifdef VMS
#define FORTRAN ERx("for")
#define PASCAL ERx("pas")
#define BASIC ERx("bas")
#define COBOL ERx("cob")
#define ADA ERx("")
#endif   

#ifdef UNIX
#define FORTRAN ERx("f")
#define PASCAL ERx("")
#define BASIC ERx("")
#if defined (dr6_us5) || defined (usl_us5)
#define COBOL ERx("cbl")
#else
#define COBOL ERx("")
#endif /* dr6_us5 || usl_us5 */
#define ADA ERx("")
#endif
 
#ifdef IBM
#define FORTRAN ERx("fortran")
#define PASCAL ERx("")
#define BASIC ERx("")
#define COBOL ERx("cobol")
#define ADA ERx("")
#endif

#ifdef PMFE                            
#define FORTRAN ERx("for")             
#define PASCAL ERx("pas")              
#define BASIC ERx("bas")               
#define COBOL ERx("cob")               
#define ADA ERx("")                    
#endif                                 

#ifdef hp9_mpe
#define COBOL ERx("cob")               
#define FORTRAN ERx("for")             
	/* Unsupported Languages */
#define ADA ERx("")                    
#define PASCAL ERx("")
#define BASIC ERx("")
#endif

#ifdef DESKTOP
#define FORTRAN ERx("for")
#define PASCAL ERx("pas")
#define BASIC ERx("bas")
#define COBOL ERx("cob")
#define ADA ERx("")
#endif
/*
** The table which converts from a suffix of a file to the
** Right equel language constants for IIlang.
*/
typedef struct {
        char    *acsuffix;
        i4      aclang;
        i4      acci;
        i4      acdml;
} UT_SUFFIX;
 
# define        UTSUFSIZ        (sizeof(utsuffix)/sizeof(utsuffix[0]))

/* GLOBALDEF's */
GLOBALDEF char  *IIutExtensions[_OLMAX+1][3] = {
                        {ERx("c"),      ERx("qc"),      ERx("sc")},
                        {FORTRAN,       ERx("qf"),      ERx("sf")},
                        {PASCAL,        ERx("qp"),      ERx("sp")},
                        {BASIC,         ERx("qb"),      ERx("sb")},
                        {COBOL,         ERx("qcb"),     ERx("scb")},
                        {ERx(""),       ERx(""),        ERx("")},
                        {ADA,           ERx("qa"),      ERx("sa")},
                        {ERx(""),       ERx("osl"),     ERx("osq")},
                        {ERx(""),       ERx("quel"),    ERx("sql")}
  };

/* extern's */

/* static's */
static STATUS   getLanguage();
static const UT_SUFFIX * _utSuffix ();
static STATUS	dmlCompile();
static STATUS	ilListFile();

/*
** .mar files are macro.  They are used for compiled forms and
** internal ABF structures.  Their query language is none, and their
** CI constants is -1 so that macro is always legal.
**
** History:
**      03/90 (jhw) -- Removed uncompilable languages.
*/
static const UT_SUFFIX       utsuffix[] = {
        {ERx("sql"),    hostDML,        CI_SQL_TM,      UT_SQL},
        {ERx("osl"),    hostOSL,        CI_OSLQUEL,     UT_QUEL},
        {ERx("osq"),    hostOSL,        CI_OSLSQL,      UT_SQL},
#ifndef PCINGRES
        {ERx("qc"),     hostC,          CIeqC,          UT_QUEL},
        {ERx("sc"),     hostC,          CIesqC,         UT_SQL},
        {ERx("qf"),     hostFORTRAN,    CIeqFORTRAN,    UT_QUEL},
        {ERx("sf"),     hostFORTRAN,    CIesqFORTRAN,   UT_SQL},
#if defined(dr6_us5) || defined(usl_us5)
        {ERx("qcb"),    hostCOBOL,      CIeqCOBOL,      UT_QUEL},
        {ERx("scb"),    hostCOBOL,      CIesqCOBOL,     UT_SQL},
#endif /* dr6_us5 || usl_us5 */
#ifndef UNIX
        {ERx("qcb"),    hostCOBOL,      CIeqCOBOL,      UT_QUEL},
        {ERx("scb"),    hostCOBOL,      CIesqCOBOL,     UT_SQL},
#ifdef VMS
        {ERx("qp"),     hostPASCAL,     CIeqPASCAL,     UT_QUEL},
        {ERx("sp"),     hostPASCAL,     CIesqPASCAL,    UT_SQL},
        {ERx("qb"),     hostBASIC,      CIeqBASIC,      UT_QUEL},
        {ERx("sb"),     hostBASIC,      CIesqBASIC,     UT_SQL},
/* Ada compilation not supported!
        {ERx("qa"),     hostADA,        CIeqADA,        UT_QUEL},
        {ERx("sa"),     hostADA,        CIesqADA,       UT_SQL},
*/
#endif  /* VMS */
#endif  /* not UNIX */

/*
** The following extension is for internal use, but unlike the next set of
** internal use entries this must have a query language (specifically SQL).
** It's inclusion was made necessary by the discovery of the use of filename
** abrtlkup.qsc in file front!abf!iaom!iamsystm.c attached to the 'lookup'
** user frame.
** Bug 41621 demonstrated that the FIND operation during a lookup on integer
** values was rendered non-functional (in adi_opid) because the lookup user
** frame being built in abextract.c without a query language specified.
** Note that SQL must be specified to allow use of '*' when ii_qualify added.
*/
        {ERx("qsc"),    hostC,          CIesqC,         UT_SQL},

/*
** The extensions from here down are supported for compatibility and for
** internal use.  Since their presence can't be checked with CI, they are
** always available.  This should really be part of the CL.  The query
** language is none since they don't have a query language.
*/
        {ERx("c"),      hostC,          -1,             UT_NODML},
#ifdef PMFEDOS
        {ERx("fmc"),    hostC,          -1,             UT_NODML}
#endif
#ifdef UNIX
        {ERx("f"),      hostFORTRAN,    -1,             UT_NODML},
        {ERx("F"),      hostFORTRAN,    -1,             UT_NODML},
        {ERx("s"),      hostC,          -1,             UT_NODML},
#if defined(dr6_us5) || defined(usl_us5)
        {ERx("cbl"),    hostCOBOL,      -1,             UT_NODML}
#endif /* dr6_us5 || usl_us5 */
#endif
#ifdef VMS
        {ERx("mar"),    hostC,          -1,             UT_NODML},
        {ERx("pas"),    hostPASCAL,     -1,             UT_NODML},
        {ERx("for"),    hostFORTRAN,    -1,             UT_NODML},
        {ERx("bas"),    hostBASIC,      -1,             UT_NODML},
/* Ada compilation not supported!
        {ERx("ada"),    hostADA,        -1,             UT_NODML},
*/
        {ERx("cob"),    hostCOBOL,      -1,             UT_NODML}
#endif
#ifdef IBM
        {ERx("assemble"),hostC,         -1,             UT_NODML},
        {ERx("fortran"),hostFORTRAN,    -1,             UT_NODML},
        {ERx("cobol"),  hostCOBOL,      -1,             UT_NODML}
#endif
#ifdef hp9_mpe
        {ERx("for"),    hostFORTRAN,    -1,         	UT_NODML},
        {ERx("cob"),    hostCOBOL,      -1,         	UT_NODML}
#endif
#endif  /* PCINGRES */
};

/*{
** Name:        IIUTlang() -    Check the language of a file.
**
** Description:
**      Looks at the extension of the file and returns the language contained
**      in the file.  It also checks to see if the extension is known by UT
**      and if the installation supports the language.
**
** Inputs:
**      file    {char *}  The file to check.
**
** Outputs:
**      lang    {nat *}  Set to the host language for the file extension.
**
** Returns:
**      {STATUS}        OK if file is okay.
**
** History:
**      (joe)  Written.
**      12/19/85 (joe)  Added error checking.
**      02/89 (jhw) -- Renamed as 'IIUTlang()'.
**      11/89 (jhw) -- Use PATH&FILENAME to support relative pathnames.
**      11/89 (jhw) -- Modified to allow all `plain' (non-EQL) extensions
**              supported by the system since ABFIMAGE can now be run without
**              ABF being authorized.
**	04-Feb-93 (fredb)
**		Changed length of suffix to prevent overruns.
**	20-May-1993 (fredb)
**		IFDEF my prior changes to LO buffer sizes.  The relationship
**		between the defined sizes is different between MPE & UNIX.
**		Bug #51560
*/
 
STATUS
IIUTlang ( file, lang )
char    *file;
i4      *lang;
{
        STATUS          rval;
        char            buf[MAX_LOC + 1];
        char            lbuf[MAX_LOC + 1];
        LOCATION        temp;
#ifdef hp9_mpe
        char            suffix[LO_FSUFFIX_MAX + 1];
#else
        char            suffix[(LO_EXT_LEN == 0 ? LO_NM_LEN : LO_EXT_LEN) + 1];
#endif
 
        if ( file == NULL || *file == EOS )
                return FAIL;
        STcopy(file, lbuf);
        if ( (rval = LOfroms(PATH&FILENAME, lbuf, &temp)) != OK  ||
                    (rval = LOdetail(&temp, buf, buf, buf, suffix, buf)) != OK )                return rval;
 
        return getLanguage( suffix, lang );
}

/*
** History:
**      09/89 (jhw) -- Moved lower-case of 'suffix[]' here so all cases
**                      are case-insensitive on such systems.  JupBug #7604.
*/
static STATUS
getLanguage ( suffix, lang )
char    *suffix;
i4      *lang;
{
        register const UT_SUFFIX   *sfp;
        STATUS                  rval;
 
        *lang = -1;
 
        if ( (sfp = _utSuffix(suffix)) == NULL )
        { /* Unrecognized extension */
                return UT_CO_SUF_NOT;
        }
        *lang = sfp->aclang;
        return OK;
}
 
/*
** Get structure pointer for suffix.
*/
static const UT_SUFFIX *
_utSuffix ( suffix )
char    *suffix;
{
        register const UT_SUFFIX      *sfp = &utsuffix[0];
        register i4             i;
 
        if ( !LO_NM_CASE )
                CVlower(suffix);
        for ( i = UTSUFSIZ ; --i >= 0 ; ++sfp )
        {
                if ( STequal(sfp->acsuffix, suffix) )
                        return sfp;
        }
        return NULL;
}

/*{
** Name:        IIUTdml() -     Return the DML for the Source-Code File.
**
** Description:
**      Given a file, checks the extension and returns the DML for
**      the extension.
**
** Inputs:
**      file    {char *}  The file.
**
** Outputs:
**      dml     {nat *}  The DML for the file.
**
** Returns:
**      {STATUS}  OK if the extension is recognized.
**
** History:
**      12/16/85 (joe)
**              Written.
**      09/89 (jhw) -- Abstracted from 'iiabExtDml()' as 'IIUTdml()'.
**	04-Feb-93 (fredb)
**		Changed length of suffix to prevent overruns.
**	20-May-1993 (fredb)
**		IFDEF my prior changes to LO buffer sizes.  The relationship
**		between the defined sizes is different between MPE & UNIX.
**		Bug #51560
*/
STATUS
IIUTdml ( file, dml )
char    *file;
i4      *dml;
{
        register const UT_SUFFIX      *sfp;
 
        LOCATION        *iiabMkLoc();
 
        if ( file != NULL )
        {
#ifdef hp9_mpe
                char    suffix[LO_FSUFFIX_MAX + 1];
#else
        	char    suffix[(LO_EXT_LEN == 0 ? LO_NM_LEN : LO_EXT_LEN) + 1];
#endif
                char    buf[MAX_LOC + 1];
 
                if ( LOdetail(iiabMkLoc("", file), buf, buf, buf, suffix, buf)
                                        == OK && *suffix != EOS
                                && (sfp = _utSuffix(suffix)) != NULL )
                {
                        *dml = sfp->acdml;
                        return OK;
                }
        }
 
        *dml = UT_NODML;
        return FAIL;
}

/*{
** Name:	ilListFile() -	Set Location for an IL List File
**				in Work Directory.
** Description:
**	If environment variable II_4GL_PRINT_IL is defined,
**	this routine sets a location for an IL list file in the work directory.
**	The name of the IL list file is formed by appending an extension
**	of ".il" to the name supplied by the caller.
**
** Input:
**	name	{char *}	The file name, not including extension.
**	lbuf	{char []}	The location buffer.
**	loc	{LOCATION *}	A reference to the location to be set.
**
** Output:
**	loc	{LOCATION *}	The location containing the path and file name
**				for a file in the work directory.
**
** Returns
**	{STATUS}  FAIL if environment variable II_4GL_PRINT_IL not defined;
**		  status returned by IIABfdirFile otherwise.
**
** History:
**	03/17/91 (emerson)
**		Written.
**	19-Jan-93 (fredb) hp9_mpe
**		Porting change: ".il" is not a legal extension (group) for
**		our implementation.  I changed it to ".tmp".
*/
static	i4	print_il = -1;

static	STATUS
ilListFile( name, lbuf, loc )
char		*name;
char		lbuf[ MAX_LOC + 1 ];
LOCATION	*loc;
{
	char	ilname[ LO_NM_LEN + 4 /* ".il" or ".tmp" */ + 1 ];

	if ( print_il == -1 )
	{
		char	*cp;

		print_il = 1;
		NMgtAt( ERx("II_4GL_PRINT_IL"), &cp );
		if ( cp == NULL || *cp == EOS )
		{
			print_il = 0;
		}
	}
	if ( print_il == 0 )
	{
		return FAIL;
	}
#ifdef hp9_mpe
	(VOID) STpolycat( 2, name, ERx(".tmp"), ilname );
#else
	(VOID) STpolycat( 2, name, ERx(".il"), ilname );
#endif
	return IIABfdirFile( ilname, lbuf, loc );
}

/*{
** Name:        IIUTcompile() -   Compile a Source File into a Library.
**
** Description:
**      Compile a file containing source code and place the resultant
**      object-code module into a library.  This is done only if it is
**      out-of-date with respect to the previous object-code module (if
**      any) in the library or if it is to be compiled regardless.  The
**      file is compiled according to its extension.
**
**      The rules that specify how a file is to be compiled (including which
**      compiler(s) to use) are specified in the "utcom.def" file in the
**      II_CONFIG directory.  This file has templates that specify how to
**      compile different extensions.  The rules are structured as follows:
**
**      <extension>             -- characters for extension
**              <command>       -- indented by a tab
**              <command>
**                ...
**              <command>
**
**      A command is:
**
**              <Eqlcommand> <arg> <arg> ... <arg>
**              <OScommand>  <arg> <arg> ... <arg>
**
**      An <Eqlcommand> is an INGRES sub-system command (e.g., EQL or 4GL.)
**              %E<name>
**
**      (Note:  The special charater `%' may be different on a particular
**      operating system.)
**
**      An <OScommand> is an operating system command.
**              <id>
**
**      <arg>s are arguments.  They can be either
**              %I   -  The pathname of the input file (minus the extension.)
**              %L   -  The pathname of the library file.
**              %N   -  The name of the input file (minus the extension.)
**              %D   -  The path of the directory for the input file.
**              %A   -  A list of INGRES sub-system parameters.
**              <id> -  Some string.
**      For example, the following template:
**
**      qc
**              cd %D; %Eeqc -A %N.qc; cc -O -c %N.c;rm %N.c
**              ar ru %L %I.o
**              rm %I.o
**
**      would compile a ".qc" file as an EQUEL/C file, while the following:
**
**      osl
**              %Eosl %A %I.osl -o%N.c
**              cc -O -c %N.c
**              ar ru %L %N.o
**              rm %N.c %N.o
**
**      would compile a ".osl" file as a 4GL/QUEL file.
**
**      This command may change directory to the source-code directory given
**      in the source file location, but will change back on return.
**
** Inputs:
**      lib     {LIBRARY}  The object-code module library.
**      file    {LOCATION *}  The location of the source file.
**      msg     {ER_MSGID}  An optional message to print before compiling.
**      exe     {UTARGS *}  Any special arguments to be passed to an INGRES
**                              sub-system.
**      errfile {LOCATION *}  An optional location to which to redirect
**                              stderr/stdout.
** Outputs:
**      compiled {bool *}  Whether the source file was compiled.
**
** Returns:
**      {STATUS}  OK, no errors.
**
** Side Effects:
**      If the library does not exist, it will be created.  Temporary files may
**      be created by the compilation process, but should be removed if no
**      errors occur.
**
** History:
**      03/89 (jhw) -- Written.
**      05/90 (jhw) -- Purge and set world permissions for 4GL generated ".c"
**              files on VAX/VMS.  JupBug #9950.
**	03/17/91 (emerson)
**		Added logic to print IL generated by 4GL compiler
**		if II_4GL_PRINT_IL defined.  Internal; facilitates testing.
**	26-feb-1992 (mgw) Bug #38790
**		Report OS level error messages from failed compiles if available
**	04-Feb-93 (fredb)
**		Changed length of LOdetail buffers to prevent overruns.
**	20-May-1993 (fredb)
**		IFDEF my prior changes to LO buffer sizes.  The relationship
**		between the defined sizes is different between MPE & UNIX.
**		Bug #51560
**      06-Sep-2010 (coomi01) b124361
**          Sep improvements
*/
STATUS
IIUTcompile ( library, file, msg, exe, errfile, compiled )
char            *library;
LOCATION        *file;
ER_MSGID        msg;
UTARGS          *exe;
LOCATION        *errfile;
bool            *compiled;
{
        STATUS          rval;
        i4              lang;
        LOCATION        obj_file;
        char            buf[MAX_LOC + 1];
        LOINFORMATION   flocinfo;
        i4              floiflags = LO_I_LAST;
#ifdef hp9_mpe
        char            basename[LO_FPREFIX_MAX+1];
        char            filename[LO_FILENAME_MAX+1];
        char            suffix[LO_FSUFFIX_MAX+1];
        char            objname[LO_FILENAME_MAX + 1];
#else
        char            basename[LO_NM_LEN+1];
        char            filename[LO_NM_LEN + 1 + LO_EXT_LEN + 1];
        char            suffix[(LO_EXT_LEN == 0 ? LO_NM_LEN : LO_EXT_LEN) + 1];
        char            objname[LO_NM_LEN + 1 + LO_EXT_LEN + 1];
#endif
 
        *compiled = FALSE;
 
        if ( file == NULL )
                return E_NoSrcFile;
 
# ifdef txCOMP
        if (TRgettrace(ABTCOMPSCR, 0))
        {
                char    *filename;
 
                LOtos(file, &filename);
                abtrcprint( ERx("COMPILE: Compiling the file %s\n"), filename,
                                (char *) NULL
                );
        }
# endif
 
        /* get parts of name */
        if ( (rval = LOdetail( file, buf, buf, basename, suffix, buf )) != OK )
                return rval;
 
        _VOID_ STprintf(filename, ERx("%s.%s"), basename, suffix);
 
        /* Now for the object file. */
 
        _VOID_ STprintf(objname, ERx("%s%s"), basename, ABOBJEXTENT);
        if ( (rval = IIABfdirFile(objname, buf, &obj_file)) != OK )
        {
                IIUGerr( E_AB004C_FileLength, UG_ERR_ERROR,
                                2, filename, objname
                );
                return rval;
        }
 
        if ( LOinfo(file, &floiflags, &flocinfo) != OK )
        { /* no source file, check for object */
                if ( LOexist(&obj_file) != OK )
                        return E_NoSrcFile;
                else
                        return E_ObjNoSrc;
        }
 
        if ( msg != ER_OK )
        {
                IIABdcmDispCompMsg(msg, TRUE, 1, filename);
        }
 
        if ( (rval = getLanguage(suffix, &lang)) != OK )
                return rval;    /* shouldn't happen */
 
        if ( lang == OLSQL )
                return FAIL;    /* shouldn't happen */
        else if ( lang != OLOSL )
        {
                rval = abexecompile(file, &obj_file, errfile);
		if (errfile != NULL)
			LOpurge(errfile, 1);
                *compiled = (OK == rval);
                return rval;
        }
        else
        { /* 4GL compilation */
                char            *dmlexe;
                i4              arg_cnt;
                char            cmdline[ABBUFSIZE];
                char            c_name[LO_NM_LEN + 2 /* ".c" */ + 1];
                char            c_buf[MAX_LOC + 1];
                LOCATION        c_file;
                char            il_buf[MAX_LOC + 1];
                LOCATION        il_file;
		CL_ERR_DESC	dummy;

                dmlexe = ( STcompare(suffix, ERx("osl")) != 0 )
                                ? ERx("oslsql") : ERx("osl");
 
#ifdef sgi_us5
                /* Multiple statements required because of SGI compiler bug */
                /* STlcopy was being called twice */
                STncpy(cmdline, exe->cmd_line, ABBUFSIZE-18);
                STcat( cmdline, ERx(",file=%L,output=%L") );
#else
                STcopy( ERx(",file=%L,output=%L"),
                        cmdline + STlcopy( exe->cmd_line, cmdline,
                                                sizeof(cmdline) - 1 )
                );
#endif
 
                arg_cnt = exe->arg_cnt;
                exe->args[arg_cnt++] = (PTR)file;
 
                if ( (rval = IIABfdirFile( STprintf(c_name, ERx("%s.c"),
                                                        basename),
                                        c_buf, &c_file)) != OK )
                        return rval;
                exe->args[arg_cnt++] = (PTR)&c_file;
 
                if ( ilListFile( basename, il_buf, &il_file ) == OK )
		{
			(VOID) STcat( cmdline, ERx(",illist=%L") );
                	exe->args[arg_cnt++] = (PTR)&il_file;
		}
 
#ifdef SEP_SYNC
		/* 
		** Must flush output buffer before fork/exec
		*/
		if (sepSyncGlobalVars.childSyncMode && (NULL != IIFTcommfile))
		{
			TCflush(IIFTcommfile);
		}
#endif
		rval = UTexe(UT_WAIT|UT_STRICT, errfile, NULL, 
			     NULL, dmlexe, &dummy, cmdline, arg_cnt, 
                                exe->args[0], exe->args[1],
				exe->args[2], exe->args[3], 
				exe->args[4], exe->args[5],
                                exe->args[6], exe->args[7],
				exe->args[8], exe->args[9]
                );

		if (rval != OK)
		{	/*
			** Bug 38790 - print OS error messages if available
			**
			** Use lang 1 which is guaranteed to be ok. The system
			** will return OS errors in a system dependent way
			** regardless of our language.
			*/
			i4	lang = 1;
			i4	msg_len = ER_MAX_LEN;
			char	msg_buf[ER_MAX_LEN];
			CL_ERR_DESC	sys_err;

			msg_buf[0] = EOS;
			if (ERlookup(0, &dummy, 0, NULL, msg_buf, msg_len,
				     lang, &msg_len, &sys_err, 0, NULL) == OK)
			{
				if (msg_buf[0] != EOS)
					IIUGerr(E_AB0155_OSCompErr,
					        UG_ERR_ERROR, 1, msg_buf);
			}
			rval = FAIL;
		} 
                else
                { /* generated a .c file, now compile it. */
                        LOCATION        *serr = NULL;
                        LOCATION        stmp;
                        char            sbuf[MAX_LOC+1];
 
                        /* VMS:  Purge and set deletable. */
                        LOpurge(&c_file, 1);
                        PEworld("+r+w", &c_file); /* so others can recompile */
 
                        if ( errfile != NULL
                                && NMloc(TEMP, PATH, (char *)NULL, &stmp) == OK
                                && LOuniq(ERx("cer"), ERx("out"), &stmp) == OK )                        {
                                LOcopy(&stmp, sbuf, &stmp);
                                serr = &stmp;
                        }
 
                        rval = abexecompile(&c_file, &obj_file, serr);
 
                        if ( serr != NULL )
                        { /* Append the output from this compilation */
                                _VOID_ IIUGafAppendFile(errfile, serr,
                                                        "\n----------\n"
                                );
                                _VOID_ LOdelete(serr);
                        }
                }
        }
        if ( errfile != NULL )
                PEworld(ERx("+r+w"), errfile);
 
        if ( rval == OK )
                *compiled = TRUE;
 
        return rval;
}

/*{
** Name:        IIUTdbCompile() -       Compile A Source File into the Database.**
** Description:
**      Compile a file containing source code into a database object.  This
**      is done only if it is out-of-date with respect to the object (as input
**      from the caller) or if it is to be compiled regardless.  The file is
**      compiled according to its extension.
**
**      The rules that specify how a file is to be compiled (including which
**      compiler(s) to use) are specified in the "utcom.def" file in the
**      II_CONFIG directory.  This file has templates that specify how to
**      compile different extensions.  The rules are structured as follows:
**
**      <extension>%            -- characters for extension
**              <command>       -- indented by a tab
**              <command>
**                ...
**              <command>
**
**      A command is:
**
**              <Eqlcommand> <arg> <arg> ... <arg>
**              <OScommand>  <arg> <arg> ... <arg>
**
**      An <Eqlcommand> is an INGRES sub-system command.
**              %E<name>
**
**      (Note:  The special charater `%' may be different on a particular
**      operating system.)
**
**      An <OScommand> is an operating system command.
**              <id>
**
**      <arg>s are arguments.  They can be either
**              %I   -  The pathname of the input file (minus the extension.)
**              %L   -  The pathname of the library file.
**              %N   -  The name of the input file (minus the extension.)
**              %D   -  The path of the directory for the input file.
**              %A   -  A list of INGRES sub-system parameters.
**              <id> -  Some string.
**
**      For example, the following template:
**
**      osq
**              %Eoslsql %A %I.osl
**
**      would compile a ".osq" file as a 4GL/SQL file into IL code.
**
**      This command may change directory to the source-code directory
**      given in the source file location, but will change back on return.
**
** Inputs:
**      file    {LOCATION *}  The location of the source file.
**      msg     {ER_MSGID}  An optional message to print before compiling.
**      exe     {UTARGS *}  Any special arguments to be passed to an INGRES
**                              sub-system.
**      errfile {LOCATION *}  An optional location for redirecting stout/stderr
**
** Outputs:
**      compiled {bool *}  Whether the source file was compiled.
**
** Returns:
**      {STATUS}  OK, no errors.
**
** Side Effects:
**      Temporary files may be created by the compilation process, but should
**      be removed if no errors occur.
**
** History:
**      03/89 (jhw) -- Written.
**	03/17/91 (emerson)
**		Added logic to print IL generated by 4GL compiler
**		if II_4GL_PRINT_IL defined.  Internal; facilitates testing.
**	26-feb-1992 (mgw) Bug #38790
**		Report OS level error messages from failed compiles if available
**	04-Feb-93 (fredb)
**		Changed length of LOdetail buffers to prevent overruns.
**	20-May-1993 (fredb)
**		IFDEF my prior changes to LO buffer sizes.  The relationship
**		between the defined sizes is different between MPE & UNIX.
**		Bug #51560
**  15-Feb-1995 (nick) (x-inst angusm)
**      Variable basename was overflowing as it was being declared as
**      LO_FPREFIX_MAX rather than LO_NM_LEN - bug 56774
**
**	06-Nov-2002 (bonro01)
**		Re-write statement on separate lines to eliminate
**		compiler bug in SGI.
*/
STATUS
IIUTdbCompile ( file, msg, exe, errfile, compiled )
LOCATION        *file;
ER_MSGID        msg;
UTARGS          *exe;
LOCATION        *errfile;
bool            *compiled;
{
        STATUS          rval;
        i4              lang;
        char            buf[MAX_LOC+1];
        LOINFORMATION   locinfo;
        i4              loiflags = (LO_I_LAST);
#ifdef hp9_mpe
        char            basename[LO_FPREFIX_MAX+1];
        char            filename[LO_FILENAME_MAX+1];
        char            suffix[LO_FSUFFIX_MAX+1];
#else
        char            basename[LO_NM_LEN+1];
        char            filename[LO_NM_LEN + 1 + LO_EXT_LEN + 1];
        char            suffix[(LO_EXT_LEN == 0 ? LO_NM_LEN : LO_EXT_LEN) + 1];
#endif
 
        *compiled = FALSE;
 
        if ( file == NULL || LOinfo(file, &loiflags, &locinfo) != OK )
                return E_NoSrcFile;
 
# ifdef txCOMP
        if (TRgettrace(ABTCOMPSCR, 0))
        {
                char    *filename;
 
                LOtos(file, &filename);
                abtrcprint( ERx("COMPILE: Compiling the file %s\n"), filename,
                                (char *) NULL
                );
        }
# endif
 
        /* Get the parts of the file name */
 
        if ( (rval = LOdetail( file, buf, buf, basename, suffix, buf )) != OK )
                return rval;
 
        _VOID_ STprintf(filename, ERx("%s.%s"), basename, suffix);
 
        if ( msg != ER_OK )
                IIABdcmDispCompMsg(msg, TRUE, 1, filename);
        if ( (rval = getLanguage(suffix, &lang)) != OK )
                return rval;
 
        if ( lang == OLOSL )
        {
                char            *dmlexe;
                i4              arg_cnt;
                char            cmdline[ABBUFSIZE];
                char            il_buf[MAX_LOC + 1];
                LOCATION        il_file;
		CL_ERR_DESC	dummy;
 
                dmlexe = ( !STequal(suffix, ERx("osl")) )
                                ? ERx("oslsql") : ERx("osl");
 
#ifdef sgi_us5
                /* Multiple statements required because of SGI compiler bug */
                /* STlcopy was being called twice */
                STncpy(cmdline, exe->cmd_line, ABBUFSIZE-9);
                STcat( cmdline, ERx(",file=%L") );
#else
                STcopy( ERx(",file=%L"),
                        cmdline + STlcopy(exe->cmd_line, cmdline, ABBUFSIZE)
                );
#endif
 
                arg_cnt = exe->arg_cnt;
                exe->args[arg_cnt++] = (PTR)file;
 
                if ( ilListFile( basename, il_buf, &il_file ) == OK )
		{
			(VOID) STcat( cmdline, ERx(",illist=%L") );
                	exe->args[arg_cnt++] = (PTR)&il_file;
		}
 
		rval = UTexe(UT_WAIT|UT_STRICT, errfile, NULL, 
			     NULL, dmlexe, &dummy, cmdline, arg_cnt, 
                                exe->args[0], exe->args[1],
				exe->args[2], exe->args[3], 
				exe->args[4], exe->args[5],
                                exe->args[6], exe->args[7],
				exe->args[8]
                );
		if (rval != OK)
		{	/*
			** Bug 38790 - print OS error messages if available
			**
			** Use lang 1 which is guaranteed to be ok. The system
			** will return OS errors in a system dependent way
			** regardless of our language.
			*/
			i4	lang = 1;
			char	msg_buf[ER_MAX_LEN];
			i4	msg_len = ER_MAX_LEN;
			CL_ERR_DESC	sys_err;

			msg_buf[0] = EOS;
			if (ERlookup(0, &dummy, 0, NULL, msg_buf, msg_len,
				     lang, &msg_len, &sys_err, 0, NULL) == OK)
			{
				if (msg_buf[0] != EOS)
					IIUGerr(E_AB0155_OSCompErr,
					        UG_ERR_ERROR, 1, msg_buf);
			}
			rval = FAIL;
		}
        }
       else if ( lang == OLSQL )
                rval = dmlCompile(basename, file);
        else
                rval =  FAIL;
 
        if ( rval == OK )
                *compiled = TRUE;
 
        return rval;
}

/*
** Name:        dmlCompile() -  Compile a Database Procedure.
*/
static STATUS
dmlCompile ( name, file )
char            *name;
LOCATION        *file;
{
        FILE            *fp;
        char            buf[BUFSIZ];

        if ( SIopen(file, ERx("r"), &fp) != OK )
                return FAIL;    /* shouldn't happen */

        /* Destroy the procedure */

        IIsqInit( (char *)NULL );
        IILQpriProcInit( IIPROC_DROP, name );
        IIwritio(FALSE, (i2 *)NULL, TRUE, DB_CHR_TYPE, 0, "drop procedure ");
        IIwritio(TRUE, (i2 *)NULL, TRUE, DB_CHR_TYPE, 0, name);
        IIsyncup( (char*)NULL, 0 );
 
        /* Compile the procedure */
 
        IIsqInit( (char *)NULL );
        IILQpriProcInit( IIPROC_CREATE, name );
 
        while ( SIgetrec(buf, sizeof(buf)-1, fp) == OK )
        {
                IIwritio(FALSE, (i2 *)NULL, TRUE, DB_CHR_TYPE, 0, buf);
                IIputctrl( II_cNEWLINE );
        }
 
 
        IIsyncup( (char*)NULL, 0 );
 
        return SIclose( fp );
}
