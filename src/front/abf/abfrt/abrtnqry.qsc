/*
**	Copyright (c) 2004 Actian Corporation
**	All rights reserved.
*/

#include	<compat.h>
#include	<cm.h>
#include	<me.h>
#define _alloc(size)	MEreqmem(0, (size), FALSE, (STATUS *)NULL)
#include	<ol.h>
#include	<st.h>
#include	<er.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
#define NOT_YET
#include	<fe.h>
#include	<adf.h>
#include	<afe.h>
#include	<abfcg.h>
#include	<abfcnsts.h>
#include	<abftrace.h>
#include	<fdesc.h>
#include	<abfrts.h>
#include	"rts.h"

/**
** Name:	abrtnqry.c -	ABF Run-time System 6.0 Object
**						Initialize/Close Module.
** Description:
**	The part of the ABF runtime system that deals with query generation
**	for v6.0 and above.  This file uses the new definitions of the QRY
**	and QDESC structures in "abfosl.h" and "qg.h" respectively.
**
**	The file "abrtqry.qc" handles query generation for versions up
**	through 5.0, using the structures QRYV0 and QDV0 (formerly known
**	as QRY and QDESC).
**
**	IIARfinFrmInit()	initialize OSL frame.  (6.0)
**	IIARpinProcInit()	initialize OSL procedure.  (6.0)
**	IIARfclFrmClose()	close OSL frame.  (6.0)
**	IIARpclProcClose()	close OSL procedure.  (6.0)
**	abrtsgen()		ABF run-time system query generation.
**	IIARgn1RtsgenV1()	ABF run-time system 6.0 query generation.
**	iiarPassArg()		pass arguments to frame or procedure.
**	iiarAttachQry()		attach query passed as parameter.
**	iiarQryExpand()		expand query passed as parameter.
**	iiarTblfld()		verify table field in FDESC.
**	iiarDbvType()		return DB datavalue type for OL type.
**	IIARqryNext()		check for passed query.
**	abrtsnext()		pre-6.1 entry point.
**	IIARsctSetClearTarget()	Set "CLEAR_ON_NO_ROWS" option.
**	IIARictInquireClearTarget()	Inquire upon "CLEAR_ON_NO_ROWS" option.
**
** History:
**	Revision 6.0  87/06  
**	Added backwards compatibility for versions 3.0-5.0.  (87/06  wong)
**	11-may-1987 (agh) First written.
**
**	Revision 6.3  90/01  wong
**	Modified to convert version 2 QDESC to version 2 (which has longs for
**	query ID instead of i1s.)  JupBug #7899.
**
**	Revision 6.3/03/00
**	11/14/90 (emerson)
**		Fixes for bugs 34438 and 34440 in function IIARgn1RtsgenV1.
**	11/27/90 (emerson)
**		Part of fix for bug 34663 in functions 
**		IIARfinFrmInit and IIARpinProcInit.
**
**	Revision 6.3/03/01
**	02/20/91 (emerson)
**              Made various changes to address bug 35798.
**
**              Bug 35798 resulted from the fact that in code
**		generated by the release 6.0 through 6.3/02 OSL compiler,
**		the qg_from, qg_where, and qg_order fields in the QDESC
**		structure were not being filled in.  This didn't matter
**		as long as QG didn't look at these fields.
**		In 6.3/03/00, the OSL compiler started filling in these
**		fields, and QG started looking at them.
**		In effect, a new version of the QDESC structure was created.
**		(No fields were added or changed in size, but the usage
**		of 3 fields changed).  However, qg_version in the QDESC
**		was left at 2, and no logic was added to abfrt to handle
**		QDESCs created by older compilers.
**
**              My fixes for bug 35798 are in $HDR2/qg.h (to bump QG_VERSION)
**		and in this source file, in functions IIARgn1RtsgenV1,
**		_qryCvtV3, and iiarQryExpand.  See the histories
**		of those functions for details.
**
**	Revision 6.4
**	03/11/91 (emerson)
**		Integrated another set of DESKTOP porting changes.
**	03/23/91 (emerson)
**		Changed references to qr_argv in the QRY structure;
**		Its declaration in abfosl.h has been changed to reflect
**		its true type (QRY_ARGV *).
**	06/19/91 (emerson)
**		Fix in IIARgn1RtsgenV1 for bug 38120 (and 35798).
**	12-aug-91 (davel)
**		Added fix for bug 33674 and comments explaining the relationship
**		of iiarQryExpand() and iiarAttachQry() with respect to
**		the writability of the QRY attribute qr_putparam.
**
**	Revision 6.4/02
**	11/07/91 (emerson)
**		Changes to IIARfinFrmInit and IIARpinProcInit
**		for bugs 39581, 41013, and 41014.
**	19-feb-92 (leighb) DeskTop Porting Change:
**		adh_evcvtdb() has only 3 args, bogus 4th one deleted.
**
**	Revision 6.4/03
**	09/20/92 (emerson)
**		Changes to IIARgn1RtsgenV1 for bug 39582.
**
**	Revision 6.4/05
**      06/09/93 (donc)
**		Changes to IIARgn1RtsgenV1 for bug 52463.
**
**	Revision 6.5
**
**	10-feb-93 (davel)
**		Added set/inquire functions for "CLEAR_ON_NO_ROWS" option,
**		for the SET_4GL and INQUIRE_4GL statements.
**
**	12-jun-93 (rudyw)
**		Fix for 51153. See history of routine IIARgn1RtsgenV1.
**	13-sep-93 (donc) bug 51127
**		Modified IIARgn1RtsgenV1 to return FALSE is 0 rows are
**		retrieved and CLEAR_ON_NO_ROWS is set to not clear. 
**		Formerly, the routine passed back a return status in this
**		situation of boolean true.  Callers of this routine
**		then went ahead and cleared the query target.
**	24-Aug-2009 (kschendel) 121804
**	    Update some of the function declarations to fix gcc 4.3 problems.
*/

FUNC_EXTERN bool	IIQG_inquery(QDESC *);

GLOBALREF ABRTSSTK      *IIarRtsStack;

FDESCV2	*iiarGetFdesc();

bool	iiarTblfld();

static bool clear_on_no_rows = TRUE;
static QDESC	*_qryCvtV3();

/*}
** Name:    QDESC_V1 -		Query Generator Query Description, Version 1.
**
** Description:
**	See QDESC description in <qg.h>.  This is differs in that the old
**	query ID (now 'qg_fill[]') is used instead of the new query ID.  The
**	new query ID is larger ('qg_num[]' is u_i4 instead of u_i1.)
*/
typedef struct {
    char	*qg_new;		/* NULL if not v0 */
    char	*qg_name;		/* name for cursor or repeat */
    u_i1	qg_num[2];		/* ID for cursor or repeat */
    u_i1	qg_version;		/* version number */
    u_i1	qg_dml;			/* query DBMS language:
					**	    DB_QUEL or DB_SQL
					*/
    u_i1	qg_mode;		/* query mode */

    QRY_ARGV    (*qg_argv)[];	/* query retrieved value descriptors */

    QRY_SPEC    (*qg_tlist)[];	/* query or 6.0 QBF target list */
    QRY_SPEC    (*qg_from)[];	/* 6.0 QBF SQL query from list */
    QRY_SPEC    (*qg_where)[];	/* 6.0 QBF query where clause */
    QRY_SPEC    (*qg_order)[];	/* 6.0 QBF order clause */

    QDESC	*qg_child;	/* detail query */
    struct qgint	*qg_internal;

    i4		    qg_bcnt;	/* base count */
    DB_DATA_VALUE   (*qg_base[QG_BCNT])[];	/* base reference DB_DATA_VALUE
						**	indexing arrays
						*/
} QDESC_V1;

/*{
** Name:	IIARfinFrmInit() -	Initialize an OSL Frame.
**
** Description:
**	Initializes an OSL frame (version 6.0 or higher).
**
** Inputs
**	name		Name of the form used in the OSL frame.
**	nrtsprm		A parameter structure built by the caller.
**	fdesc		An fdesc built by the caller.
**	dbdvarr		The array of DB_DATA_VALUEs for the frame.
**
** History:
**	29-may-1987 (agh)
**		Adapted for v6.0 from abrtsfinit().
**	11/27/90 (emerson)
**		Call routine to fix up objects' tags (bug 34663).
**	11/07/91 (emerson)
**		Part of fix for bugs 39581, 41013, and 41014:
**		Move the call to FEbegintag to tagPush in abrtcall.qsc
**		(so objects will be allocated on this frame's tag
**		instead of the parent frame's tag).
**		Remove the no-longer-needed call to routine
**		to fix up objects' tags.
*/
STATUS
IIARfinFrmInit(name, nrtsprm, fdesc, dbdvarr)
char		*name;
ABRTSPRM	*nrtsprm;
FDESC		*fdesc;
DB_DATA_VALUE	*dbdvarr;
{
	return iiarIObjInit(name, nrtsprm, fdesc, dbdvarr, ABOFRM);
}

/*{
** Name:	IIARpinProcInit() -	Initialize an OSL Procedure.
**
** Description:
**	Initializes an OSL procedure (version 6.0 or higher).
**
** Input:
**	name		Name of the procedure.
**	nrtsprm		A parameter structure built by the caller.
**	fdesc		An fdesc built by the caller.
**	dbdvarr		The array of DB_DATA_VALUEs for the frame.
**
** History:
**	29-may-1987 (agh)
**		Adapted for v6.0 from abrtspinit().
**	11/27/90 (emerson)
**		Call routine to fix up objects' tags (bug 34663).
**	11/07/91 (emerson)
**		Part of fix for bugs 39581, 41013, and 41014:
**		Move the call to FEbegintag to tagPush in abrtcall.qsc
**		(so objects will be allocated on this procedure's tag
**		instead of the parent frame's tag).
**		Remove the no-longer-needed call to routine
**		to fix up objects' tags.
*/
STATUS
IIARpinProcInit(name, nrtsprm, fdesc, dbdvarr)
char		*name;
ABRTSPRM	*nrtsprm;
FDESC		*fdesc;
DB_DATA_VALUE	*dbdvarr;
{
	return iiarIObjInit(name, nrtsprm, fdesc, dbdvarr, ABOPROC);
}

/*{
** Name:	IIARfclFrmClose() -	Close an OSL Frame.
**
** Description:
**	Closes an OSL frame (version 6.0 or higher).
**
** Inputs:
**	nrtsprm		A parameter structure built by the caller of this frame.
**	dbdvarr		The array of DB_DATA_VALUEs for this frame.
**
** History:
**	1-jun-1987 (agh)
**		Adapted for v6.0 from abrtsfclose().
*/
STATUS
IIARfclFrmClose(nrtsprm, dbdvarr)
ABRTSPRM	*nrtsprm;
DB_DATA_VALUE	*dbdvarr;
{
	iiarCObjClose(nrtsprm, dbdvarr, ABOFRM);
}

/*{
** Name:	IIARpclProcClose() -	Close an OSL Procedure.
**
** Description:
**	Closes an OSL procedure (version 6.0 or higher).
**
** Inputs:
**	nrtsprm		A parameter structure built by the caller of this
**			procedure.
**	dbdvarr		The array of DB_DATA_VALUEs for this procedure.
**
** History:
**	1-jun-1987 (agh)
**		Adapted for v6.0 from abrtspclose().
*/
STATUS
IIARpclProcClose(nrtsprm, dbdvarr)
ABRTSPRM	*nrtsprm;
DB_DATA_VALUE	*dbdvarr;
{
	iiarCObjClose(nrtsprm, dbdvarr, ABOPROC);
}

/*{
** Name:	abrtsgen() -	Interface for Query Generation.
**					(version < 6.0)
** Description:
**	This is ABF's interface to QG, the query generation module.
**	We don't call QG directly because the runtime code would do a
**	substantial amount of checking.
**
**	In 6.0, abrtsgen() has become a cover for the old and new
**	query generate routines, which it calls based on the type
**	of its first argument.  If this argument is an old-style
**	(up to 5.0) QRY (now called a QRYV0), this cover routine calls
**	'iiarRtsgenV0()' (the 5.0 abrtsgen).  If the argument is a new
**	QRY, then 'IIARgn1RtsgenV1()' is called.
**
** History:
**	??  First written.
**	22-may-1987 (agh)
**		Adapted for v6.0: now a cover for other routines.
*/
bool
abrtsgen (qry, mode)
QRY	*qry;
i4	mode;
{
	bool	IIARgn1RtsgenV1();

	return (qry->qr_zero == 0) ? IIARgn1RtsgenV1(qry, mode)
				   : iiarRtsgenV0((QRYV0 *)qry, mode);
}

/*{
** Name:	IIARgn1RtsgenV1() -  ABF Run-Time System 6.0 Query Generation.
**
** Description:
**	This routine is the interface to the QG module for version 6.0 and
**	later style queries.  It calls QG to get the data for a single row
**	of the query (or row plus detail rows for a master/detail query.)
**	The routine then loads any visible data onto the form, either the
**	fields or the rows of a table field.
**
**	For ABF run-time frame/structures prior to version 6.0, this routine
**	must blank-trim and EOS-terminate any hidden fields of character type.
**
**	If the query mode is negative, then this is being called for an attached
**	query and the form mode must be set to be different than QUERY before
**	loading any values.
**
** Input:
**	qry	{QRY *}  Version 6.0 ABF run-time query structure.
**	mode	{nat}  QG query mode.  If negative, set form mode before
**				loading values.
** Called by:
**	abrtsgen()
**
** Side Effects:
**	Loads data into the fields or table field rows of the form,
**	or into an array or record (the latter only arises
**	in frames or procedures compiled before release 6.4/02).
**	May also convert the query descriptor 'qry->qr_desc' to V2.
**	The QR_ROWS_FOUND bit in qry->qr_version is set to indicate
**	whether this call to IIARgn1RtsgenV1 found at least one row.
**	The qr_version in any child QRY structures is left unchanged.
**
** Returns:
**	{bool}	TRUE if either: (1) another tuple was successfully generated,
**		or (2) the query succeeded but returned 0 rows, and
**		the QR_0_ROWS_OK bit in qry->qr_version was set by the caller.
**		Otherwise, FALSE is returned.  FALSE is always returned
**		if mode is QI_BREAK (or -QI_BREAK).
**		
** History:
**	22-may-1987 (agh)
**		Adapted for v6.0 from old abrtsgen().
**	06/15/87 (jhw) -- Added backwards compatibility support for
**		versions < 6.0.
**	01/02/90 (jhw) -- Convert V1 QDESC to V2.
**	08/90 (jhw) -- Added support for loading arrays.  #32963.
**	10/90 (jhw) -- Added support for setting form mode.  #31929.
**	11/14/90 (emerson)
**		Make sure array rows aren't treated as full-blown arrays
**		(bug 34438).
**	11/14/90 (emerson)
**		Clear records and array rows before trying to select into them
**		(bug 34440).
**	02/20/91 (emerson)
**		Fixes for bug 35798: Call _qryCvtV3 (instead of the old
**		_qryCvtV2), to handle V2 QDESCs as well as V1 QDESCs
**		(convert both to V3).
**
**		Note that _qryCvtV3 needs to be passed the FDESC
**		of the frame or procedure which built the QDESC;
**		for IIARgn1RtsgenV1, this is generally the current frame
**		or procedure.
**
**		A seeming exception is the call to abrtsgen in iiarIObjInit
**		(abrtsgen in turn calls IIARgn1RtsgenV1):
**		a new entry for the current (called) frame has already
**		been pushed onto the run-time stack, but it was the caller
**		who built the QDESC.  However, iiarIObjInit calls iiarQryExpand
**		before calling abrtsgen; iiarQryExpand (in this source file) 
**		will make the appropriate call to _qryCvtV3.
**
**		Another seeming exception are calls to abrtsgen to retrieve
**		the next row of a passed-in query; again, it was the caller
**		who built the QDESC.  But in this case, the QDESC has
**		already been converted to V3 format by the call to abrtsgen
**		in iiarIObjInit, as discussed in the previous paragraph.
**
**		A real exception is the call to IIARgn1RtsgenV1 in abrtlkup.qsc
**		(called indirectly from IIARlookup).  The problem here is that
**		IIARlookup is a system frame (currently the only one), and
**		doesn't seem to have an FDESC of its own.  (In any event,
**		the runtime stack entry for IIARlookup has a null FDESC
**		pointer).  What's more, IIARlookup didn't build the QDESC
**		either; its caller did.  We sidestep this problem by searching
**		by searching the runtime stack until we find a nonnull FDESC
**		pointer.
**	06/19/91 (emerson)
**		Fix for bug 38120 (and for bug 35798 in the case where
**		the SELECT that was compiled under an old release is in
**		a procedure rather than a frame).
**	09/20/92 (emerson)
**		Added logic to check the new QR_0_ROWS_OK bit and to set
**		the new QR_ROWS_FOUND bit (for bug 39582).
**		Also changed comments to indicate that the explicit
**		"select into record" support is needed only for frames
**		compiled before 6.4/02.  (Subsequent releases generate IL
**		to select into temporaries and then copy them into the record
**		(after clearing it) if the select returns a row).
**	11-feb-93 (davel)
**		Clear the left-hand-side target of the select conditionally
**		based on the current setting of "clear_on_no_rows" behavior,
**		when zero rows are returned in the the query.  Note two 
**		semantic notes:
**		1. Normally when a tablefield is cleared, the mode of the
**		   tablefield is switched to "update" if it was in "query" mode.
**		   This will mode switching will also be bypassed if we do
**		   not clear the tablefield on zero rows.
**		2. Currently row-typed objects (records, elements of arrays,
**		   and elements of tablefields) are already cleared before
**		   the query is generated.  More work is required to allow
**		   these LHS's to react to the "clear_on_no_rows" setting.
**	09-jun-93 (donc)  Bug 52463
**		In cases where "clear_no_rows" was set "on" and no rows
**		were returned, the tablefield's mode was being set to "update"
**		(which subsequently causes the FRS routine IITBtclr to set
**		the tablefield header flag bit for READONLY on.) This, in cases
**		where queries were attached to submenus, caused the submenu loop
**		to be bypassed AND the form/tablefield mode not being restored
**		to what it was prior to running the query.  In essence, the
**		tablefield remained in "BROWSE" mode disallowing any further
**		querying in the 4GL frame.  We document that upon leaving a
**		submenu the form/tablfeild mode will be restored. Changes were
**		made NOT to change the mode in the very first place iff the 
**              the aforementioned situation is encountered. 
**	12-jun-93 (rudyw)
**		Fix for 51153. Add check at the end of routine IIARgn1RtsgenV1
**		so that memory is freed after the query has finished.
*/
bool
IIARgn1RtsgenV1 ( qry, mode )
register QRY	*qry;
i4		mode;
{
    register DB_DATA_VALUE	**base;
    QDESC			*qdsc = qry->qr_qdesc;
    char			*form;
    i4				output;
    i4				err;
    bool			setmode;
    DB_DATA_VALUE		*adbv = (DB_DATA_VALUE *)NULL;
    DB_DATA_VALUE		*rdbv = (DB_DATA_VALUE *)NULL;

    qry->qr_version &= ~QR_ROWS_FOUND;	/* no row found yet */

    /* Check for Version 1 or 2 Query Descriptor */
    if ( qdsc->qg_version < QG_VERSION )
    { /* Convert version 1 or 2 to version 3 */
        ABRTSSTK		*rtsstk;
        FDESC			*fdesc;

	for (rtsstk = IIarRtsStack; ; rtsstk = rtsstk->abrfsnext)
	{
		fdesc = rtsstk->abrfsfdesc;
		if (fdesc != NULL)
		{
			break;
		}
	}
	qdsc = _qryCvtV3(qdsc, fdesc);
	qry->qr_qdesc = qdsc;
	if ( qdsc == NULL )
	{
		abproerr(ERx("IIARgn1RtsgenV1"), OUTOFMEM, (char *) NULL);
		return FALSE;
	}
	if ( qry->qr_child != NULL )
	{
		qry->qr_child->qr_qdesc = qdsc->qg_child;
	}

	/*
	** If query descriptor was built by a procedure compiled under
	** release 6.0 thru 6.3/02, qr_form will be NULL, even though
	** the object being selected into is the "form" (actually the
	** procedure name).  For 6.3/03 and above, we need to change this
	** to some non-null value, so that the logic below won't assume
	** that we're selecting into a record or array.
	*/
	if ( ( fdesc->fdsc_version & FDSC_60_6302 ) && qry->qr_form == NULL )
	{
		qry->qr_form = ERx("");
	}
    }

    /* Check if form mode is to be set */
    if ( mode > 0 )
    {
	setmode = FALSE;
    }
    else
    {
	setmode = TRUE;
	mode = -mode;	/* query mode */
    }

    /*
    ** Get the form name associated with the select query.
    ** This was set to NULL by interp/ilquery.qsc iff
    ** the 3rd operand of the IL_QRY operation was set
    ** to refer to the l.h.s. of the query assignment
    ** by osqrygen in osl/osquery.c.  That was done iff
    ** the l.h.s. of the query assignment was an array
    ** [or possibly a record, if compiled prior to 6.4/02;
    ** a record includes the case of an array element].
    ** In the latter case, we must clear the record *now*,
    ** so that (1) it will be clear if the select fails, and
    ** (2) attributes not in the target list will be clear
    ** (whether or not the select fails).  We skip the clear
    ** if we're being called to break out of a query (we don't want to wipe out
    ** the record we retrieved on the previous call to this routine).
    **
    */
    form = qry->qr_form;
    if (form == NULL)
    {
       	/* We have an array or a record.  Decide which. */
       	adbv = (DB_DATA_VALUE *)qry->qr_table;
       	if ( !iiarIarIsArray( adbv ) )
       	{
	    rdbv = adbv;
	    adbv = NULL;
	    if ( mode != QI_BREAK )
	    {
		/* 
		** It's too early to do this -- the SELECT might fail.
		** But we have no other good place for it.  Unlike the
		** array case, QG fills in the data, so it's too late 
		** to do the clear after the query takes place.
		*/
		_VOID_ IIARdocDotClear( rdbv );
	    }
	}
    }

    /*
    ** Call separate QG routine to find status of current query in order
    ** to handle retrieve statements within submenus.
    */
    if ( mode == QI_NMASTER && !IIQG_inquery(qdsc) )
    { /* Attempt to get next tuple when in fact none were retrieved. */
	return FALSE;
    }

    /* Perform the query(s) */
    err = IIQG_generate(qdsc, mode, &output);

    /* Exit immediately if query failed or mode is QI_BREAK */
    if (err != OK || mode == QI_BREAK)
    {
	IIQG_free(qdsc);	/* Free memory allocated in the QDESC. */
	return FALSE;
    }

    /* If the query succeeds, there are some things we want to do before
    ** checking whether any rows were returned.
    **
    ** Clear any tablefield involved in this query or a child query.  Also,
    ** if the table field is in query mode, we put it into update mode.  We 
    ** do this:
    ** 	1. After the call to IIQG_generate, so any qualifications from the
    **     tablefield have already been built, and it's OK to clear the 
    **	   tablefield and put it into update mode.
    ** 	2. Regardles of whether any rows were retrieved (The tablefield remains
    **     in query mode).
    **  3. Not if the Select fails.
    **
    ** Clear the record or array we selected into.  Note: we may skip this step
    ** if the "clear_on_no_rows" behavior is set off and no rows were returned
    ** from the query.
    */

    if (output == QO_QDONE && !clear_on_no_rows)
    {
	;	/* don't clear the left-handside */
    }
    else if (form != NULL)
    {
	/* SELECT into a form.  Look for tablefields */
	QRY			*loopqry;

	for (loopqry = qry; loopqry != NULL; loopqry = loopqry->qr_child)
	{

	    if ( *loopqry->qr_table != EOS )
	    {  
##	    	char		curform[FE_MAXNAME+1];

##	    	inquire_frs form ( curform = name );
		if ( STequal(form, curform) )
		{
##		    char	*tblfld = loopqry->qr_table;
##		    char	tfmode[20];

##		    clear field tblfld;
##		    inquire_frs field curform (tfmode = mode(tblfld))
                    /*
		    ** If no rows retrieved, do not change the tablefield mode
		    ** because if this query is attached to a submenu, the
		    ** tablefield will be left in read mode disallowing any
		    ** further querying
		    */ 
                    if ( output != QO_QDONE ) {
		        if ( CMcmpnocase(tfmode, ERx("q")) == 0 )
##		            set_frs field curform (mode(tblfld) = ERx("update"))
##		        inquire_frs field curform (tfmode = mode(tblfld))
                    }
		}
	    }
	}
    }
    else
    {
	/* No form. Look for arrays and records */
	if (rdbv != NULL)
	{
	    /* 
	    ** It's too late to clear the record; its attrbiutes have 
	    ** already been set.
	    */
	}
	if (adbv != NULL)
	{
	    iiarArClearArray(adbv);
	}
    }

    /* See if any rows were found */
    if (output == QO_QDONE)
    {
	IIQG_free(qdsc);	/* Free memory allocated in the QDESC. */
        if (clear_on_no_rows)    
	   return ((qry->qr_version & QR_0_ROWS_OK) != 0);
	else
	   return FALSE; 
    }

    qry->qr_version |= QR_ROWS_FOUND;	/* found row */

    /* Check for attached query */
    if ( setmode )
    { /* set form mode to be different than QUERY mode . . . */
##	char	fmode[2];

##	INQUIRE_FRS FORM ( fmode = MODE );
	if ( fmode[0] == 'Q' )
##		SET_FRS FORM ( MODE = UPDATE );
    }

    /*
    ** qg_base is the array of bases for the DB_DATA_VALUE array(s).
    */
    base = (DB_DATA_VALUE **)qdsc->qg_base;	/* cast for IBM */

    /*
    ** If the query has a child then we need to do the putform
    ** for it.  If the query is into a table field then we fill it up.
    */
    while (qry != NULL)
    {
	register QRY_ARGV	*argv;
	register char		*putlist;

	if ( form != NULL && *qry->qr_table != EOS )
	{ /* load table field */
	    while (output != QO_DDONE && output != QO_QDONE && err == OK)
	    {
/*##		loadtable qry->qr_form qry->qr_table ( ... ); */
		if (IItbact(form, qry->qr_table, TRUE) != 0)
		{
		    /* Note:  No table field columns are ever `hidden' from
		    ** the Form System.  (That is, all columns must be loaded
		    ** into the table field using 'IItcoputio()' including
		    ** those that are not displayed on the form.)
		    */
		    for (argv = qry->qr_argv;
				argv != NULL && argv->qv_name != NULL; ++argv)
		    {
			IItcoputio(argv->qv_name, (i2 *)NULL, TRUE,
			    DB_DBV_TYPE, 0,
			    &((base[argv->qv_base])[argv->qv_index])
			);
		    }
		    IITBceColEnd();
		}
		err = IIQG_generate(qdsc, QI_GET, &output);
	    }
	}
	else if ( adbv != (DB_DATA_VALUE *)NULL )
	{ /* load array */
	    register i4		i = 0;
	    DB_DATA_VALUE		element;

	    /* setup 'element' to be an array element. */
	    element.db_datatype = DB_DMY_TYPE;
	    element.db_length = element.db_prec = 0;
	    while (output != QO_DDONE && output != QO_QDONE && err == OK)
	    {
		/* get the new array record */
		_VOID_ IIARarrArrayRef(adbv, (i4)++i, &element, TRUE);

		/* set the objects */
		for (argv = qry->qr_argv;
				argv != NULL && argv->qv_name != NULL; ++argv)
		{
			_VOID_ IIARdoaDotAssign( &element, argv->qv_name,
					&((base[argv->qv_base])[argv->qv_index])
			);
		}
		err = IIQG_generate(qdsc, QI_GET, &output);
	    }
	}
	else if ( form != NULL
	  && (putlist = qry->qr_putparam) != NULL 
	  && *putlist != EOS  
	  && IIfsetio(form) != 0 )
	{ /* output values to form for frame */
	    for (argv = qry->qr_argv ;
		    *putlist != EOS && argv != NULL && argv->qv_name != NULL;
			putlist++, argv++)
	    {
		if ( *putlist == 'a' )
		{
			IIputfldio(argv->qv_name, (i2 *)NULL, TRUE,
				DB_DBV_TYPE, 0,
				&((base[argv->qv_base])[argv->qv_index])
			);
		}
	    }
	}
	qry = qry->qr_child;
    } /* end query while */

    /*
    ** If the query is done, free memory allocated in the QDESC. Fixes 51153.
    */
    if (output == QO_QDONE)
    {
	IIQG_free(qdsc);
    }

    return TRUE;
}

/*
** Name:	_qryCvtV3() -	Convert V1 or V2 QDESC to V3.
**
** Description:
**	Converts a V1 or V2 QDESC (query descriptor) to V3.
**
** Input:
**	qv	{QDESC *}  The QG version 1 or 2 query descriptor.
**	fdesc	{FDESC *}  The FDESC for the frame or procedure that built
**			   the query descriptor.
**
** Side Effects:
**	Allocates a V3 query descriptor (if the original descriptor was V1).
**
** History:
**	01/90 (jhw) -- Written (for JupBug #7899.)
**	02/20/91 (emerson)
**		Fixes for bug 35798:
**		Handle V2 QDESCs as well as V1 QDESCs; convert both to V3.
**
**		Note: we set the qg_from, qg_where, and qg_order fields to NULL
**		(they were garbage in V1 and V2).
**
**		Also note that we need logic to detect the case
**		where the input QDESC is really V3
**		(even though its qg_version is 2); in a V3 QDESC,
**		the qg_from, qg_where, and qg_order fields contain
**		meaningful data which may be non-null; it would be a mistake
**		to null them out.
**
**		We detect this case by looking at the FDESC
**		for the frame or procedure that built the QDESC;
**		if the FDSC_60_6302 bit is *not* set in fdsc_version,
**		we conclude that the frame or procedure was compiled using
**		the 6.3/03/00 OSL compiler, and thus the QDESC contains
**		meaningful data in qg_from, qg_where, and qg_order.
**
**		The only problem with this is where a frame or procedure
**		with no fields whatsoever is compiled under 6.3/03/00:
**		the FDSC_60_6302 bit will be erroneously set.
**		(See the discussion of bug 35946 in fdesc.h and abrtexpr.c).
**		It wouldn't make sense for such a frame or procedure
**		to do a select (there'd be no fields to select into),
**		but it could pass a query to a called frame.
**		That would cause trouble if any of the qg_from, qg_where, or
**		qg_order fields had non-null values.
*/
static QDESC *
_qryCvtV3 ( qv, fdesc )
QDESC	*qv;
FDESC	*fdesc;
{
	QDESC	*qnew;

	if (qv->qg_version == QG_V2)
	{
		qnew = qv;
		qnew->qg_version = QG_VERSION;
		if (fdesc->fdsc_version & FDSC_60_6302)
		{
			qnew->qg_from = NULL;
			qnew->qg_where = NULL;
			qnew->qg_order = NULL;
		}
	}
	else
	{
		QDESC_V1 *qv1;
		i4	i;

		qv1 = (QDESC_V1 *)qv;
		qnew = (QDESC *)_alloc(sizeof(*qnew));
		if ( qnew == NULL )
		{
			return NULL;
		}
		qnew->qg_new = qv1->qg_new;
		qnew->qg_name = qv1->qg_name;
		qnew->qg_version = QG_VERSION;
		qnew->qg_dml = qv1->qg_dml;
		qnew->qg_mode = qv1->qg_mode;
		qnew->qg_num[0] = qv1->qg_num[0];
		qnew->qg_num[1] = qv1->qg_num[1];
		qnew->qg_argv = qv1->qg_argv;
		qnew->qg_tlist = qv1->qg_tlist;
		qnew->qg_from = NULL;
		qnew->qg_where = NULL;
		qnew->qg_order = NULL;
		qnew->qg_child = qv1->qg_child;
		qnew->qg_internal = qv1->qg_internal;
		qnew->qg_bcnt = qv1->qg_bcnt;
		for ( i = QG_BCNT ; --i >= 0 ; )
			qnew->qg_base[i] = qv1->qg_base[i];
	}
	if ( qnew->qg_child != NULL &&
		( qnew->qg_child = _qryCvtV3(qnew->qg_child, fdesc)) == NULL )
	{
		MEfree(qnew);
		return NULL;
	}
	return qnew;
}

/*{
** Name:	iiarPassArg() -	Pass Arguments to Frame or Procedure.
**
** Description:
**	Passes the arguments in a ABRTSPRM to a frame or procedure described
**	by an FDESC, either the 6.0 version or earlier.  The version of the
**	ABRTSPRM will be 6.0 in most cases. However, if the FDESC is 6.0,
**	then ABRTSPRM can be 6.0 or earlier.
**
**	This routine is the 6.0 equivalent of 'abrtspassarg()'.
**
** Inputs:
**	name	{char *}  Form name
**	prm	{ABRTSPRM *}  The parameter structure for the call.
**	fdesc	{FDESC *}  The symbol table for the callee.
**	dbdvarr	{DB_DATA_VALUE []}  The array of DB_DATA_VALUEs for the frame.
**	dir	{nat}   The direction to copy >0 means from prm to
**			fdesc, <0 means from fdesc to prm iff the
**			type in prm is < 0 (which means by reference)
**	obj	{char *}  The name of the called object.
**	kind	{char *}  A string describing the called object.
**
** History:
**	14-may-1987 (agh)
**		Adapted for v6.0 from abrtspassarg().
**	06/09/87 (jhw) -- Added backwards compatibility for versions < 6.0.
**	09/90 (jhw) - Modified check for positional parameters to report error
**		at first but to continue processing for formal parameters.
*/
static STATUS _inConvert();				 
static STATUS _outConvert();				 

VOID
iiarPassArg ( name, prm, fdesc, dbdvarr, dir, obj, kind )
char		*name;
ABRTSPRM	*prm;
FDESC		*fdesc;
DB_DATA_VALUE	*dbdvarr;
i4		dir;
char		*obj;
char		*kind;
{
    register char	**fpn;	/* pointer to formal name */
    register ABRTSPV	*ap;	/* pointer to actuals */
    register i4	cnt;
    i4			prmver;
    ADF_CB		*cb;

    if ( prm == NULL || prm->pr_argcnt <= 0 )
	return;

    cb = FEadfcb();
    prmver = prm->pr_version;

    /* If no dbdvarr, we're in an error exit.  Leave now. */
    if (dir <= 0 && dbdvarr == NULL)
	return;

    /*
    ** Because of the grammar, formals will either be NULL or the first one
    ** will be NULL if all arguments or some arguments are positional.  At
    ** present, 4GL frames and procedures can only have keyword parameters.
    */
    fpn = prm->pr_formals;
    if ( prm->pr_argcnt > 0 && (fpn == NULL || fpn[0] == NULL) )
    {
    	iiarUsrErr(POSTOOSL, 1, name);
    }

    for ( ap = prm->pr_actuals, cnt = prm->pr_argcnt ;
			fpn != NULL && --cnt >= 0 ; ++fpn, ++ap )
    {
	DB_DATA_VALUE		*actual;
	PTR			value;
	DB_EMBEDDED_DATA	edv;
	char			*fld_name;
	DB_DT_ID		fld_type;
	i4			fld_len;
	FDESCV2 		*fp;

	if (*fpn == NULL)
	{ /* skip positional parameters */
	    continue;
	}

	/* Fast check on return for `by reference' values */
	if (dir <= 0 && ap->abpvtype >= 0)
	    continue;	/* no need to process if not `by reference' */

	actual = prmver > 1 ? (DB_DATA_VALUE *)ap->abpvvalue : NULL;

	if ((fp = iiarGetFdesc(*fpn, ERx(""), fdesc)) == NULL)
	{
		if (!(prm->pr_flags & ABPIGNORE) && dir > 0)
			iiarUsrErr( NOPARAM, 3, *fpn, obj, kind );
		continue;
	}

	if (fp->fdv2_flags & FDF_LOCAL)
	{
		/* local variable, can't pass a value to it. */
		iiarUsrErr( NOPARAM, 3, *fpn, obj, kind );
		continue;
	}

	/*
	** Get value, and if visible, also get display information
	** corresponding to the current FDESC.
	*/
	value = (PTR) (dbdvarr + fp->fdv2_dbdvoff);
	if (fp->fdv2_visible == 'v')
	{
		fld_name = fp->fdv2_name;
		fld_type = DB_DBV_TYPE;
		fld_len = 0;
	}
	if (prmver <= 1)
	{ /* calling frame < 6.0 */
		edv.ed_data = (PTR)ap->abpvvalue;
		edv.ed_type = iiarDbvType(abs(ap->abpvtype));

		switch (edv.ed_type)
		{
		  case DB_INT_TYPE:
		    edv.ed_length = sizeof(i4);
		    break;

		  case DB_FLT_TYPE:
		    edv.ed_length = sizeof(f8);
		    break;

		  case DB_CHR_TYPE:
		    edv.ed_length = dir > 0 ? 0 : ap->abpvsize;
		    break;

		  default:
		    edv.ed_length = 0;	/* error */
		    break;
		}
		edv.ed_null = (i2 *)NULL;
	}

	if (dir > 0)
	{ 
		/* pass parameters in ... */
	    if ((prmver > 1 &&	/* only calling frames >= 6.0 have Nulls */
	    		AFE_NULLABLE_MACRO(actual->db_datatype) )
		  &&
		( !AFE_NULLABLE_MACRO(((DB_DATA_VALUE *)value)->db_datatype)) )
	    {
		/*
		** Error if a possibly Null value is passed
		** into a field that is not Nullable.
		*/
		iiarUsrErr( ABNULLPRM, 3, obj, kind, *fpn );
	    }

	    if (_inConvert(cb, prmver, &edv, actual, (DB_DATA_VALUE*)value,
			obj, kind, *fpn) == E_DB_OK
	      && fp->fdv2_visible == 'v' 
	      && IIfsetio(name) != 0)
	    { /* Put data to form (use converted value) */
	       IIputfldio(fld_name, (i2 *)NULL, TRUE, fld_type, fld_len, value);
	    }
	}
	else if (ap->abpvtype < 0)
	{ 
		/* by reference ... */
	    if (fp->fdv2_visible == 'v' && IIfsetio(name) != 0)
	    { 
		/* Get data from form */
	       IIgetfldio((i2 *)NULL, TRUE, fld_type, fld_len, value, fld_name);
	    }

	    if ( AFE_NULLABLE_MACRO(((DB_DATA_VALUE *)value)->db_datatype)
		  &&
		(prmver <= 1 || !AFE_NULLABLE_MACRO(actual->db_datatype)) )
	    {
		/*
		** Error if a possibly Null value is returned by
		** reference to a field that is not Nullable.
		*/
		iiarUsrErr( ABNULLBYREF, 2, *fpn, kind );
	    }
	    /*
	    ** The error would have been printed when passing
	    ** parameters into the object so don't bother here.
	    */
	    _VOID_ _outConvert(cb, prmver, &edv, 
			(DB_DATA_VALUE *)value, actual
		);
	}
    } /* end for */
}

static STATUS
_outConvert(cb, prmver, edv, value, actual)
ADF_CB			*cb;
i4			prmver;
DB_EMBEDDED_DATA	*edv;
DB_DATA_VALUE		*value;
DB_DATA_VALUE		*actual;
{
	STATUS stat;

	if (prmver > 1)
	{
		/* return from V >= 6.0 to V >= 6.0 */
		stat = afe_cvinto(cb, value, actual);
	}
	else 
	{
		/* return from V >= 6.0 to V < 6.0 */
		stat = adh_dbcvtev(cb, value, edv);
	}
	return stat;
}

static STATUS
_inConvert(cb, prmver, edv, actual, value, obj, kind, fname)
ADF_CB			*cb;
i4			prmver;
DB_EMBEDDED_DATA	*edv;
DB_DATA_VALUE		*actual;
DB_DATA_VALUE		*value;
char			*obj;
char			*kind;
char			*fname;
{
	STATUS stat;

	if ( prmver > 1 ) /* ... from V >= 6.0 */
	{
		if (actual->db_datatype == DB_DMY_TYPE 
		  || value->db_datatype == DB_DMY_TYPE)
		{
			STATUS IIARoasObjAssign();

			stat = IIARoasObjAssign(actual, value);
		}
		else
		{
			stat = afe_cvinto(cb, actual, value);
		}
	}
	else
	{
		stat = adh_evcvtdb(cb, edv, value);	 
	}
	if (stat == E_DB_OK)
		return stat;

	/* Bad news.  Error.  Tell. */

	if (cb->adf_errcb.ad_errcode == E_AD1012_NULL_TO_NONNULL)
	{
		FEafeerr(cb);
	}
	else
	{
		DB_DATA_VALUE	xdbv;
		DB_DATA_VALUE	*dp;
		AB_TYPENAME	vtn;	/* formal datavalue type name */
		AB_TYPENAME	atn;	/* actual datavalue type name */

		if (prmver > 1)
			dp = actual;
		else
		{
			xdbv.db_datatype = edv->ed_type;
			xdbv.db_length = edv->ed_length;
			xdbv.db_prec = 0;
			dp = &xdbv;
		}
		iiarUsrErr( PRMTYPE, 5, obj, kind, fname,
				iiarTypeName(value, vtn), iiarTypeName(dp, atn)
		);
	}
	return stat;
}

/*{
** Name:	iiarAttachQry() -	Attach Query Passed As Parameter.
**
** Description:
**	Called when a query (from v6.0 or later) is passed as a parameter to a
**	frame or procedure of any version.  If it is not v6.0 or later, a DBDV
**	array is allocated for the frame or procedure's data.
**	This routine has to resolve some things that OSL can't do at
**	compile time, because OSL doesn't know the fields of the frame
**	being called.
**	This routine is the 6.0 equivalent of the earlier routine
**	abrtsfattach(), whose first argument is a QRYV0.
**
** Inputs:
**	qry		{QRY *}  The query.
**			Expects that the attribute "qr_putparam" is writable;
**			currently this is ensured by the routine iiarQryExpand,
**			which is always called prior to this routine (see 
**			abrtqry.qsc).
**	fdesc		{FDESC *}  The field desc. array for the called frame.
**	dbdvarr		{DB_DATA_VALUE []}  The array of DB_DATA_VALUEs for
**		 			    the frame (NULL if < 6.0.)
**	framename	{char *}  The name of the called frame.
**	formname	{char *}  The name of the called frame's form.
**
** Returns:
**	{STATUS}  OK if all went okay; else FAIL.
**
** History:
**	06/10/87 (jhw) -- Added backwards compatibility for versions 3.0-5.0.
**	19-may-1986 (agh)
**		Adapted for v6.0 from abrtsfattach().
**	10/89 (jhw) -- Set FAIL status for columns not found in the symbol
**		table.  JupBug #8491.
*/
STATUS
iiarAttachQry ( qry, fdesc, dbdvarr, framename, formname )
QRY		*qry;
FDESC		*fdesc;
DB_DATA_VALUE	*dbdvarr;
char		*framename;
char		*formname;
{
    register QRY_ARGV	*qp;
    register char	*pt = qry->qr_putparam;
    char		*tblname = qry->qr_table;
    i4			count;
    STATUS		attach;

    if (CMcmpnocase(qry->qr_form, formname) != 0 ||
	    STbcompare(qry->qr_form, 0, formname, 0, TRUE) != 0)
    {
	iiarUsrErr( NOQRYFRM, 3, framename, qry->qr_form, formname );
	qry->qr_form = formname;
    }
    else if (tblname != NULL && *tblname != EOS)
    {
	if ( !iiarTblfld(tblname, fdesc) )
	{
	    iiarUsrErr( NOQRYTBL, 3, framename, formname, tblname );
	    return FAIL;
	}
    }

    /* Attach QRY_ARGVs to frame DBDVs. */
    attach = OK;
    count = 0;
    for ( qp = qry->qr_argv ;
		qp->qv_dbval != NULL || qp->qv_name != NULL ; ++qp )
    {
	FDESCV2 *fp;

	fp = iiarGetFdesc(qp->qv_name, tblname, fdesc);

	if (fp != NULL && fp->fdv2_dbdvoff >= 0)
	{
	    if (++count >= DB_MAX_COLS)
	    {
		iiarUsrErr( DOMOVER, 0 );
		return FAIL;
	    }

	    /*
	    ** Fill in the base/index reference member pair of the QRY_ARGV.
	    ** The base indicates the DB_DATA_VALUE array in the called frame;
	    ** the index the offset into that array for the particular element.
	    */
	    qp->qv_base = ABCG_CALLEEBASE;
	    qp->qv_index = fp->fdv2_dbdvoff;
	    *pt++ = (fp->fdv2_visible == 'v') ? 'a' : 'd';
	}
	else
	{ /* Error! */
	    if (*tblname == EOS)
		iiarUsrErr( ABNOFIELD, 2, qp->qv_name, qry->qr_form );
	    else
		iiarUsrErr( ABNOTFCOL, 3, qp->qv_name, tblname, qry->qr_form );
	    attach = FAIL;
	}
    } /* end for */

    /*
    ** Set the element of the qg_base array that points to the
    ** DB_DATA_VALUE array in the called frame.
    */
    qry->qr_qdesc->qg_base[ABCG_CALLEEBASE] = (DB_DATA_VALUE (*)[])dbdvarr;

    return attach;
}

/*{
** Name:	iiarQryExpand() -	Expand Query Passed as a Parameter.
**
** Description:
**	Expands a '.all' in a query passed between a 6.0 frame or procedure
**	and another frame or procedure of any version.
**
** Inputs:
**	qry	{QRY *}  The query structure (which may have to be expanded).
**	fdesc	{FDESC *}  The field desc. array for the called frame.
**
** Side Effects:
**	Allocates and set-ups the query descriptor argument list and query
**	specification based on the fields or table field columns for the form.
**	May also convert the query descriptor 'qry->qr_desc' to V2.
**	Also always ensures a writable copy of 'qry->qr_putparam' for future
**	calls to iiarAttachQry().
**
** History:
**	20-may-87 (agh)
**		Adapted from abrtsqexpand() for 6.0.
**	06/10/87 (jhw) -- Added backwards compatibility for versions 3.0-5.0.
**	01/02/90 (jhw) -- Convert V1 QDESC to V2.
**	02/20/91 (emerson)
**		Fixes for bug 35798: Call _qryCvtV3 (instead of the old
**		_qryCvtV2), to handle V2 QDESCs as well as V1 QDESCs
**		(convert both to V3).  Note that _qryCvtV3 needs to be passed
**		the FDESC of the frame or procedure which built the QDESC;
**		for iiarQryExpand, this is the frame or procedure which called
**		the current frame, since iiarQryExpand is called from
**		iiarIObjInit after a new entry for the current (called) frame
**		has been pushed onto the run-time stack.
**	12-aug-91 (davel)
**		Fix for bug 33674: iiarAttachQry is expecting this routine
**		to allocate a writable copy of qry->qr_putparam. If there's
**		no "dot all" arguments, allocate a string of the same length
**		as the current qry->qr_putparam.
*/
QRY_SPEC	*iiarNxtDotAllSpec();
static i4	_DotAllUsed();

VOID
iiarQryExpand ( qry, fdesc )
QRY		*qry;
FDESC		*fdesc;
{
    register QRY_ARGV	*avp;
    register QRY_ARGV	*new_argvs;
    register QRY_SPEC	*specs;
    QDESC		*qdesc = qry->qr_qdesc;
    QRY_ARGV		*ablock;	/* mem allocated for QRY_ARGV array */
    QRY_SPEC		*sblock;	/* mem allocated for QRY_SPEC array */
    char		*tfldname;
    i4			num_tables;
    i4			num_fields;
	FDESCV2 *fp;

    char	*FEsalloc();

    /* Check for Version 1 or 2 Query Descriptor */
    if ( qdesc->qg_version < QG_VERSION )
    { /* Convert version 1 or 2 to version 3 */
	qdesc = _qryCvtV3(qdesc, IIarRtsStack->abrfsnext->abrfsfdesc);
	qry->qr_qdesc = qdesc;
	if ( qdesc == NULL )
	{
		abproerr(ERx("QryExpand(QV2Cvt))"), OUTOFMEM, (char *) NULL);
		return;
	}
	if ( qry->qr_child != NULL )
		qry->qr_child->qr_qdesc = qdesc->qg_child;
    }

    if ((num_tables = _DotAllUsed(qry->qr_putparam)) == 0)
    {	/* no '.all' references in query:
	** allocate a writable qr_putparam.  Currently iiarAttachQry is
	** relying on this routine to allocate a writable copy.
	*/
	STATUS  stat;
	if ( (qry->qr_putparam = 
	     (char*)FEcalloc(1 + STlength(qry->qr_putparam), &stat)) == NULL
           )
	{
	   abproerr(ERx("QryExpand"), OUTOFMEM, (char *) NULL);
	}
	return;
    }

    tfldname = qry->qr_table;
    num_fields = 0;

	for (fp = (FDESCV2*)fdesc->fdsc_ofdesc; fp->fdv2_name != NULL ; fp++)
	{
	    if (fp->fdv2_visible != 'v' && fp->fdv2_visible != 'h')
		continue;
	    if (CMcmpnocase(fp->fdv2_tblname, tfldname) == 0 
	      && STbcompare(fp->fdv2_tblname, 0, tfldname, 0, TRUE) == 0 
	      && fp->fdv2_visible == 'v')
	    {
		++num_fields;
	    }
	}

    /*
    ** The number of QRY_ARGVs for the query's target list is as follows:
    ** the number of displayed fields in the form times the number of tables
    ** referenced with a dot-all), plus the number of already existing
    ** QRY_ARGVs, minus the number of dot-alls (since each dot-all already
    ** occupies one QRY_ARGV), plus one for the terminating QRY_ARGV.
    **
    ** The number of QRY_SPECs for the target list remains the same as
    ** in the original array, but the QRY_SPECs corresponding to dot-alls
    ** have their strings expanded (in the newly allocated array.)
    ** (Remember to include one for the terminating QRY_SPEC.)
    */
    {
	STATUS  stat;
	register i4	n_argvs;
	register i4	size_specs;

	n_argvs = (num_fields * num_tables) - num_tables + 1;
	for (avp = (QRY_ARGV *)qdesc->qg_argv ;
			avp->qv_name != NULL || avp->qv_dbval != NULL ; ++avp)
	    ++n_argvs;

	size_specs = 1;
	for (specs = (QRY_SPEC *)qdesc->qg_tlist ;
			specs->qs_type != QS_END ; ++specs)
	    ++size_specs;

	if ( (ablock = (QRY_ARGV*)FEcalloc(n_argvs*sizeof(*avp), &stat)) == NULL
		|| (sblock = (QRY_SPEC*)FEcalloc(size_specs * sizeof(*specs),
			&stat)) == NULL
		|| (qry->qr_putparam = (char*)FEcalloc(n_argvs + 1, &stat))
			== NULL )
	{
	    abproerr(ERx("QryExpand"), OUTOFMEM, (char *) NULL);
	}
	MEcopy((PTR)qdesc->qg_tlist, (size_specs * sizeof(*sblock)), (PTR)sblock);
    }

    /*
    ** Build new arrays of QRY_ARGVs and QRY_SPECs.  For each QRY_ARGV that
    ** corresponds to a dot-all, create one QRY_ARGV for each displayed
    ** field in the called form.  Copy over any other QRY_ARGVs from the
    ** old array to the new.
    ** For each QRY_SPEC that relates to a dot-all, expand the qs_var
    ** element to be a full target list.
    */
    new_argvs = ablock;
    specs = sblock;
    for (avp = (QRY_ARGV *)qdesc->qg_argv ;
		avp->qv_dbval != NULL || avp->qv_name != NULL; ++avp)
    {
	/* Note:  'iiarAttachQry()' will set the base/index members */
	new_argvs->qv_dbval = (DB_DATA_VALUE *)NULL;
	if (*avp->qv_name != EOS)
	{ /* a "real" QRY_ARGV */
	    new_argvs->qv_name = avp->qv_name;
	    ++new_argvs;
	}
	else
	{ /* . ALL QRY_ARGV */
	    char		tlist[ABBIGBUFSIZE];
	    register char	*tcp = tlist;
	    char		*relname;

	    /*
	    ** Set specs to point to the next QRY_SPEC that
	    ** refers to a dot-all, and fill in the relname buffer
	    ** with the name of the table for the dot-all.
	    */
	    if ((specs = iiarNxtDotAllSpec(specs)) == NULL)
	    {
		abproerr(ERx("QryExpand"), OUTOFMEM, (char *) NULL);
		return;
	    }
	    relname = (char *)specs->qs_var + (sizeof(ERx("%A")) - 1);
	    /*
	    ** Expand the QRY_ARGV array for the dot-all.
	    */

	    for (fp = (FDESCV2*)fdesc->fdsc_ofdesc; fp->fdv2_name != NULL; fp++)
	    {
		if (CMcmpnocase(fp->fdv2_tblname, tfldname) == 0 
		  && STbcompare(fp->fdv2_tblname, 0, tfldname, 0, TRUE) == 0)
		{
			/* Skip hidden fields in expanding the dot-all. */
			if (fp->fdv2_visible != 'v')
				continue;

			new_argvs->qv_name = fp->fdv2_name;
			++new_argvs;

			/*
			** If this is an SQL "select *" statement, simply
			** output the names of the fields.  If it is a QUEL 
			** "retrieve (table.all)" statement, output
			** "col1=table.col1, ...".
			*/
			if (*relname == '*')
			{
			    _VOID_ STprintf(tcp, ERx("%c%s"),
						(tcp == tlist) ? ' ' : ',',
						fp->fdv2_name
				);
			}
			else
			{
			    _VOID_ STprintf(tcp, ERx("%c%s=%s.%s"),
						(tcp == tlist) ? ' ' : ',',
						fp->fdv2_name, relname,
						fp->fdv2_name
				);
			}
			tcp += STlength(tcp);
		}
	    }
	    /*
	    ** Insert newly built target list string into QRY_SPEC corresponding
	    ** to the dot-all.  Then increment the pointer into the QRY_SPEC
	    ** array so that the next call to 'iiarNxtDotAllspec()' will find
	    ** the next dot-all instance (if any).
	    */
	    *tcp = EOS;
	    specs->qs_var = (PTR)FEsalloc(tlist);
	    ++specs;
	}
    } /* end for */
    new_argvs->qv_dbval = (DB_DATA_VALUE *)NULL;
    new_argvs->qv_name = (char *)NULL;

    /*
    ** Set QRY and QDESC QRY_ARGV arrays and the QDESC
    ** qg_tlist array to be the newly created arrays.
    */
    qry->qr_argv = ablock;
    qdesc->qg_argv = (QRY_ARGV (*)[])ablock;
    qdesc->qg_tlist = (QRY_SPEC (*)[])sblock;
}

/*
** Name:	iiarNxtDotAllSpec() -	Return QRY_SPEC For Next Dot-All.
**
** Description:
**	Returns the QRY_SPEC for the next dot-all.  The dot-all is indicated
**	by a "%Aname" in the text string of a QRY_SPEC in the query's target
**	list.
**
** Input:
**	qspec	{QRY_SPEC *}  A reference to a QRY_SPEC array containing a part
**			of the string for the query's target list.
**			Set to point to the QRY_SPEC which corresponds to
**			the next dot-all in the target list.
**
** Returns:
**	{QRY_SPEC *}  Reference to the QRY_SPEC array element that corresponds
**			to the next dot-all in the target list, if any.
**		
** History:
**	22-may-87 (agh)
**		Adapted from abrtsrname() for 6.0.
*/
QRY_SPEC *
iiarNxtDotAllSpec (qspecarr)
QRY_SPEC	*qspecarr;
{
    register QRY_SPEC	*qsptr;

    if ( qspecarr == NULL )
	return NULL;

    for (qsptr = qspecarr ; qsptr->qs_type != QS_END ; ++qsptr)
    {
	if ( qsptr->qs_type == QS_TEXT )
	{
		register char	*tlcp;

		tlcp = (char *)qsptr->qs_var;
		if (*tlcp == '%' && *(tlcp+1) == 'A')
			return qsptr;
	}
    } /* end for */

    return NULL;
}

/*
** Name:    _DotAllUsed() -	Does a '.all' appear in a passed query?
**
** Description:
**	Determines how many (if any) '.all' constructs appear in a
**	query passed between frames.
**	Each '.all' is indicated by a "%Aname" in the 'qr_putparam'
**	element of the query.
**
** Inputs:
**	str	{char *}  The 'putparam' for the query.
**
** Returns:
**	{nat}  The number of '.all' constructs in the query in the
**		calling frame; 0 if none.
**		
** History:
**	22-may-87 (agh) - Written.
*/
static i4
_DotAllUsed ( str )
char	*str;
{
	register char	*cp;
	register i4	dotalls = 0;

	for (cp = str ; *cp != EOS ; ++cp)
	{
		if (*cp == '%' && *(cp+1) == 'A')
			++dotalls;
	}
	return dotalls;
}

/*{
** Name:	IIARsctSetClearTarget() - Set "CLEAR_ON_NO_ROWS" option.
**
** Description:
**	Set the "CLEAR_ON_NO_ROWS" option, usually as the result of a
**	user's SET_4GL statement, but can also be set internally. The current
**	state is kept in this module in static variable "clear_on_no_rows".
**
** Input:
**	clear_opt	{nat}  		new value of "CLEAR_ON_NO_ROWS" option
**
** Returns:
**	void
**
** Side-Effects:
**	modifies value of static variable "clear_on_no_rows".
**
** History:
**	10-feb-93 (davel)
**		First written.
*/
void
IIARsctSetClearTarget (i4 clear_opt)
{
	clear_on_no_rows = (clear_opt) ? TRUE : FALSE;
	return;
}

/*{
** Name:	IIARictInquireClearTarget() - Return "CLEAR_ON_NO_ROWS" setting.
**
** Description:
**	Return the value of the "CLEAR_ON_NO_ROWS" option.  This is usually
**	called externally as a result of a user's INQUIRE_4GL statement. Other
**	modules in abrtnqry.qsc just reference the static variable 
**	"clear_on_no_rows" directly to inquire upoin the setting.
**
** Input:
**	none.
**
** Returns:
**	{nat}  		value of "CLEAR_ON_NO_ROWS" setting.
**
** History:
**	10-feb-93 (davel)
**		First written.
*/
i4
IIARictInquireClearTarget (void)
{
	return (clear_on_no_rows ? 1 : 0 );
}

/*{
** Name:	iiarDbvType() -	Return DB Datavalue Type for OL Type.
**
** Description:
**	Map from old (3.0, 4.0, 5.0) OL module type (OL_I4, OL_F8, etc.
**	(in "ol.h") to new DB datavalue type (as defined by "dbms.h".)
**
** Input:
**	oltype	{nat}  Type from (3.0, 4.0, 5.0) OL module type.
**
** Returns:
**	{DB_DT_ID}  DB datavalue type.
**
** History:
**	06/87 (jhw) -- Written.
*/
DB_DT_ID
iiarDbvType ( i4 oltype )
{
    switch (oltype)
    {
      case OL_STR:
	return DB_CHR_TYPE;
      case OL_I4:
	return DB_INT_TYPE;
      case OL_F8:
	return DB_FLT_TYPE;
      default:
	return DB_NODT;
    }
}

/*{
** Name:	IIARqryNext() -	Check for Passed Query.
**
** Description:
**	Make sure that a query has been passed into the current
**	frame when a user requests the "next" tuple.
*/
bool
IIARqryNext ( nrtsprm )
ABRTSPRM	*nrtsprm;
{
	ABRTSOPRM	*rtsprm;

	if ( nrtsprm == NULL )
		return (bool)FALSE;

	rtsprm = NEWPARAM_MACRO(nrtsprm)
			? nrtsprm->pr_oldprm : (ABRTSOPRM*)nrtsprm;
	return (bool)( rtsprm->pr_qry != NULL );
}

bool
abrtsnext ( nrtsprm )
ABRTSPRM	*nrtsprm;
{
	return IIARqryNext( nrtsprm );
}

/*{
** Name:	iiarTblfld() -	Verify Table Field in FDESC.
**
** Description:
**	Search through an FDESC to see if a table field exists.
**	This routine is the 6.0 equivalent of the earlier routine
**	'iiarOFTblfld()'.
**
** Inputs:
**	tblname		The table field's name.
**	fdesc		The FDESC to look in.
**
** Returns:
**	{bool}	TRUE if tblname is a table field.
**		FALSE otherwise.
**
** History:
**	19-may-1986 (agh)
**		Adapted from 'iiarOFTblfld()' for v6.0.
**	9/89 (billc) - Re-written.
*/

bool
iiarTblfld ( tblname, fdesc )
char		*tblname;
FDESC		*fdesc;
{
	return (bool)( iiarGetFdesc((char*)NULL, tblname, fdesc) != NULL );
}
