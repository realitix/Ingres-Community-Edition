/*
** Copyright (c) 2004, 2008 Actian Corporation
** All Rights Reserved.
*/

# include	<compat.h>
# include	<cv.h>		 
# include	<pc.h>		 
# include	<st.h>		 
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<fe.h>
# include	<er.h>
# include	<ex.h>
# include	<si.h>
# include	<lo.h>
# include	<nm.h>
# include	<ci.h>
# include	<cm.h>
# include	<ug.h>
# include	<st.h>
# include	<eqsym.h>
# include	<eqgr.h>
# include	<equel.h>
# include	<eqscan.h>
# include	<eqlang.h>
# include	<eqesql.h>
# include	<eqgen.h>
# include	<eqstmt.h>
# include	<equtils.h>
# include	<ereq.h>
/*
+* Filename:	eqmain.c
** Purpose:	Process command-line arguments and pre-process all files.
**
** Defines:
**	eq_main		- Driver for equel.
**	eq_procargs	- Process an argument list, up to the first file name.
**	eqhandle	- Handle exceptions.
**	eq_init		- Do per-file language-independent initialization.
**	eq_help		- Print an error message and a help message, then exit.
**	eq_loc_compare	- See if two locations refer to the same object.
**	gr_mechanism	- Dummy gr_mechanism for testing.
** (Local Data):
**	eq_private	- Private state flags.
-*	dml_lang	- Private DML language string ("EQUEL" or "ESQL")
** Notes:
**	  This file is language-independent.
**
** History:
**	28-jan-1985	- Initial version. (mrw)
**	01-dec-1986	- Added support for global includes, from jhw code
**			  of 05-feb-1986. (mrw)
**	29-jun-87 (bab)	Code cleanup.
**	03/16/88 (dkh) - Added EXdelete call to conform to coding spec.
**	25-jan-89 (marian)
**		Added support for a -wcommon flag that will be used to
**		produce warning messages to notify the user of non-portable
**		sql code.  This flag will notify when non-common sql commands
**		are used.
**      03/27/89 (esd) - ifdef'd out help info that doesn't apply to MVS.
**	15-may-1989	- Changed -wcommon flag to -wopen. (bjb)
**	11-jul-89 (bryanp) - MPE/ML-specific changes to file name generation.
**	02-aug-1989	- Changed flag numbers; added -wfips flag. (barbara)
**	10-aug-1989	- Fixed bug in processing arguments. (barbara)
**	02-oct-89 (neil)
**		Added recognition of the -a flag for Ada.  This allows support
**		for Vads and Vax Ada compilers with dynamic option.
**	05-oct-89 (barbara)
**		Integrated PC changes.  eq_main is now declared void.
**	20-nov-89 (neil)
**		Turn on ANSI for MF COBOL (by default).
**	23-jan-90 (barbara)
**		Str buffer to LOfroms should not be used outside of LO module.
**		Turn on ANSI for MF COBOL (by default).
**      07-feb-1990 (kwatts)
**		Added recognition of the -u flag for COBOL. This allows support
**		for MF COBOL compilers without using END-IF, END-PERFORM, or
**		CONTINUE. (Useful for porting to dialects not supporting these).
**	13-mar-90 (barbara)
**		Fixed bug #7218 - removed help for internal flags and -h
**		flag (these are both for internal use only).
**	13-mar-90 (barbara)
**		Fixed bug #7282 to disallow trailing flags on command line.
**		So now we accept eq/esql [flags] file[s] [flags] file[s]
**		but not eq/esql [flags] file[s] flags.
**	27-feb-90 (russ)
**		Add serialization support for ODT.
**	17-jul-1990 (gurdeep rahi)
**		Select Alsys-Ada using "-a" option (see equel.h)
**      10-oct-1990 (stevet)
**              Added IIUGinit call to initialize character set attribute
**              table.
**	24-jun-1990 (teresal)
**		Comment out help for -wfips flag - it is not 
**		part of the 6.4 release.
**	15-nov-91 (leighb) DeskTop Porting Change:
**		Output function prototypes for IILQdbl() and IILQint().
**	12-feb-1992 (rudyw)
**		Remove obsolete ifdef section for Open Desktop serialization.
**	03-oct-1992 (teresal)
**		Replace "-wfips" flag with "-wsql=entry_sql92". Added
**		"-wsql=open" flag (which is the same as "-wopen"), but left
**		"-wopen" for backwards compatibility. Changed help to 
**		print new flags.
**	14-oct-1992 (larrym)
**		Added new flag (temporarily, not LRC approved) "-SQLCODE"
**		to indicate that an SQLCODE is assumed to be declared.
**		Also updated copyright notice to new format.
**	10-jun-1993 (kathryn)
**	    	For FIPS,  Add "-b" flag for ESQL/C only - to specify ANSI STD
**		assigment retrieval rules, which state that fixed length "C"
**		variables should be blank-padded to the length of host_var-1
**		and then EOS terminated.  This is a temporary internal flag 
**		only so that NIST testing may continue. 
**	25-jun-1993 (kathryn)
**		Replaced "-b" flag with the new official ESQL startup flags
**		"-blank_pad" and "-noblank_pad" as described above.
**	17-aug-1993 (sandyd)
**		The .c file generated by ESQL/C will now begin with a #include
**		of the eqdef.h header --- which declares the return types of
**		all function calls that might be generated by the preprocessor.
**		Those declarations are needed to allow warning-free compiles
**		even with strict-checking ANSI compilers (e.g., "acc -vc").
**		Because eqdef.h is similar in concept to the eqdef files used
**		in the non-C languages, it would have been nice to handle it
**		via that same mechanism (i.e., when including the SQLCA).
**		But we obviously couldn't require existing C users to always
**		include the SQLCA (as we do in the non-C languages), so the
**		generation of the #include eqdef.h was put here, as an
**		unconditional first step in generating the .c file.
**	17-dec-1993 (teresal)
**		Give an error if "-wsql=" flag is given with no arguments.
**		Bug #54320.
**	22-nov-1993 (teresal)
**		Add "-[no]check_eos" flag for FIPS. This flag is only for 
**		ESQL/C; it controls checking all character variables 
**		(declared with an explicit length) for a null terminator.
**		This flag is required for FIPS - bug 55915.
**	03/25/94 (dkh) - Added call to EXsetclient().
**      26-mar-1994 (teresal)
**              Add support for the ESQL/C++ preprocessor. Add flags
**              '-extension=<ext>', '-cplusplus', add check for correct 
**		bit for C++ in the authorization string.
**		As part of this change add the ESQL/C '-[no]prototypes'
**              flag.
**      18-sep-1995 (sarjo01)
**		Set EQ_FMTANSI for case of NT_GENERIC
**      12-Dec-95 (fanra01)
**          Added definitions for extracting data for DLLs on windows NT
**      11-jan-1996 (toumi01; from 1.1 axp_osf port)
**              Added kchin's changes for axp_osf
**              10-sep-93 (kchin) bug# 51967
**              Added function prototypes for IILQdbl() and IILQint()
**              for axp_osf, since they returns PTR.  On 64-bit platform, the
**              default int return value for a function will truncate an
**              address which is 64-bit long.
**              Apparently the function prototypes only required for C 
**              language, added a checking.
**	14-mar-1996 (thoda04)
**		Added st.h for STcompare() function prototype.
**		Added eqgen.h for gen_ functions prototypes.
**		Added equtils.h for lbl_init() function prototype.
**		Added eqstmt.h for ecs_clear() function prototype.
**		Added eq_help() function prototype; made arg list fixed length.
**		Cast constant arguments of IIUGfmt() calls to proper nat.
**		Cleaned up esq_ci[] array, (i4)0, not NULL ptr.
**		Check language C before emitting IILQdbl() and IILQint() protos.
**		WIN16 always requires eqdefc.h or eqdefcc.h in emitted C code.
**	08-oct-1996 (mcgem01)
**		Global data moved to eqdata.c
**      25-nov-1996 (merja01)
**              Back off kchin's change for axp_osf bug# 51967
**              Remove function prototypes for IILQdbl() and IILQint() for
**              axp_osf.  The return values are now set to void * in eqdef.h
**	18-Dec-97 (gordy)
**	    Added -multi flag for multi-threaded applications.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	6-sep-02 (toumi01)
**	    bug 76918 add -F free format flag for COBOL (opposite of -a ansi)
**	12-sep-02 (toumi01)
**	    bug 76918 back out -F change above
**	    More changes would be necessary to support FREE format besides
**	    column layout issues (sequence number area and Margin R), and
**	    interested client will manually convert VAX -> ANSI. For more
**	    on converting from VAX to MF Unix COBOL, see issue 12174414.
**	26-feb-2003 (toumi01)
**	    add explicit support for GNAT Ada compiler (initially identical
**	    to Verdix Ada)
**	28-mar-2003 (somsa01)
**	    Changed return type of IILQdbl() and IILQint() to "void *".
**	18-nov-2003 (xu$we01)
**	    The .c file generated by eqc needs a #include of the eqdef.h
**	    header (bug 111314).
**      15-mar-200415-mar-2004 (nansa02) (Problem:-INGEMB119 & bug 111963)
**         Added the code for -multi flag to appear in the help for esqlc when
**         invoked with no params  
**      11-Jun-2004 (hanch04)
**          Removed reference to CI for the open source release.
**	29-Sep-2004 (drivi01)
**	    Added LIBOBJECT hint which creates a rule
**	    that copies specified object file to II_SYSTEM/ingres/lib
**	24-Mar-2007 (toumi01)
**	    Add -multi support for Ada.
**	20-Jun-2008 (hweho01)
**	    Add option -g64 for esqlf and eqf on hybrid platforms, so    
**	    the preprocessors can generate the include statement for 
**	    64-bit definition files.
**	22-Jun-2009 (kschendel) SIR 122138
**	    Use any_aix, sparc_sol, any_hpux symbols as needed.
**	24-Nov-2009 (frima01) Bug 122490
**	    Removed yyparse declaration, prototype now available
**	    in equel.h.
**      20-Jul-2011 (coomi01) Bug 125478
**          Add field eq_outrec_len, initialize it through new FORTRAN 
**          -olen switch
**      
**
*/

/*
**
LIBOBJECT = eqmain.c
**
*/

static char	*dml_lang = ERx("EQUEL");
static char	*abortmsg = ERx("");	/* Aborting on user interrupt */
static char	*exc1msg = ERx("");	/* Internal exception occured */
static char	*exc2msg = ERx("");	/* Please save input and output files */

GLOBALREF i4	eq_private;		/* private state flags; see below */

# define	P_EQ_DLIST	01	/* dump to list file */
# define	P_EQ_DOUTPUT	02	/* dump to output file */
# define	P_EQ_ABF	04	/* called by ABF - do not check CI */
# define	P_EQ_CPROTOS	010	/* include C function prototype file */

/* Flags for eq_loc_compare() */
# define	EQLOCINOUT	1	/* "Input" and "Output" */
# define	EQLOCINLST	2	/* "Input" and "Listing" */
# define	EQLOCOUTLST	3	/* "Output" and "Listing" */

STATUS eq_procargs(char ***argv, char **inp_file);
STATUS equel(char *inp_name);
i4     eqhandle(EX_ARGS *);		/* exception handler */
void   eq_init(void);
void   eq_help(bool err, char c1, char c2, char c3, char c4);
void   eq_loc_compare(LOCATION *a, LOCATION *b, i4  flag);

/*
+* Procedure:	eq_main
** Purpose:	Driver for equel.
** Parameters:
**	argc	- int		- Number of argument strings.
**	argv	- char **	- Pointer to array of argument strings.
** Return Values:
-*	STATUS	- System exit values.
** Notes:
**	- Declares an exit handler.
**	- Repeatedly calls eq_procargs to parse flags and one file, and
**	  preprocesses that file, until it runs out of arguments.
**	- Cleans up and exits.
**
** Imports modified:
**	None.
*/

VOID
eq_main( argc, argv )
i4	argc;
char	**argv;
{
    char	*in_file;
    EX_CONTEXT	context;


    /* Tell EX this is an ingres tool. */
    (void) EXsetclient(EX_INGRES_TOOL);

    /* Call IIUGinit to initialize character set attribute table */
    if ( IIUGinit() != OK)
    {
	PCexit(FAIL);
    }

    if (EXdeclare( eqhandle, &context ) != OK)
    {
	EXdelete();
	PCexit(FAIL);
    }

    if (argc == 1)
    {
	gr_mechanism( GR_EQINIT );
	if (dml_islang(DML_ESQL))
	    dml_lang = ERx("ESQL");
	else
	    dml_lang = ERx("EQUEL");
	eq_help( FALSE , '\0', '\0', '\0', '\0' );
    }
    argv[argc] = NULL;	/* just in case our C runtime uses another flag */

    /*
    ** initialize that part of the eq structure that we aren't guaranteed
    ** to fill in later
    */

    eq->eq_flags = 0;
  /* So error messages on "-h" look right.  This part is reset later. */
    eq->eq_filename = ERget(F_EQ0001_eqCMMDLINE);
    eq->eq_ext = ERx("");
    eq->eq_infile = stdin;

  /* default the DML to EQUEL; SQL or others will change it */
    dml->dm_lang = DML_EQUEL;
    dml->dm_gentab = NULL;
    dml->dm_lex = NULL;		/* MUST be set to something! */
    dml->dm_contin = NULL;	/* currently unused */
    dml->dm_strcontin = NULL;
    dml->dm_iscomment = NULL;
    dml->dm_caarg = NULL;
    dml->dm_cursordmp = NULL;
    dml->dm_sqlcadmp = NULL;
    dml->dm_sqintodmp = NULL;
    dml->dm_repeat = NULL;

  /* 
  ** Get messages to be used by handler because we don't want to be
  ** accessing files after an exception has occurred.
  */
    abortmsg = ERget( F_EQ0004_eqUSRABORT );
    exc1msg = ERget( F_EQ0005_eqINTRNLEX );
    exc2msg = ERget( F_EQ0006_eqINTRNLSAV );

  /* process the argument list */

    for (argv++; *argv;)
    {
	in_file = NULL;
	if (eq_procargs(&argv, &in_file) == OK)
	{
	    /*	
	    ** Make sure ESQL/C++ with no user supplied arguments gets 
	    ** a help message. ESQL/C++ always has 2 arguments by default,
	    ** i.e., 'esqlc -cplusplus' 
	    */
    	    if (argc == 2 && eq_islang(EQ_CPLUSPLUS))
	    	eq_help( FALSE , '\0', '\0', '\0', '\0' );
	    _VOID_ equel(in_file);
	}
    }

    EXdelete();
    PCexit( er_exit() );
}

/*
+* Procedure:	eq_procargs
** Purpose:	Process an argument list, up to the first file name.
**
** Parameters:
**	argv		- char ***	- A pointer to an array of pointers to
**					  strings, terminated by a NULL pointer.
**	inp_file	- char *	- A pointer to a string pointer.
** Returns Values:
-*	STATUS	- Always returns OK.
** Notes:
**	"argv" is pointed to the first unconsumed pointer.
**	"inp_file" is pointed to the specified file name (NULL if none).
**
** Imports modified:
**	None.
**
** History:
**	10-aug-1989	- After processing -w flags, initialize cp pointer.
**			  (barbara)
**	25-jun-1993	(kathryn)
**	    Add -blank_pad and -noblank_pad for FIPS.
**	22-nov-1993	(teresal)
**	    Add "-[no]check_eos" for FIPS. Bug fix 55915
**	31-jan-1993 	(teresal)
**	    Fixed it so the '-c' flag now works - I broke when I 
**	    added the "-check_eos" flag. (part of bug fix 55915).
**	29-mar-1994 	(teresal)
**	    Add new flags "-cplusplus", "-extension" for ESQ/C++ and
**	    added "-[no]prototypes" for ESQL/C.
**	18-Dec-97 (gordy)
**	    Added -multi flag for multi-threaded applications.
*/

STATUS
eq_procargs( argv, inp_file )
char	***argv;
char	**inp_file;
{
    register char
		**arg = *argv;
    register char
		*cp;
    char	*empty = ERx("\0"); /* point cp here to end the inner while */
    GLOBALREF i4	yydebug;

    eq_init();
    gr_mechanism( GR_EQINIT );
    if (dml_islang(DML_ESQL))
	dml_lang = ERx("ESQL");
    else
	dml_lang = ERx("EQUEL");

#ifdef SEINGRES
    eq->eq_flags |= EQ_NOREPEAT;
#endif /* SEINGRES */

#ifdef CMS
    if (eq_islang(EQ_COBOL))
	eq->eq_flags |= EQ_FMTANSI;
#endif /* CMS */

#ifdef NT_GENERIC
    if (eq_islang(EQ_COBOL))    /* MF COBOL */
        eq->eq_flags |= EQ_FMTANSI;
#endif /* NT_GENERIC */

#ifdef UNIX
    if (eq_islang(EQ_COBOL))	/* MF COBOL */
	eq->eq_flags |= EQ_FMTANSI;
#endif /* UNIX */

    if (eq_islang(EQ_ADA))		/* Default for VMS or Vads Ada */
#ifdef VMS
	eq->eq_config = EQ_ADVAX;
#elif defined (LINUX)
	eq->eq_config = EQ_ADGNAT;
#else
	eq->eq_config = EQ_ADVADS;
#endif /* VMS */

#ifdef WIN16
    if (eq_islang(EQ_C) && !(eq_islang(EQ_CPLUSPLUS)) &&
	dml_islang(DML_ESQL)) 
	eq_private |= P_EQ_CPROTOS;  /* esqlc always needs eqdefc.h */
#endif /* WIN16 */

    while (cp = *arg++)
    {
	if (*cp == '-')
	{
	    if (cp[1] == '\0')
		eq_help( TRUE, cp[1], '\0', '\0', '\0' );

	    cp++;		/* Skip the '-' */
	    while (*cp)
	    {
		switch (*cp)
		{
		  case 'b':
                    if (eq_islang(EQ_C) && dml_islang(DML_ESQL))
		    {
			char w_str[FE_PROMPTSIZE];
			STlcopy(cp, w_str, FE_PROMPTSIZE - 1);
			CVlower(w_str);
			if (STcompare(ERx("blank_pad"), w_str) == 0)
			{
				eq->eq_flags |= EQ_CHRPAD;
				cp = empty;
				break;
			}
		    }
                    eq_help( TRUE, *cp, '\0', '\0', '\0' );
                    break;
		  case 'y':
		    yydebug = 1;
		    break;
		  case 'e':
		    /* 
		    ** '-e' flag falls through to '-l' case statement
		    ** for backwards compatibility.
		    **
		    ** Check for ESQL/C & C++ flags:
		    **
		    ** 	'-extension = <ext>' 	! flag sets default output file
		    ** 				  extension. Abbreviation is 
		    **			   	  '-ext[ension] = <ext>'
		    **	
		    ** Note: this flag is available to ESQL C & C++ but only
		    ** documented for C++.
		    */
		    if (eq_islang(EQ_C) && dml_islang(DML_ESQL) && *(cp+1) &&
		       (STbcompare(ERx("extension="), 3, cp, 10, TRUE) == 0))
		    {
			while (*cp != '=' && *cp)
			    cp++;
			if (*cp == '=' && *(cp+1))
			{
			    eq->eq_def_out = cp+1;
			    cp = empty;
			}
			else
			    eq_help( TRUE, *cp, '\0', '\0', '\0' );
			break;
		    }
		    /* Fall through */
		  case 'l':
		    eq->eq_flags |= EQ_LIST;
		    if (cp[1] == 'o')
		    {
			eq->eq_flags |= EQ_LSTOUT;
			cp++;
		    }
		    break;
		  case 'd':
		    eq->eq_flags |= EQ_IIDEBUG;
		    break;
		  case 'c':
		    if (!eq_islang(EQ_C))
			eq_help( TRUE, *cp, '\0', '\0', '\0' );
		    /*
		    ** Check for Embedded C flags: 
		    **	-c		! Compatlib flag
		    **	-ch[eck_eos]	! Check for end of string (ESQL/C only)
		    **  -cp[lusplus]	! Turn on C++ preprocessor (Internal)
		    **			!   Note: "-cplusplus" can be removed
		    **			!   if we ever start building
		    **			!   a separate executable for ESQL/C++.
		    **			!   This flag should NEVER be exposed
		    **			!   to the user.
		    */
                    if (dml_islang(DML_ESQL))
		    {
			char w_str[FE_PROMPTSIZE];
			STlcopy(cp, w_str, FE_PROMPTSIZE - 1);
			CVlower(w_str);
			/*
			** Check for '-c' flag here so we don't
			** get confused with the '-check_eos'
			** flag later on
			*/
			if (STcompare(ERx("c"), w_str) == 0)
			{
		    	    eq->eq_flags |= EQ_COMPATLIB;
			    break;
			}
			if (STbcompare(ERx("check_eos"), 0, w_str, 
							  9, TRUE) == 0)
			{
			    eq->eq_flags |= EQ_CHREOS;
			    cp = empty;
			    break;
			}
			else if (STbcompare(ERx("cplusplus"), 0, w_str, 
							  9, TRUE) == 0)
			{
			    eq->eq_lang = EQ_CPLUSPLUS;

			    /* Set default file extensions for C++ */

			    /* Porting hint: if you want the defaults
			    ** for the output files to be different,
			    ** modify the esqlcc script not this code */

			    eq->eq_def_in = ERx("scc");
			    eq->eq_def_out = ERx("cc");
			    eq->eq_in_ext = ERx("scc");
			    eq->eq_out_ext = ERx("cc");
			    cp = empty;
			    break;
			}
			else
			{
			    eq_help( TRUE, *cp, '\0', '\0', '\0' );
			    break;
			}
		    }
		    eq->eq_flags |= EQ_COMPATLIB;
		    break;
		  case 'q':
		    eq->eq_flags |= EQ_QRYTST;
		    break;
		  case 'r':
		    if (!eq_islang(EQ_BASIC))
			eq_help( TRUE, *cp, '\0', '\0', '\0' );
		    if (*++cp == '4')
			gr_mechanism( GR_LENFIX, ERx("real"), (i4)4 );
		    else if (*cp == '8')
			gr_mechanism( GR_LENFIX, ERx("real"), (i4)8 );
		    else
			eq_help( TRUE, cp[-1], *cp, '\0', '\0' );
		    break;
		  case 'n':
		    if (cp[1] == '\0')
			eq_help( TRUE, cp[0], '\0', '\0', '\0' );
		    if (cp[1] == 'o')
		    {
			char w_str[FE_PROMPTSIZE];
			cp++; cp++; /* skip the 'no' */
			STlcopy(cp, w_str, FE_PROMPTSIZE - 1);
			CVlower(w_str);

			/* -no??? flag processing goes here */
			if ((STcompare(ERx("sqlcode"), w_str) == 0) 
				&& (dml_islang(DML_ESQL)))
			{
			    eq->eq_flags |= EQ_NOSQLCODE;
			    cp = empty;
			}
			else if (   (STcompare(ERx("blank_pad"), w_str) == 0)
				 && eq_islang(EQ_C) && dml_islang(DML_ESQL))
			{
			    eq->eq_flags &= ~EQ_CHRPAD;
			    cp = empty;
			}
			else if (   (STcompare(ERx("check_eos"), w_str) == 0)
				 && eq_islang(EQ_C) && dml_islang(DML_ESQL))
			{
			    eq->eq_flags &= ~EQ_CHREOS;
			    cp = empty;
			}
			else if (   (STcompare(ERx("prototypes"), w_str) == 0)
				 && eq_islang(EQ_C) && dml_islang(DML_ESQL)
				 && !eq_islang(EQ_CPLUSPLUS))
			{
			    eq_private &= ~P_EQ_CPROTOS;
			    cp = empty;
			}
		    }
		    else if (*++cp == '.')
			cp++;			/* Skip the '.' */
		    eq->eq_in_ext = cp;		/* Might be empty */
		    cp = empty;
		    break;
		  case 'o':
		    if (0 == STncmp(ERx("olen="),cp,5))
		    {
			if ( eq_islang(EQ_FORTRAN) )
			{
			    /* Give the user an ability to set the
			    ** output record length
			    */
			    CVan(&cp[5], &eq->eq_outrec_len);
			    cp = empty;
			}
			else
			{
			    eq_help( FALSE, '\0', '\0', '\0', '\0' );
			}
		    }
		    else if (cp[1] == '\0')
		    {
			eq->eq_flags |= EQ_INCNOWRT;
                    }
		    else
		    {
			if (*++cp == '.')
			    cp++;		/* Skip the '.' */
			eq->eq_out_ext = cp;	/* Might be empty */
			cp = empty;
		    }
		    break;
		  case 'i':		/* Can be used for C too */
		    if (!eq_islang(EQ_FORTRAN) && !eq_islang(EQ_C) &&
			!eq_islang(EQ_BASIC))
			eq_help( TRUE, *cp, '\0', '\0', '\0' );
		    else
		    {
			char  *int_str = 
			    eq_islang(EQ_C) ? ERx("int") : ERx("integer");

			if (*++cp == '1')
			    gr_mechanism( GR_LENFIX, int_str, (i4)1 );
			else if (*cp == '2')
			    gr_mechanism( GR_LENFIX, int_str, (i4)2 );
			else if (*cp == '4')
			    gr_mechanism( GR_LENFIX, int_str, (i4)4 );
			else
			    eq_help( TRUE, cp[-1], *cp, '\0', '\0' );
		    }
		    break;
		  case 'w':
		    {
			char w_str[FE_PROMPTSIZE];
			STlcopy(cp+1, w_str, FE_PROMPTSIZE - 1);
			CVlower(w_str);
		        if (cp[1] == '\0')
			{
			    eq->eq_flags |= EQ_VERSWARN;
			}
			else if ((STcompare(ERx("open"), w_str) == 0) 
				&& (dml_islang(DML_ESQL)))
			{
			    eq->eq_flags |= EQ_COMMON;
			    cp = empty;
			}
			/* As per INGRES command flag conventions, allow
			** abbreviated command flags until they are unique, 
			** i.e:
			**	-wsql=e[ntry_sql92]
			**	-wsql=o[pen]
			*/
			else if ((STbcompare(ERx("sql="), 4, w_str, 4, TRUE)
				== 0) && (dml_islang(DML_ESQL)))
			{
			    if (w_str[4] == '\0')
			    {
			    	eq_help( TRUE, cp[-1], *cp, '\0', '\0' );
			        cp = empty;
			    }
			    if (STbcompare(ERx("entry_sql92"), 0, w_str+4,
								11, TRUE) == 0)
			    {	
			    	eq->eq_flags |= EQ_FIPS;
			    	cp = empty;
			    }	
			    else if (STbcompare(ERx("open"), 0, w_str+4, 
								4, TRUE) == 0)
			    {
			    	eq->eq_flags |= EQ_COMMON;
			    	cp = empty;
			    }	
			    else
			    {
			    	eq_help( TRUE, cp[-1], *cp, '\0', '\0' );
			        cp = empty;
			    }
			}
			else 
			{
			    eq_help( TRUE, cp[-1], *cp, '\0', '\0' );
			    cp = empty;
			}
			break;
		    }
		  case 'f':
		    if (cp[1])
		    {
			eq->eq_outname = cp+1;
			cp = empty;
		    } else
		    {
			eq->eq_outfile = stdout;
			eq->eq_flags |= EQ_STDOUT;
		    }
		    break;
		  case 's':
		    {
			char w_str[FE_PROMPTSIZE];
			STlcopy(cp+1, w_str, FE_PROMPTSIZE - 1);
			CVlower(w_str);
			if (STcompare(ERx("qlcode"), w_str) == 0) 
			{
			    if(dml_islang(DML_ESQL))
			    {
				eq->eq_flags |= EQ_SQLCODE;
			    	cp = empty;
			    }
			    else
			    {
				eq_help( TRUE, cp[-1], *cp, '\0', '\0' );
				cp = empty;
			    }
			}
			else	 /* anything else, assume -s */
			{
			    eq->eq_flags |= EQ_STDIN;
			    *inp_file = NULL;
			}
			break;
		    }
		  case 't':		/* trace flag -- dump output */
		    if (cp[1] == 'o')
		    {
			eq_private |= P_EQ_DOUTPUT;
			cp++;
		    } else if (cp[1] == 'l')
		    {
			eq_private |= P_EQ_DLIST;
			cp++;
		    } else
			eq_help( TRUE, *cp, cp[1], '\0', '\0' );
		    break;
		  case '#':
		  case 'p':
		    /* Look first for '-p' or '#' */
		    if (!cp[1])
		    {
		     	eq->eq_flags |= EQ_SETLINE;
		    	break;
		    }
		    /*
		    ** Check for Embedded C only flag: 
		    **	-pr[ototypes]	
		    */
		    if (eq_islang(EQ_C) && !(eq_islang(EQ_CPLUSPLUS)) &&
			dml_islang(DML_ESQL) && 
			(STbcompare(ERx("prototypes"), 2, cp, 10, TRUE) == 0))
		    {
			eq_private |= P_EQ_CPROTOS;
			cp = empty;
			break;
		    }
		    else
			eq_help( TRUE, *cp, cp[1], '\0', '\0' );
		    break;
		  case 'A':	/* Cap A for ABF - do not display */
		    eq_private |= P_EQ_ABF;
		    break;
		  case 'a':
		    if (eq->eq_lang != EQ_COBOL && eq->eq_lang != EQ_ADA)
			eq_help( FALSE, *cp, '\0', '\0', '\0' );
		    else if (eq->eq_lang == EQ_COBOL)
			eq->eq_flags |= EQ_FMTANSI;
		    else			/* Ada -avads or -avax */
		    {
			char	adabuf[6];

			STlcopy(cp+1, adabuf, 5);
			CVlower(adabuf);
			if (STcompare(adabuf, "vads") == 0)
			{
			    eq->eq_config = EQ_ADVADS;
			    cp += 4;
			}
			else if (STcompare(adabuf, "vax") == 0)
			{
			    eq->eq_config = EQ_ADVAX;
			    cp += 3;
			}
			else if (STcompare(adabuf, "alsys") == 0)
			{
			    eq->eq_config = EQ_ADALSYS;
			    cp += 5;
			}
			else if (STcompare(adabuf, "gnat") == 0)
			{
			    eq->eq_config = EQ_ADGNAT;
			    cp += 4;
			}
			else
			    eq_help( TRUE, *cp, '\0', '\0', '\0' );
		    }
		    break;
		  case 'u':
		    if (eq->eq_lang != EQ_COBOL)
			eq_help( FALSE, *cp, '\0', '\0', '\0' );
		    else
			eq->eq_config = EQ_COBUNS;
		    break;
		  case 'h':
		    inc_add_inc_dir( cp+1 );
		    cp = empty;
		    break;
		  case 'm':
		    if ((eq_islang(EQ_C)||eq_islang(EQ_ADA)) &&
			dml_islang(DML_ESQL) && *(cp+1) &&
		       (STbcompare(ERx("multi"), 0, cp, 5, TRUE) == 0))
		    {
			eq->eq_flags |= EQ_MULTI;
			cp = empty;
		    }
		    else
			eq_help( TRUE, *cp, '\0', '\0', '\0' );
		    break;
#if defined(UNIX) && defined(conf_BUILD_ARCH_32_64)
		  case 'g':
		    if ( (STbcompare(ERx("g64"), 3, cp, 3, TRUE) == 0) &&
		         (eq_islang(EQ_FORTRAN)) )
		    {	        
                        eq->eq_flags |= EQ_FOR_DEF64;   
			cp = empty;
		    }	        
                    else
                        eq_help( TRUE, *cp, '\0', '\0', '\0' );
		    break;	
#endif /* UNIX && hybrid */ 
		  case '-':
		  case '?':
		    eq_help( FALSE, *cp, '\0', '\0', '\0' );
		    break;
		  default:
		    eq_help( TRUE, *cp, '\0', '\0', '\0' );
		    break;
		} /* switch (*cp) */
		CMnext(cp);
	    } /* while (*++cp) */
	} else /* if (*cp == '-') */
	{
	    *inp_file = cp;
	    arg++;		/* to fix termination adjustment */
	    break;
	} /* not (*cp == '-') */
    } /* while (cp = *arg++) */

    gr_mechanism( GR_SYMINIT );	/* here so that the "-cir" flags can work */
    *argv = --arg;
    return OK;
}

/*
** Procedure:	equel
** Purpose:	Process the named file.
** Parameters:
**	inp_name	- char *	- The name of the file to process
**					  (NULL means stdin).
** Return Values:
**	STATUS
**	OK		- Successfully preprocessed the file.
-*	FAIL		- Couldn't open the file.
** Notes:
**	- If inp_name is NULL then read from stdin and write to stdout.
**	- Else if eq->eq_outname is non-NULL then that name must be used
**	  for the output file; if it is NULL then generate the output file
**	  name from the input name (and set eq->eq_outname to it).
**
** Imports modified:
**	None.
**
*/

STATUS
equel( inp_name )
char	*inp_name;
{
    char	dumbuf[MAX_LOC+1],
		in_fbuf[MAX_LOC+1],
		in_f_file[MAX_LOC+1],
		in_f_ext[MAX_LOC+1],
		out_fbuf[MAX_LOC+1],
		list_fbuf[MAX_LOC+1];
    LOCATION	in_loc,
    		out_loc,
		list_loc;
    FILE	*in_f,
    		*out_f,
		*list_f;
    STATUS	opened;
    static bool	seen_filename = FALSE;

    eq->eq_listfile = NULL;

    /* Disallow trailing flags */
    if (   seen_filename
	&& (eq->eq_flags & EQ_STDIN) == 0
	&& inp_name == NULL)
    {
	er_write( E_EQ000A_TRAIL_FLAG, EQ_WARN, 0 );
	return OK;
    }

    seen_filename = TRUE;
    if (inp_name == NULL)	/* pretend -s if no file name */
	eq->eq_flags |= EQ_STDIN;
  /* conflicting dump options? */
    if ((eq_private & P_EQ_DLIST) && (eq_private & P_EQ_DOUTPUT))
    {
	er_write( E_EQ0004_eqTRACEFL, EQ_FATAL, 1, dml_lang );
    }

    /*
    ** process input file first
    */

    if (eq->eq_flags & EQ_STDIN)
    {
	in_f = eq->eq_infile = stdin;
	STcopy( ERx("stdin"), in_fbuf );
	STcopy( ERx("stdin"), in_f_file );
	eq->eq_filename = ERx("stdin");
	eq->eq_ext = ERx("");
	LOfroms( FILENAME, in_fbuf, &in_loc );
    } else /* not (eq->eq_flags & EQ_STDIN) */
    {
      /* set up the input file */
	STcopy( inp_name, in_fbuf );
      /* test for filenames that are too long */
	if (LOfroms(PATH & FILENAME, in_fbuf, &in_loc) != OK)
	{
	    er_write( E_EQ0005_eqINFILE, EQ_FATAL, 2, dml_lang, inp_name );
	}
	LOdetail( &in_loc, dumbuf, dumbuf, in_f_file, in_f_ext, dumbuf );
	if (in_f_ext[0] == '\0')		/* no extension specified */
	{
	    _VOID_ STprintf( in_fbuf, ERx("%s.%s"), inp_name, eq->eq_def_in );
	    if (LOfroms(PATH & FILENAME, in_fbuf, &in_loc) != OK)
	    {
	        er_write( E_EQ0005_eqINFILE, EQ_FATAL, 2, dml_lang,
		    STprintf(in_fbuf, ERx("%s.%s"), inp_name, eq->eq_def_in) );
	    }
	    LOdetail( &in_loc, dumbuf, dumbuf, in_f_file, in_f_ext, dumbuf );
	}

      /* now open it */
	if (SIopen(&in_loc, ERx("r"), &in_f) != OK)
	{
	    er_write( E_EQ0005_eqINFILE, EQ_FATAL, 2, dml_lang, in_fbuf );
	}
	eq->eq_infile = in_f;
	eq->eq_filename = in_f_file;
	eq->eq_ext = in_f_ext;
    }

    /*
    ** now the input file is open, and inp_name is non-NULL if
    ** it was named.
    ** process the output file
    */

    if ((eq->eq_flags & EQ_STDOUT) && eq->eq_outname)
    {
	er_write( E_EQ0006_eqOUTOPT, EQ_FATAL, 1, dml_lang );
    }

    if ((eq->eq_flags & EQ_STDOUT) || (eq->eq_outname==NULL && inp_name==NULL))
    {
	out_f = eq->eq_outfile = stdout;
	eq->eq_outname = ERx("stdout");
	STcopy( ERx("stdout"), out_fbuf );
	LOfroms( FILENAME, out_fbuf, &out_loc );
    } else /* either input or output (or both) was specified (and not STDOUT) */
    {
	if (eq->eq_outname)
	{
	    STcopy( eq->eq_outname, out_fbuf );
	    LOfroms( PATH & FILENAME, out_fbuf, &out_loc );
	} else
	{
	  /* generate output file name from input one */
#ifndef hp9_mpe
	    LOcopy( &in_loc, out_fbuf, &out_loc );
	    _VOID_ STprintf( dumbuf, ERx("%s.%s"), in_f_file, eq->eq_def_out );
	    LOfstfile( dumbuf, &out_loc );
#else   /* hp9_mpe */
	    STprintf( out_fbuf, ERx("%s.%s"), in_f_file, eq->eq_def_out );
	    LOfroms( PATH & FILENAME, out_fbuf, &out_loc );
#endif  /* hp9_mpe */
	}

	/*
	** now we have both an input and an output name
	** and an input and an output location.
	** the input has been opened;
	** check to make sure that we don't overwrite the input file.
	*/

	eq_loc_compare( &in_loc, &out_loc, EQLOCINOUT );

      /* now we're ready to open (create) the output file */
	EQ_SI_OPEN_LANG( opened, &out_loc, ERx("w"), &out_f );
	if (opened != OK)
	{
	    char	*err_outname;
	    LOtos( &out_loc, &err_outname );
	    er_write( E_EQ0007_eqOUTFILE, EQ_FATAL, 2, dml_lang, err_outname );
	}
	eq->eq_outfile = out_f;
	LOtos( &out_loc, &eq->eq_outname );
#ifdef	PMFE											 
#ifndef WIN16  /* WIN16 must have all the protos from eqdefc.h anyway */
	if (eq_islang(EQ_C))  /* only emit C protos if C language */
	{
	   SIfprintf(out_f, "void * IILQdbl(double dblval);\n");	 
	   SIfprintf(out_f, "void * IILQint(long intval);\n");	 
	}
#endif  /* !WIN16 */
#else   /* !PMFE  */
#endif  /* !PMFE */
    }

  /* requested a listing; this is much like making an output file */
    if (eq->eq_flags & EQ_LIST)
    {
      /* generate list file name from input one */
#ifndef hp9_mpe
	LOcopy( &in_loc, list_fbuf, &list_loc );
# ifdef CMS
	_VOID_ STprintf( dumbuf, ERx("%s.%s"), in_f_file, ERx("listing") );
# else
	_VOID_ STprintf( dumbuf, ERx("%s.%s"), in_f_file, ERx("lis") );
# endif /* CMS */
	LOfstfile( dumbuf, &list_loc );
#else   /* hp9_mpe */
	_VOID_ STprintf( list_fbuf, ERx("%s.%s"), in_f_file, ERx("lis") );
	LOfroms( PATH & FILENAME, list_fbuf, &list_loc );
#endif  /* hp9_mpe */

	/*
	** now we have both an input and an output and a listing name
	** and an input and an output and a listing location.
	** the input and output has been opened; check
	** to make sure that we don't overwrite the input or output files.
	*/

	eq_loc_compare( &in_loc, &list_loc, EQLOCINLST );
	eq_loc_compare( &out_loc, &list_loc, EQLOCOUTLST );

      /* now we're ready to open (create) the listing file */
#ifdef hp9_mpe
	if (SIfopen( &list_loc, ERx("w"), SI_TXT, 256, &list_f) != OK)
#else  /* hp9_mpe */
	if (SIopen(&list_loc, ERx("w"), &list_f) != OK)
#endif /* hp9_mpe */
	{
	    char *err_listbuf;
	    LOtos( &list_loc, &err_listbuf );
	    er_write( E_EQ0008_eqLISTFILE, EQ_FATAL, 2, dml_lang, err_listbuf );
	}
	eq->eq_listfile = list_f;
    }

    /*
    ** Save include location of original parent file. (ncg)
    */
    inc_save(&in_loc);

    /*
    ** redirect dump output?
    ** -l bit is sticky, so -tl can be too.
    ** always an output file so -to can be sticky too.
    */

    if (eq_private & P_EQ_DLIST)
    {
	if (eq->eq_listfile)
	    eq->eq_dumpfile = eq->eq_listfile;
    } else if (eq_private & P_EQ_DOUTPUT)
	eq->eq_dumpfile = eq->eq_outfile;
    else
	eq->eq_dumpfile = stdout;

    if (eq->eq_flags & EQ_STDIN)
	SIprintf( ERx("%s\n"), 
	    IIUGfmt(dumbuf, (i4)MAX_LOC, ERget(F_EQ0002_eqINTACTBANNR),
		(i4)1, dml_lang) );
# ifndef	VMS
    else
	SIprintf( ERx("%s\n"),
	    IIUGfmt(dumbuf, (i4)MAX_LOC, ERget(F_EQ0003_eqBANNER),
		(i4)2, dml_lang, inp_name) );
# endif		/* VMS */

    if (eq->eq_flags & EQ_SETLINE)	/* EQC -# */
	gen_line( (char *)0 );		/* Note that we've started a file */
    if (   eq_islang(EQ_C) && (eq->eq_flags & EQ_FIPS))
    {
	if (!(eq->eq_flags & EQ_CHRPAD))
	{
	   er_write( E_EQ051F_FIPS_ESQLFLAG, EQ_WARN, 1, "-blank_pad");
	}
	if (!(eq->eq_flags & EQ_CHREOS))
	{
	   er_write( E_EQ051F_FIPS_ESQLFLAG, EQ_WARN, 1, "-check_eos");
	}
    }

    /*
    ** The .c file generated by ESQL/C needs a #include of the eqdef.h header.
    */
    if (dml_islang(DML_ESQL) && eq_islang(EQ_C) || \
	(dml_islang(DML_EQUEL) && eq_islang(EQ_C)))
    {
        LOCATION    loc;
        char        buf[MAX_LOC +1];
        char        *lname;

	/*
	** Choose correct header file(s) for INGRES runtime routines:
	**
	**	ESQL/C++ generates includes for:
	**	================================
	**	eqpname.h	Rename function call to prototyped name
	**	eqdefcc.h	Function prototypes for C++.
	**
	**	ESQL/C with -prototypes generates includes for:
	**	===============================================
	**	eqpname.h	Rename function call to prototyped name
	**	eqdefc.h	ANSI C function prototypes.
	**
	**	ESQL/C generates includes for:
	**	==============================
	**	eqdef.h		Old-style C function declarations
	*/
	if (eq_islang(EQ_CPLUSPLUS))
	{
#ifndef WIN16
            STcopy( ERx("eqpname.h"), buf );
	    NMloc( FILES, FILENAME, buf, &loc );
	    LOtos( &loc, &lname );
	    gen_include( lname, (char *)0, (char *)0 );
#endif /* WIN16 */
            STcopy( ERx("eqdefcc.h"), buf );
	}
	else if (eq_private & P_EQ_CPROTOS)
	{
#ifndef WIN16
            STcopy( ERx("eqpname.h"), buf );
	    NMloc( FILES, FILENAME, buf, &loc );
	    LOtos( &loc, &lname );
	    gen_include( lname, (char *)0, (char *)0 );
#endif /* WIN16 */
            STcopy( ERx("eqdefc.h"), buf );
	}
	else
            STcopy( ERx("eqdef.h"), buf );
        NMloc( FILES, FILENAME, buf, &loc );
        LOtos( &loc, &lname );
        gen_include( lname, (char *)0, (char *)0 );
    }

  /* now we've opened all of the files; go for it! */
    yyparse();

  /* clean up any include files, in case parsing failed */
    while (inc_is_nested() != SC_NOINC)
	inc_pop_file();

    /*
    ** close all output files (don't close stdout or stdin;
    ** that isn't good on some systems)
    */
    if (eq->eq_infile && (eq->eq_infile != stdin))
	SIclose( eq->eq_infile );
    if (eq->eq_outfile && (eq->eq_outfile != stdout))
	SIclose( eq->eq_outfile );
    if (eq->eq_listfile && (eq->eq_listfile != stdout))
	SIclose( eq->eq_listfile );
    if (eq->eq_dumpfile && (eq->eq_dumpfile != stdout))
	SIclose( eq->eq_dumpfile );

    gr_mechanism( GR_CLOSE );
    return OK;
}

/*
+* Procedure:	eqhandle
** Purpose:	Handle exceptions.
** Parameters:
**	ex	- EX_ARGS *	- Exception condition pointer.
** Return Values:
-*	i4	- EXRESIGNAL to propogate the exception.
** Notes:
**	Basically just clean up all the I/O, issue a message, and prepare
**	to exit.  If message wasn't successfully found by ERget at startup,
**	issue some English text.  Pop all of the include files.
**
** Imports modified:
**	Closes all the files we opened..
*/

i4
eqhandle( ex )
EX_ARGS	*ex;
{
    char	*f = eq->eq_filename;
    i4	l  = eq->eq_line;
    i4	exnum = ex->exarg_num;
    char	buf[MAX_LOC +1];

    if (exnum != EXQUIT)
    {
	while (inc_is_nested() != SC_NOINC)
	    inc_abort_file();
    }

    if (exnum == EXINTR)
	SIprintf(ERx("%s\n"), 
                 IIUGfmt(buf, (i4)MAX_LOC, abortmsg, (i4)1, dml_lang));
    if (eq->eq_listfile && (eq->eq_listfile != stdout))
	SIclose( eq->eq_listfile );
    if (eq->eq_outfile && (eq->eq_outfile != stdout))
	SIclose( eq->eq_outfile );
    if (eq->eq_dumpfile && (eq->eq_dumpfile != stdout))
	SIclose( eq->eq_dumpfile );
    if (exnum == EXEXIT
     || exnum == EXFATER
     || exnum == EXINTR
     || exnum == EXQUIT)
    {
	if (eq->eq_infile && (eq->eq_infile != stdin))
	    SIclose( eq->eq_infile );
	PCexit( er_exit() );
    }
#ifdef	UNIX
    if (eq->eq_outfile == stdout)
	SIprintf( ERx("\n") );		/* guarantee on a separate line */
#endif	/* UNIX */

    SIprintf( ERx("%s\n"), 
	IIUGfmt(buf, (i4)MAX_LOC, exc1msg, (i4)4, dml_lang, &exnum, f, &l) );
    if (eq->eq_line > 0)
	SIprintf( ERx("%s\n"), exc2msg );
    SIflush( stdout );
    PCexit(-1);
}

/*
+* Procedure:	eq_init
** Purpose:	Do per-file language-independent initialization.
** Parameters:
**	None.
** Return Values:
-*	None.
** Notes:
**	- These things must be done once before anything starts:
**	    eq->eq_flags = 0;
**	    eq->eq_dumpfile = stdout;
**	    eq->eq_listfile = NULL;
**	- gr_mechanism(GR_SYMINIT) must be called after you have diddled
**	  the pre-defined types table.
**	- Some language-dependent stuff must be done at the start;
**	  gr_mechanism(GR_EQINIT) does that stuff.
**
** Imports modified:
**	Initializes the scanner, the label manager, the parser, and eq.
*/

void
eq_init()
{
    sc_reset();
    lbl_init();
    gr_mechanism( GR_STMTFREE );
    eq->eq_outname = NULL;
    eq->eq_dumpfile = stdout;
    eq->eq_line = 0;		/* sc_readline increments before first token */
    eq->eq_outrec_len = -1;     /* Initialized to an invalid length          */
    dml->dm_exec = DML_HOST;		/* Always start out in host mode */
    ecs_clear();
    esqlca(sqcaINIT, 0, (char *)0);
}

/*
+* Procedure:	eq_help
** Purpose:	Print an (optional) error message and a help message, then exit.
** Parameters:
**	err	- bool	- If TRUE then print an error message.
**	c1 - c4	- char	- The chars of the offending flag argument.
** Return Values:
-*	None; this routine always exits.
** Notes:
**	If "err" then print an error message: bad option '-%s'
**	where "c1" to "c4" are the characters of the string, some
**	of which may be missing.  If any are missing, the last one
**	present must be '\0'.
**
** Imports modified:
**	None.
*/

/* the help language bit masks */
# define	H_C		(u_i2)0x01
# define	H_FORTRAN	(u_i2)0x02
# define	H_PASCAL	(u_i2)0x04
# define	H_BASIC		(u_i2)0x08
# define	H_COBOL		(u_i2)0x10
# define	H_ADA		(u_i2)0x40
# define	H_CPLUSPLUS	(u_i2)0x80
# define	H_ALL		\
		(u_i2)(H_C|H_FORTRAN|H_PASCAL|H_BASIC|H_COBOL|H_ADA| \
	 	       H_CPLUSPLUS)
# define	H_BUTADA	(u_i2)(H_ALL ^ H_ADA)

/* the help DML bit masks */
# define	D_EQUEL		(u_i2)1
# define	D_ESQL		(u_i2)2
# define	D_ALL		(u_i2)(D_EQUEL|D_ESQL)

/*
** the help text
*/

struct help_struct {
    u_i2	hs_dml;		/* bit mask of SMLs to which hs_msg applies */
    u_i2	hs_lang;	/* bit mask of langs to which hs_msg applies */
    char	*hs_msg;
};
static struct help_struct help_msg[] = {
 { D_ALL,   H_ALL,	NULL },		/* where FLAGS are */
 { D_ALL,   H_ALL,	NULL },		/* -l[o] */
 { D_ALL,   H_ALL,	NULL },		/* -d */
# ifndef MVS
 { D_ESQL,  H_CPLUSPLUS,NULL },		/* -extension= ESQL/C++ only */
 { D_EQUEL, H_ALL,	NULL },		/* -n.ext EQUEL */
 { D_ESQL,  H_FORTRAN,  NULL },         /* -olen=NNN   FORTRAN only   */
 { D_EQUEL, H_BUTADA,	NULL },		/* -o.ext EQUEL */
 { D_ESQL,  H_BUTADA,	NULL },		/* -o.ext ESQL */
 { D_ALL,   H_BUTADA,	NULL },		/* -o no inc out */
# endif
 { D_EQUEL, H_ALL,	NULL },		/* -f[filename] EQUEL */
 { D_ESQL,  H_ALL,	NULL },		/* -f[filename] ESQL */
# if defined(UNIX) && defined(conf_BUILD_ARCH_32_64)
 { D_ALL,   H_FORTRAN,	NULL },		/* -g64 Fortran 64 file EQUEL/ESQL */
# endif
 { D_ALL,   H_ALL,	NULL },		/* -s */
# ifndef WIN16   /* Windows 3.1 always needs prototypes */
 { D_ESQL,  H_C,	NULL },		/* -prototypes  */
# endif
 { D_ALL,   H_ALL,	NULL },		/* -w version warnings */
 { D_ESQL,  H_ALL,	NULL },		/* -wsql= standard SQL warnings */
 { D_ESQL,  H_ALL,	NULL },		/*  Valid standards are: */
 { D_ESQL,  H_ALL,	NULL },		/*   -wsql=entry_sql92 SQL92 warnings */
 { D_ESQL,  H_ALL,	NULL },		/*   -wsql=open SQL OPEN warnings */
 { D_ESQL,  H_ALL,	NULL },		/* -sqlcode */
 { D_ESQL,  H_ALL,	NULL },		/* -nosqlcode */
 { D_ESQL,  H_ALL,	NULL },	        /* -multi */   	
 { D_ALL,   H_BASIC,	NULL },		/* -rN realls */
 { D_ALL,   H_C|H_CPLUSPLUS|H_FORTRAN|H_BASIC,	NULL },	/* -iN ints */
 { D_ALL,   H_C,	NULL },		/* -#|p  ... to the C compiler */
 { D_ALL,   H_CPLUSPLUS,NULL },		/* -#|p  ... to the C++ compiler */
 { D_ALL,   H_COBOL, 	NULL },		/* -a ansi */
 { D_ALL,   H_ALL,	NULL },		/* -- or -? */
 { 0,	    0,	     	NULL }
};

/*
** VARARGS
*/

static struct {
    u_i2	h_lang;
    char	*h_suff;
    char	*h_name;
} help_langs[] = { 	/* Order as defined in eqlang.h */
    H_C,	ERx("c"),	ERx("C"),	/* EQ_C */	
    H_FORTRAN,	ERx("f"),	ERx("FORTRAN"),	/* EQ_FORTRAN */
    H_PASCAL,	ERx("p"),	ERx("PASCAL"),	/* EQ_PASCAL */	
    H_BASIC,	ERx("b"),	ERx("BASIC"),	/* EQ_BASIC */	
    H_COBOL,	ERx("cbl"),	ERx("COBOL"),	/* EQ_COBOL */	
    0,		NULL,		NULL,		/* Used to be PL/1 */
    H_ADA,	ERx("a"),	ERx("ADA"),	/* EQ_ADA */
    0,		NULL,  		NULL,		/* Skip OSL */
    0,		NULL,  		NULL,		/* Skip SQL */
    H_CPLUSPLUS,ERx("cc"),	ERx("C++"),	/* EQ_CPLUSPLUS */
};

void
eq_help( bool err, char c1, char c2, char c3, char c4 )
{
    struct help_struct *h;
    u_i2	h_lang = help_langs[eq->eq_lang].h_lang;
    u_i2	h_dml;
    char		*h_comm;
    char		buf[MAX_LOC];

    /* Initialize help_msg structure */
    h = help_msg;
    (h++)->hs_msg = ERget( F_EQ0008_eqFL0);
    (h++)->hs_msg = ERget( F_EQ0009_eqFL1);
    (h++)->hs_msg = ERget( F_EQ000A_eqFL2);
# ifndef MVS
    (h++)->hs_msg = ERget( F_EQ0023_eqFL27);
    (h++)->hs_msg = ERget( F_EQ000B_eqFL3);
    (h++)->hs_msg = ERget( F_EQ0037_eqOUTL);
    (h++)->hs_msg = ERget( F_EQ000C_eqFL4);
    (h++)->hs_msg = ERget( F_EQ000D_eqFL5);
    (h++)->hs_msg = ERget( F_EQ000E_eqFL6);
# endif
    (h++)->hs_msg = ERget( F_EQ000F_eqFL7);
    (h++)->hs_msg = ERget( F_EQ0010_eqFL8);
# if defined(UNIX) && defined(conf_BUILD_ARCH_32_64)
    (h++)->hs_msg = ERget( F_EQ0036_eqFL32);
# endif  /* option for generating 64-bit Fortran file on hybrid ports */ 
    (h++)->hs_msg = ERget( F_EQ0011_eqFL9);
# ifndef WIN16   /* Windows 3.1 always needs prototypes */
    (h++)->hs_msg = ERget( F_EQ0025_eqFL29);
# endif
    (h++)->hs_msg = ERget( F_EQ0012_eqFL10);
    (h++)->hs_msg = ERget( F_EQ001D_eqFL21);
    (h++)->hs_msg = ERget( F_EQ001E_eqFL22);
    (h++)->hs_msg = ERget( F_EQ001F_eqFL23);
    (h++)->hs_msg = ERget( F_EQ0020_eqFL24);
    (h++)->hs_msg = ERget( F_EQ0021_eqFL25);
    (h++)->hs_msg = ERget( F_EQ0022_eqFL26);
    (h++)->hs_msg = ERget( F_EQ0035_eqFL31);
    (h++)->hs_msg = ERget( F_EQ0015_eqFL13);
    (h++)->hs_msg = ERget( F_EQ0016_eqFL14);
    (h++)->hs_msg = ERget( F_EQ0017_eqFL15);
    (h++)->hs_msg = ERget( F_EQ0024_eqFL28);
    (h++)->hs_msg = ERget( F_EQ0018_eqFL16);
# ifdef UNIX
    (h++)->hs_msg = ERget( F_EQ001B_eqFL19);
# else
    (h++)->hs_msg = ERget( F_EQ001C_eqFL20);
# endif /* UNIX */

    if (dml_islang(DML_ESQL))
    {
	h_dml = D_ESQL;
	h_comm = ERx("esql");
    }
    else
    {
	h_dml = D_EQUEL;
	h_comm = ERx("eq");
    }

    if (err)
    {
    	char		e_buf[5];

    	e_buf[0] = c1;
    	e_buf[1] = c2;
    	e_buf[2] = c3;
    	e_buf[3] = c4;
    	e_buf[4] = '\0';

	er_write( E_EQ0009_eqBADOPT, EQ_ERROR, 2, dml_lang, e_buf );
    }

    SIprintf( ERx("%s\n"),
	IIUGfmt(buf, (i4)MAX_LOC, ERget(F_EQ0007_eqUSAGE), (i4)4, dml_lang,
            help_langs[eq->eq_lang].h_name, h_comm, 
	    help_langs[eq->eq_lang].h_suff ));
    for (h=help_msg; h->hs_msg; h++)
    {
    	if ((h->hs_lang & h_lang) && (h->hs_dml & h_dml))
	    SIprintf( ERx("%s\n"), h->hs_msg );
    }
    PCexit( FAIL );
}

/*
+* Procedure:	eq_loc_compare
** Purpose:	Compare two locations to see if they refer to the same object.
** Returns:
**	  Prints an error message and exits if they are the same;
**	  does nothing (and returns nothing) if they're different.
** Parameters:
**	a, b		- LOCATION *	- Pointers to the locations to compare.
**	flag		- i4  		- Indicates file type names to print.
** Return Values:
-*	None; this routine exits if the names compare equal.
** Notes:
**	Just compare the string names, don't bother with logical name
**	expansion (VMS) or [symbolic] links (UNIX) -- wait for a CL
**	routine to do that.
**
** Imports modified:
**	None.
*/

void
eq_loc_compare( a, b, flag )
LOCATION	*a,
		*b;
i4		flag;
{
    char	*a_p,
		*b_p;
    
    LOtos( a, &a_p );
    LOtos( b, &b_p );
    if (STcompare(a_p, b_p) == 0)
    {
	switch( flag ) {
	  case EQLOCINOUT:
	    er_write( E_EQ0011_eqSAMEFL1, EQ_FATAL, 1, a_p );
	    break;
	  case EQLOCINLST:
	    er_write( E_EQ0012_eqSAMEFL2, EQ_FATAL, 1, a_p );
	    break;
	  case EQLOCOUTLST:
	    er_write( E_EQ0013_eqSAMEFL3, EQ_FATAL, 1, a_p );
	    break;
	}
    }
}
