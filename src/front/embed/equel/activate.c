# include 	<compat.h>
# include	<st.h>		/* 6-x_PC_80x86 */
# include	<me.h>		/* 6-x_PC_80x86 */
# include	<si.h>
# include	<er.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<equel.h>
# include	<equtils.h>
# include	<eqsym.h>
# include	<eqgen.h>
# include	<eqstmt.h>
# include	<ereq.h>

/*
** Copyright (c) 2004 Actian Corporation
*/

/*
+* Filename:	ACTIVATE.C
** Purpose:	Maintains all the routines for managing Activate blocks.
**
** Defines:	act_open() 	     -  Setup queue for Activate.
**		act_string() 	     - 	Save a string for Activate.
**		act_var()	     -	Save a variable for Activate.
**		act_command()	     -  Return command value.
**		act_args()	     -  Save static ACTIVATE args (expl, valid).
**		act_num()	     -  Save static FRSKEY number variable.
**		act_add() 	     -	Add an Activate to the queue.
**		act_close()	     -	Write queue of buffered Activates in
**					specific format.
**		act_dump( all )	     - 	Dump contents of Activate queues for
**					debugging.
** Locals:
**		act_name()	     -  Add an Activate name to argman.
**		act_clrelm( act )    -  Clear out an Activate element.
**
** Used for Activate statements - to keep track of interrupt values for Display
-* loop Activate blocks, and independent Submenus.
**
** Note:
**	1. Replaces the old Activate.c before Equel was rewritten.
**	2. Activate blocks must be strictly nested to be able to free up
**	   the string table space, and the list of activate objects, without
**	   bothering another block.
**	3. Preprocessor Operation:
**	   A typical example would be this 3-line Display loop:
**
**	   ## display "form"
**	   ## activate menuitem "Menu":      { ...menu...   }
**	   ## activate column "Table" "Col": { ...column... }
**
**	   which generates (only the relevant code):
**
**	   ...start up form...
**	   goto IIfdinit1;
**   IIfdbegin1:
**	   while ( IIrunfrm() !=0 ) {
**	       if (IIretval() == 1) {		...interrupt value 1...
**		    ... menu...
**	       } else if (IIretval() == 2) {	...interrupt value 2...
**		    ...column...
**	       } else 
**		    goto IIfdEnd1;
**         }
**   IIfdinit1:					...generated by act_close...
**	   if (IIinitmu() == 0) goto IIfdEnd1;
**	   if (IIactmu( "Menu", 1) == 0) goto IIfdEnd1;  ..real object..
**	   if (IIactcol( "Table", "Col", 2) == 0) goto IIfdEnd1;
**	   if (IIendmu() == 0) goto IIfdEnd1;
**	   goto IIfdbegin1;
**   IIfdEnd1;
**
**	   This Activate manager buffers away the actual Activate objects 
**	   together with their corresponding interrupt values, to be dumped
**	   when the display loop is completely reduced by the grammar.  Each 
**	   interrupt value corresponds to the order of the Activate block in the
**	   display loop.  To avoid saving away the complete buffered statement,
**	   only a small part is saved away in the representation of an ACT_ELM.
**
** History:
**		20-sep-1984 	- Written (ncg)
**		30-jul-1985 	- Added support for ACTIVATE frskey, and
**				  an argument list. (ncg)
**		15-nov-1988	- Added support for ACTIVATE timeout (bjb)
**		05-may-1989	- Added support for entry activation (teresa)
**		09-aug-1989	- Added support for 8.0 keystroke interception
**				  by allowing 'activate frskey0' (only for -c
**				  command flag). (teresa)
**		16-nov-1989	- Added the ability to parameterize the FRSKEY
**				  number. (teresa)
**	11-Nov-1993 (tad)
**		Bug #56449
**		Replace %x with %p for pointer values where necessary.
**	23-apr-1996 (thoda04)
**		Added function prototype for static functions.
**		Added a cast for queue element argument.
**		
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
*/

/* 
** Activate argument list structure element.
** Syntax:	
**		(explanation = "string", validate = {0|1})
** Note:
**	Currently only used for FRSKEY or MENUITEM but can be extended to be 
** used for all types of ACTIVATE's.  See a description on how it is used 
** later on down.
*/

typedef struct {
	char		*aa_expl;	/* Explanation or temporary string */
	SYM		*aa_evar;	/* If expl is var then symbol entry */
	char		*aa_valid;	/* Validate = {0|1} */
	SYM		*aa_vvar;	/* If valid is var then symbol entry */
	char		*aa_activate;	/* Activate = {0|1} */
	SYM		*aa_avar;	/* If activate is var then sym entry */
	char		*aa_frskey;	/* ACTIVATE FRSKEY keynum */
	SYM		*aa_fvar;	/* If keynum is var then sym entry */
} ACT_ARGS;
# define	ACTvalDEF	ERx("2")   /* Default for validate value (3 state) */
# define	ACTkeyMAX	40

/* Activate statement structure element */

typedef struct {
	Q_ELM		a_qlink;	/* Queue manager stuff */
	i4		a_type;		/* Type (Menu, Field, Scroll, etc) */
	char		*a_name;	/* Variable name or string value   */
	SYM		*a_var;		/* If variable then symbol entry */
	i4		a_intrp;	/* Interrupt value 	   */
	i4		a_val;		/* Command, Scroll or entry activation value */
	ACT_ARGS	a_args;		/* Extra args (currently only frskey) */
} ACT_ELM;

# define	ACTNULL		(ACT_ELM *)0
 
/* Maximum number of nested blocks for any Equel statement */
# define	ACT_MAXBLOCKS	10

/* 
** The Activate string table uses at most buffers of ACT_STRMAX size to store 
** away menuitems and such.
*/

# define	ACT_STRMAX	300

static STR_TABLE	*act_st = STRNULL;
			

/*
** Activate Block (Nesting) Manager.
**
** With each display loop, or nested menu a queue of Activate objects is
** opened.  Thus there can be at most ACT_MAXBLOCK queues active on the stack 
** at a given time.  This is equivalent to the number of nested displays 
** / nested menus / nested activates.
** Note that this implementation assumes that all block type statements that
** use the local queue structure are strictly nested.
*/

typedef struct {
    i4		a_init;				/* Queue was initialized */
    Q_DESC	a_qdesc;			/* Real queue descriptor */
} ACT_DESC;

static		ACT_DESC	act_descs[ACT_MAXBLOCKS] ZERO_FILL;
# define	NOACTDESC	&act_descs[-1]
static  	ACT_DESC	*act_d = NOACTDESC;

/*
** ACT_ARGS -
**
** When parsing the target list (explanation, validate) then use this local
** object to add information to. In the future all ACTIVATE objects will allow
** for such information so generalize now.
**
** Currently this is how it works:  When the target list is being parsed then
** any right-hand values get put into act_locargs (see act_args and grammar 
** rule for act_aelm).  When the main ACTIVATE object is added (act_add) then 
** act_locargs is copied into act->a_args (and the local act_locargs is reset).
** Act->a_args is kept around till real dump time (act_close).  At any other
** time the contents of act_locargs is set to the default value (see act_args
** with FALSE as first arg).
*/

static		ACT_ARGS	act_locargs ZERO_FILL;	/* For real use */

/* For adding a name to the argument manager */
static		void		act_name(SYM *var, char *name);

/* When freeing a list of Activate blocks clear out each element */
static		i4		act_clrelm(ACT_ELM *act);


/* 
+* Procedure: 	act_open 
** Purpose:	Start up stuff neeeded for Activate blocks.
**
** Parameters: 	None
-* Returns: 	None
**
** Open up a queue to start adding menuitems, fields etc for a particular 
** display loop or nested menu.
*/

void
act_open()
{
    register ACT_DESC	*ad;
    register ACT_ELM	*act;

    if (act_st == STRNULL)		/* Get a string table */
	act_st = str_new( ACT_STRMAX );

    if ((ad = ++act_d) > &act_descs[ACT_MAXBLOCKS-1])
	er_write( E_EQ0303_actNEST, EQ_FATAL, 1, er_na(ACT_MAXBLOCKS) );

    if (!ad->a_init)
    {
	ad->a_init = 1;
	q_init( &ad->a_qdesc, sizeof(ACT_ELM) );
    }
    /* The first element should point at the first next free spot in strings */
    q_new( (ACT_ELM *), act, &ad->a_qdesc );
    act->a_name = str_mark( act_st );
    q_enqueue( &ad->a_qdesc, (Q_ELM *)act );
}

/*
+* Procedure:	act_var 
** Purpose:	Parser passed an Equel representation of the variable.
** 	     	Reformat the representation into a local buffer and store.
** Parameters: 	var	- SYM *	 - Variable to add.
**		id	- char * - Fully qualified name.
-* Returns: 	i4 *	- Pointer to an Activate object holding var information.
*/

i4  	*
act_var( var, id )
SYM		*var;
char		*id;
{
    register ACT_ELM 	*act;

    /* Save the Activate variable */
    if (var == (SYM *)0)
	act = (ACT_ELM *)act_string( id );
    else
    {
	q_new( (ACT_ELM *), act, &act_d->a_qdesc );
	act->a_var = var;
	act->a_name = str_add( act_st, id );
    }
    return (i4 *)act;
}


/*
+* Procedure:	act_string 
** Purpose:	A string constant or a plain identifier was parsed inside
**		an activate statement.  Fill up act element, and pass it
** 		back for later adding.
** Parameters: 	string 	- char * - String const to be part of Activate elem.
-* Returns: 	i4 * 	- Pointer to Activate object holding string constant.
*/

i4	 *
act_string( string )
char	*string;
{
    register ACT_ELM	*act;

    q_new( (ACT_ELM *), act, &act_d->a_qdesc );
    if (string == (char *)0)
	act->a_type = ACT_BADTYPE;
    else
	act->a_name = str_add( act_st, string );
    act->a_var = (SYM *)0;
    return (i4 *)act;
}


/*
+* Procedure:	act_command
** Purpose:	Maps string to command value.
** Parameters:
**	ctl	- char * - Control_xx string.
** Return Values:
-*	i4	- c_CTRLxx or -1 for error.
*/

i4
act_command( ctl )
register char	*ctl;
{
    static struct a_ctl { 
	char	*ac_str;
	i4	ac_com;
    } acoms[] =		{
	{ ERx("control_b"), c_CTRLB },
	{ ERx("control_f"), c_CTRLF },
	{ ERx("control_g"), c_CTRLG },
	{ ERx("control_z"), c_CTRLZ }
    };
    register struct a_ctl	*ac;
    register i4		i;

    for (ac = acoms, i = 0; i < 4; ac++, i++)
    {
	if (STbcompare(ctl, 9, ac->ac_str, 0, TRUE) == 0)
	    return ac->ac_com;
    }
    return (-1);
}
	

/*
+* Procedure:	act_args 
** Purpose:	Buffer away arguments for parsing target list of ACTIVATE.
**		(explanation = "string" , validate = {on|off})
** Parameters: 	add	- i4	    - Add to/Reset static storage.
**		action	- char *    - "explanation" or "validate".
**		name	- char *    - String value of action or name of var.
**		type	- i4	    - Type of name.
**		var	- SYM *	    - Variable pointer if any.
-* Returns: 	None
*/

void
act_args( add, action, name, type, var )
i4	add;
char	*action;		/* action = name */
char	*name;
i4	type;
SYM	*var;
{
    register ACT_ARGS	*aa = &act_locargs;	/* Act arg bufferer for later */

    if (!add)	/* Reset static buffer */
    {
	aa->aa_expl = (char *)0;
	aa->aa_evar = (SYM *)0;
	aa->aa_valid = ACTvalDEF;
	aa->aa_vvar = (SYM *)0;
	aa->aa_activate = ACTvalDEF;
	aa->aa_avar = (SYM *)0;
	aa->aa_frskey = (char *)0;		/* FRSKEY variable */
	aa->aa_fvar = (SYM *)0;
	return;
    }
    if (name == (char *)0)
    {
	er_write( E_EQ0306_actARGS, EQ_ERROR, 2, action, ERx("?NULL?") );
	return;
    }

    /* Add an action to the local argument buffer */
    if (STbcompare(action, 5, ERx("valid"), 5, TRUE) == 0)
    {
	if (type != T_INT)
	    er_write( E_EQ0059_grINT, EQ_ERROR, 1, name );
	else if (var)
	{
	    aa->aa_valid = str_add( act_st, name ); /* string or var name */
	    aa->aa_vvar = var;
	}
	else if (*name == '0' && *(name+1) == '\0')
	    aa->aa_valid = ERx("0");
	else if (*name == '1' && *(name+1) == '\0')
	    aa->aa_valid = ERx("1");
	else
	    er_write( E_EQ0306_actARGS, EQ_ERROR, 2, action, name );
    }
    else if (STbcompare(action, 4, ERx("expl"), 4, TRUE) == 0)
    {
	if (type != T_CHAR)
	    er_write( E_EQ0066_grSTR, EQ_ERROR, 1, name );
	else
	{
	    aa->aa_expl = str_add( act_st, name );	/* string or var name */
	    aa->aa_evar = var;
	}
    }
    else if (STbcompare(action, 4, ERx("acti"), 4, TRUE) == 0)
    {
	if (type != T_INT)
	    er_write( E_EQ0059_grINT, EQ_ERROR, 1, name );
	else if (var)
	{
	    aa->aa_activate = str_add( act_st, name ); /* string or var name */
	    aa->aa_avar = var;
	}
	else if (*name == '0' && *(name+1) == '\0')
	    aa->aa_activate = ERx("0");
	else if (*name == '1' && *(name+1) == '\0')
	    aa->aa_activate = ERx("1");
	else
	    er_write( E_EQ0306_actARGS, EQ_ERROR, 2, action, name );
    }
    else
	er_write( E_EQ0306_actARGS, EQ_ERROR, 2, action, name );
}

/*
+* Procedure:	act_num 
** Purpose:	Buffer away frskey number (in ACT_ARGS) if it is a variable.
**
**		Statement: ACTIVATE FRSKEY keynum ...
**
** Parameters: 	action	- char *    - "frskey"
**		name	- char *    - Name of var.
**		type	- i4	    - Type of name.
**		var	- SYM *	    - Variable pointer if any.
-* Returns: 	None
*/

void
act_num(  action, name, type, var )
char	*action;		/* action = name */
char	*name;
i4	type;
SYM	*var;
{
    register ACT_ARGS	*aa = &act_locargs;	/* Local arg buffer */

    if (name == (char *)0)
    {
	er_write( E_EQ0306_actARGS, EQ_ERROR, 2, action, ERx("?NULL?") );
	return;
    }

    /* Add a variable to the local argument buffer */
    if (STbcompare(action, 4, ERx("frsk"), 4, TRUE) == 0)
    {
	if (type != T_INT)
	    er_write( E_EQ0059_grINT, EQ_ERROR, 1, name );
	else if (var)
	{
	    aa->aa_frskey = str_add( act_st, name ); /* var name */
	    aa->aa_fvar = var;
	}
	else
	    er_write( E_EQ0306_actARGS, EQ_ERROR, 2, action, name );
    }	
    else
	er_write( E_EQ0306_actARGS, EQ_ERROR, 2, action, name );
}


/*

/*
+* Procedure:	act_add 
** Purpose:	Add an Activate element to the current list.  Assign the 
** 	     	interrupt values, and types for later dumping to output.
**
** Parameters: 	type	- i4  - Type of Activate object,
**		intrpval- i4  - Interrupt value for Activate statement,
**		mode	- i4  - Mode of Activate stmt (for Command and Scroll,
**				or entry activation for Field and Column),
**		actobj	- nat*- Pointer to already initialized Activate object.
-* Returns: 	None
*/

void
act_add( type, intrpval, mode, actobj )
i4  	type;
i4  	intrpval;
i4  	mode;
i4	*actobj;
{
    register ACT_ELM 	*act;

    if (act_d ==  NOACTDESC)
	return;

    switch (type)
    {
      case ACT_FRSKEY:
	if (mode > ACTkeyMAX || mode <= 0)
	{
	    /* Allow frskey0 only if -c command flag */	
	    if (!((mode == 0) && (eq->eq_flags & EQ_COMPATLIB)))
	    {
	        er_write( E_EQ015A_fsBADNUM, EQ_ERROR, 4, ERx("FRSKEY"), 
			  ERx("ACTIVATE"), er_na(ACTkeyMAX), ERx("FRSKEY1") );
	    	mode = 1;
	    }
	}
	/* Fall through */
      case ACT_COMMAND:
      case ACT_TIMEOUT:
      case ACT_EVENT:
	if ((act = (ACT_ELM *)actobj) == ACTNULL)
	    q_new( (ACT_ELM *), act, &act_d->a_qdesc );
	break;

      case ACT_FIELD:
      case ACT_MENU:
      case ACT_COLUMN:			/* There will be 2 for a column */
      case ACT_SCROLL:
	if ((act = (ACT_ELM *)actobj) == ACTNULL)
	{
	    er_write( E_EQ0304_actNULL, EQ_ERROR, 1, er_na(type) );
	    return;
	}
	/* If variable then type is CHAR, and is checked by grammar */
	break;

      default:
	er_write( E_EQ0301_actBAD, EQ_ERROR, 1, er_na(type) );
	type = ACT_BADTYPE;
	break;
    }
    if (act->a_type != ACT_BADTYPE)
	act->a_type = type;
    act->a_intrp = intrpval;
    act->a_val = mode;
    /* If act_args then add them here; later have all ACT's use them */
    MEcopy( (char *)&act_locargs, sizeof(ACT_ARGS), (char *)&act->a_args );
    q_enqueue( &act_d->a_qdesc, (Q_ELM *)act );
    act_args( FALSE, (char *)0, (char *)0, 0, (SYM *)0);
}

/*
+* Procedure:	act_close 
** Purpose:	Walk through the list of Activate elements for this current 
**	       	display loop, and write the corresponding function call to 
** 		output.  Free up the queue, and reserved string space when done.
**
** Parameters: 	form_no	- i4  - Form number for exit label.
-* Returns: 	None
*/

void
act_close( form_no )
i4	form_no;
{
    register ACT_ELM	*act;
    register ACT_ARGS	*aa;
    i4			mu_init = FALSE;	/* Menu was used */
    i4			timeout_seen = FALSE;	/* Catch >1 timeout blks */
    i4			onlyevent_seen =  -1;	/* Catch if only event blk */
    i4			err = FALSE;
    i4			act_func;		/* Function to write out */

    if (act_d ==  NOACTDESC || !act_d->a_init)
	return;
    /*
    ** The first element in the Activate list is a string space marker
    ** set up when the the display loop was started - act_open(), so skip
    ** it when traversing.
    */
    act = q_first( (ACT_ELM *), &act_d->a_qdesc );

    for (act = q_follow((ACT_ELM *), act); act != ACTNULL && !err; 
	 act = q_follow((ACT_ELM *), act))
    {
	aa = &act->a_args;
	switch(act->a_type)
	{
	  case ACT_COMMAND:				/* Command value */
	    arg_int_add( act->a_val );
	    act_func = IIACTCOMM;
	    break;

	  case ACT_FIELD:				/* Field name */
	    act_name( act->a_var, act->a_name );
	    arg_int_add( act->a_val);	/* entry activation */
	    act_func = IIACTFLD;
	    break;

	  case ACT_MENU:				/* Menu item */
	    if (!mu_init)		/* No menu yet - so initialize */
	    {
		mu_init = TRUE;
		gen_if_goto( IIINITMU, C_EQ, 0, L_FDEND, form_no );
	    }
	    act_name( act->a_var, act->a_name );
	    act_name( aa->aa_evar, aa->aa_expl );
	    if (aa->aa_vvar)
		arg_var_add( aa->aa_vvar, aa->aa_valid );
	    else 
		arg_str_add( ARG_INT, aa->aa_valid );
	    if (aa->aa_avar)
		arg_var_add( aa->aa_avar, aa->aa_activate );
	    else 
		arg_str_add( ARG_INT, aa->aa_activate );
	    act_func = IIACTMU;
	    break;

	  case ACT_SCROLL:
	    act_name( act->a_var, act->a_name );
	    arg_int_add( act->a_val );			/* 0/1 - Up/Down */
	    act_func = IIACTSCRL;
	    break;

	  case ACT_COLUMN:
	    {
		ACT_ELM	*nact;

		act_name( act->a_var, act->a_name );	/* Table name */
		nact = q_follow( (ACT_ELM *), act );
		if (nact == ACTNULL || nact->a_type != ACT_COLUMN)
		{
		    err = TRUE;
		    arg_str_add( ARG_CHAR, ERx("IIcol") );
		    er_write( E_EQ0302_actCOL, EQ_ERROR, 1, act->a_name );
		}
		else
		{
		    act_name( nact->a_var, nact->a_name ); /* Column name */
		    act = nact;
		}
	    	arg_int_add( act->a_val);	/* entry activation */
		act_func = IIACTCLM;
	    }
	    break;
	    
	  case ACT_FRSKEY:		/* FRS key */
	    if (eq->eq_flags & EQ_COMPATLIB)
	    {
	        arg_int_add( 0 );		/* Dummy argument */	
		gen_call (IIFRINTERNAL);	/* '-c' preprocessor flag on */
	    }	
	    if (aa->aa_fvar)			/* Key number variable */
		arg_var_add( aa->aa_fvar, aa->aa_frskey );
	    else 
	        arg_int_add( act->a_val );	/* Key number constant */
	    act_name( aa->aa_evar, aa->aa_expl );
	    if (aa->aa_vvar)
		arg_var_add( aa->aa_vvar, aa->aa_valid );
	    else 
		arg_str_add( ARG_INT, aa->aa_valid );
	    if (aa->aa_avar)
		arg_var_add( aa->aa_avar, aa->aa_activate );
	    else 
		arg_str_add( ARG_INT, aa->aa_activate );
	    act_func = IIACTFRSK;
	    break;

	  case ACT_TIMEOUT:
	    if (timeout_seen == TRUE)
		    er_write( E_EQ0308_actTIMEOUT, EQ_ERROR, 0 );
	    arg_int_add( 0 );		/* In future may be a timeout value */
	    act_func = IIACTTIME;
	    timeout_seen = TRUE;
	    break;

	  case ACT_EVENT:
	    /*  No other activate blks found so far? */
	    if (onlyevent_seen == -1)
		onlyevent_seen = 1;	/* Event might be only activate blk */
	    act_func = IIACTEVENT;
	    break;

	  case ACT_BADTYPE:
	  default:
	    er_write( E_EQ0301_actBAD, EQ_ERROR, 1, er_na(act->a_type) );
	    err = TRUE;
	    act_func = II0;
	    break;
	}
	if (act->a_type != ACT_EVENT)
	    onlyevent_seen = 0;

	if (act_func != II0)				/* Special error */
	{
	    arg_int_add( act->a_intrp );
	    gen_if_goto( act_func, C_EQ, 0, L_FDEND, form_no );
	}
    }
    if (mu_init)		/* There was a menu item */
	gen_if_goto( IIENDMU, C_EQ, 0, L_FDEND, form_no );

    /*
    ** It is illegal to have an event block in a display loop by
    ** itself.
    */
    if (onlyevent_seen == 1)
	er_write( E_EQ0311_actONLYEVENT, EQ_ERROR, 0);

    /* Free up the string space reserved by the firt element */
    act = q_first( (ACT_ELM *), &act_d->a_qdesc );
    str_free( act_st, act->a_name );
    /* Free up the queue used by this display loop */
    q_free( &act_d->a_qdesc, act_clrelm );
    if (act_d-- < act_descs)
    {
	act_d = NOACTDESC;
	er_write( E_EQ0305_actUNDFL, EQ_FATAL, 0 );
    }
}


/*
+* Procedure:	act_name 
** Purpose:	Add an Activate name to the argument manager.
**
** Parameters: 	var	- SYM * - Variable entry.
**		name	- char *- Name.
-* Returns: 	None
*/

static void
act_name( var, name )
SYM	*var;
char	*name;
{
    if (var)
	arg_var_add( var, name );
    else
	arg_str_add( ARG_CHAR, name );
}


/*
+* Procedure:	act_clrelm 
** Purpose:	Reset all Activate object fields before freeing. This is
**		called indirectly from the queue manager.
**
** Parameters: 	act	- ACT_ELM * - Activate object to clear.
-* Returns: 	1 / 0 	- Continue / stop.
*/

static i4
act_clrelm( act )
register ACT_ELM *act;
{
    if (act != ACTNULL)
    {
	act->a_name = (char *)NULL;
	act->a_var = (SYM *)NULL;
	act->a_type = ACT_NOTYPE;
	act->a_intrp = 0;
	act->a_val = 0;
	MEfill( sizeof(ACT_ARGS), '\0', (char *)&act->a_args );
	return 1;
    }
    return 0;
}


/*
+* Procedure:	act_dump 
** Purpose:	Walk through a specified queue of Activates (or all of them)
**	      	and dump there contents.
**
** Parameters: 	None
-* Returns: 	None
*/

void
act_dump()
{
    register ACT_ELM	*act;
    ACT_DESC		*cur_ad;
    register i4	ad_no;
    register i4	i;
    FILE		*df = eq->eq_dumpfile;
    i4			atype;
    static char		*anames[] = { ERx("BAD"), ERx("COM"), ERx("FLD"), 
				      ERx("MU"), ERx("COL"),
				      ERx("SCL(U=0/D=1)"), ERx("FRSK") };

    if (act_d == NOACTDESC)
	return;

    for (ad_no = 0, cur_ad = act_descs; cur_ad != act_d+1; cur_ad++, ad_no++)
    {
	SIfprintf( df, ERx("ACT_DUMP: Act Queue[%2d]\n"), ad_no );

	/*
	** First element in the Activate list is a string space marker.
	** Skip it when traversing.
	*/
	act = q_first( (ACT_ELM *), &cur_ad->a_qdesc );

	for (i = 1, act = q_follow((ACT_ELM *),act); act != ACTNULL; 
	     i++,   act = q_follow((ACT_ELM *),act))
	{
	    SIfprintf( df, ERx(" act[%2d]: act= 0x%p, var= 0x%p,"), 
		       i, act, act->a_var );
	    atype = act->a_type;
	    if (atype < ACT_NOTYPE || atype > ACT_FRSKEY)
		atype = ACT_NOTYPE;
	    SIfprintf( df, ERx(" type= %s,"), anames[atype] );
	    SIfprintf( df, ERx(" name= '%s',\n"), 
		act->a_name ? act->a_name : ERx("") );
	    SIfprintf( df, ERx("          val= %d, intrp= %d"), 
		       act->a_val, act->a_intrp );
	    if (atype == ACT_FRSKEY || atype == ACT_MENU)
	    {
		SIfprintf( df, ERx(", aa_expl= '%s', aa_evar= 0x%p"),
			   act->a_args.aa_expl ? act->a_args.aa_expl : ERx(""),
			   act->a_args.aa_evar );
		SIfprintf( df, ERx(", aa_val= %s, aa_vvar= 0x%p\n"),
			   act->a_args.aa_valid ? act->a_args.aa_valid : ERx(""),
			   act->a_args.aa_vvar );
	    }
	    else
		SIfprintf( df, ERx("\n") );
	}
    }
    if (act_st != STRNULL)
	str_dump( act_st, ERx("Act Strings") );
    SIflush( df );
}
