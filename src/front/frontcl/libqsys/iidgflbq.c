# include 	<compat.h>
# include	<er.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<generr.h>
# include	<eqlang.h>
# include	<eqrun.h>
# include	"erls.h"
# ifdef DGC_AOS

typedef struct
{
	short 	s_desc[4];
} DESC;
FUNC_EXTERN	char	*II_sdesc();

/*
** Copyright (c) 2004 Actian Corporation
*/

/*
+* Filename:	iidgflbq.c
** Purpose:	Runtime translation layer for DG ESQL/F77 programs only
**
** Defines:			Maps to:
**	IIERRTEST		IIerrtest
**	IIEXIT			IIexit
**	IIFLUSH			IIflush
**	IINGOPEN		IIngopen
**	IINEXTGET		IInextget
**	IINEXEC			IInexec
**	IIPARRET		IIparret
**	IIPARSET		IIparset
**	IIGETDOMIO		IIgetdomio
**	IIRETINIT		IIretinit
**	IIPUTDOMIO		IIputdomio
**	IINOTRIMIO		IIputdomio
**	IISEXEC			IIsexec
**	IISYNCUP		IIsyncup
**	IITUPGET		IItupget
**	IIUTSYS			IIutsys 
**	IIWRITIO		IIwritio
**	IICSCLOSE		IIcsClose
**	IICSDELETE		IIcsDelete
**	IICSERPLACE		IIcsERplace
**	IICSREPLACE		IIcsReplace
**	IICSOPEN		IIcsOpen
**	IICSQUERY		IIcsQuery
**	IICSRETRIEVE		IIcsRetrieve
**	IICSGETIO		IIcsGetio
**	IICSERETRIEVE		IIcsERetrieve
**	IIEXDEFINE		IIexDefine
**	IIEXEXEC		IIexExec
**	IIPUTCTRL		IIputctrl
**	IIXACT			IIxact
**	IICSRDO			IIcsRdO
**	IILQPRIPROCINIT		IILQpriProcInit
**	IILQPRSPROCSTATUS	IILQprsProcStatus
**	IILQPRSPROCVALIO	IILQprsProcValio	
**	IISETERR		IIseterr
**	IISQCONNECT		IIsqConnect
**	IISQDISCONNECT		IIsqDisconnect
**	IISQFLUSH		IIsqFlush
**	IISQINIT		IIsqInit
**	IISQLCDINIT		IIsqlcdInit
**	IISQGDINIT		IIsqGdInit
**	IISQSTOP		IIsqStop
**	IISQPRINT		IIsqPrint
**	IISQUSER		IIsqUser
**	IISQTPC			IIsqTPC
**	IILQSIDSESSID		IILQsidSessID
**	IISQXEXIMMED		IIsqExImmed
**	IISQEXSTMT		IIsqExStmt
**	IICSDAGET		IIcsDaGet
**	IISQMODS		IIsqMods
**	IISQPARMS		IIsqParms
**	IILQESEVSTAT		IILQesEvStat
**      IILQSSSETSQLIO          IILQssSetSqlio
**      IILQSIINQSQLIO          IILQisInqSqlio
**	IILQSHSETHANDLER	IILQshSetHandler
**	IILQLED_LOENDDATA	IILQled_LoEndData
-*
** Notes:
** 0)	Files in F77 runtime layer:
**		iidgflbq.c	- libqsys directory
**		iidgfrun.c	- runsys directory
**
** 1)   Purpose of F77 runtime layer:
**	The above files contain routines which map subroutine calls from a 
**	DG F77 program (i.e., generated by esqlf on DG) to our runtime system.
**
** 2)	F77 symbol conventions:
**	F77 subroutine names need translating because the F77 compiler upper
**	cases symbol names.  
**
** 3)   Parameter passing by reference:
**	The F77 compiler passes everything by reference, so this translation
**	layer also serves to dereference numerics and strings where necessary.
**	Sometimes an argument may be a numeric zero (a null pointer) or a 
**	string pointer.  (See IIflush, IIretinit, IIsyncup, IIutsys, IIfsetio 
**	IIprnscr, IIfrskact, IIthidecol).  This layer tests for a non-zero 
**	(sent by reference) before deciding whether to send the pointer 
**	or a zero.
**
** 4)   Null-terminated input strings:
**	This layer assumes that string variables which are SENDING data
**	to INGRES/forms system are blank padded.  String literals are
**	assumed to have had a null concatenated to them.  For literals,
**	the ESQL F77 code generator generates calls to IISD(). 
**	These routines return a pointer into a buffer where the string
**	has been copied and null terminated.  Since the compiler passes
**	everything by reference, this pointer is passed by reference
**	(char **) to these run time routines!!
**
**	IISD returns a pointer to the null terminated string.  On DG, the
**	string descriptor is passed after the parameter list which contains
**	the length of the string.  IISLEN (returns the length of a string)
**	also uses this string descriptor.
**
** 5)   String Lengths as parameters:
**	In those instances where string variables are being passed
**	for RECEIVING character data from INGRES/forms system, this
**	layer assumes that a host-language blank padded variable is used.
**	For those routines which return strings to host language variables
**	the interface layer must specify the type as DB_CHA_TYPE.  The system
**	blank pads the output to the length specified.
**
**
** 6)	External variable sent via IIaddform:
**	VIFRED has been changed for DG to have the form name in both upper (for
**	F77) and lower (other languages) cased when a form is compiled. 
**
** 7)   COMMONFORMAT:
**	All DG C code is compiled with commonformat.  Therefore all C routines
**	expect parameters to be byte pointers, regardless whether they are
**	a *char or a *nat.  DG F77 passes *char as byte pointers and *nat
**	as word pointer.  For this reason, all parameters are passed in as
**	unsigned nats, doubled and then casted to the correct datatype.
**	Char strings are doubly dereferenced because strings first
**	call IISD (to null terminate) which returns a *char.
**
** 8)   #ifdef DG_LIKE_INGRES.  This appears around new calls that
**	reflect INGRES-only functionality.  When and if this functionality
**	shows up in the DG dbms, these ifdefs can be removed.
**
** History:
**	11-may-89 (sylviap)   
**		Created from iiuflibq.c
**	29-sep-89 (barbara)
**		Integrated Unix porting changes.
**	20-dec-89 (barbara)
**		Updated for Phoenix/Alerters.  Added IILQesEvStat and
**		IILQegEvGetio.  Also added 6.3 calls IILQsidSessID and
**		IIsqTPC.
**	11-sep-90 (teresal)
**		Modified I/O calls to accept new decimal
**              data type DB_DEC_CHR_TYPE (53) which is a decimal
**              number encoded as a character string. For
**              completeness, all current I/O routines have been
**              updated.
**      26-feb-1991 (kathryn) Added:
**              IILQssSetSqlio, IILQisInqSqlio and IILQshSetHandler.
**	25-apr-1991 (teresal)
**		Removed IILQegEvGetio.
**	14-oct-1992 (lan)
**		Added IILQled_LoEndData.
**	16-dec-1992 (larrym)
**	    Added IIsqlcdInit and IIsqGdInit
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**      09-oct-2007 (huazh01)
**          Call IILQprsProcStatus() with correct number of parameter.
**          This fixes bug 119273.
*/
	

/*
** IIbreak
**	- ## endretrieve
**	- Generated to break retrieve loop
**	- should never be called on DG.
*/
void
IIBREAK()
{
    IIbreak();
}


/*
** IIerrtest
**	- Generated as test in retrieve loop
*/
i4
IIERRTEST()
{
    return IIerrtest();
}

/*
** IIexit
** 	- ## exit
*/
void
IIEXIT()
{
    IIexit();
}

/*
** IIflush
**	- Clean up at completion of retrieve
*/
void
IIFLUSH( t_file_name, t_line_num )
u_i4	t_file_name;
u_i4	t_line_num;
{
    char **file_name;
    i4	 *line_num;
    
    /* double pointer because of DG commonformat */
    line_num = (i4 *)(2 * t_line_num);
    file_name = (char **)(2 * t_file_name);

    if (*file_name)
	IIflush( file_name, *line_num );
    else
	IIflush( (char *)0, 0 );
}
/* 
** IIingopen 
**	- ## ingres <dbname> flags
** 	- Sends a variable number of arguments, up to a maximum of 14
**	  character string args plus language argument.
**	- For COBOL we assume an extra argument, which is a
**	  count representing the number of string args.  This is present
**	  on all calls which have a varying number of arguments.
**	  (See which calls go through gen_var_args in code generator.)
**	- should never be called on DG.
*/
void
IIINGOPEN( t_count, t_lan, t_arg1, t_arg2, t_arg3, t_arg4, t_arg5, t_arg6, 
	   t_arg7, t_arg8, t_arg9, t_arg10, t_arg11, t_arg12, t_arg13, t_arg14 )
u_i4	t_count, t_lan;
u_i4	t_arg1, t_arg2, t_arg3, t_arg4, t_arg5, t_arg6, t_arg7, t_arg8,
        t_arg9, t_arg10,t_arg11,t_arg12,t_arg13,t_arg14;
{
# define 	ING_ARGS_MAX	14
    char	*v_args[ING_ARGS_MAX];
    i4  	i;
    i4		*count, *lan;
    char	**arg1, **arg2, **arg3, **arg4, **arg5, **arg6, **arg7, **arg8,
                **arg9, **arg10,**arg11,**arg12,**arg13,**arg14;

    /* double pointer because of DG commonformat */
    count = (i4 *)(2 * t_count);
    lan = (i4 *)(2 * t_lan);
    arg1 = (char **)(2 * t_arg1);
    arg2 = (char **)(2 * t_arg2);
    arg3 = (char **)(2 * t_arg3);
    arg4 = (char **)(2 * t_arg4);
    arg5 = (char **)(2 * t_arg5);
    arg6 = (char **)(2 * t_arg6);
    arg7 = (char **)(2 * t_arg7);
    arg8 = (char **)(2 * t_arg8);
    arg9 = (char **)(2 * t_arg9);
    arg10 = (char **)(2 * t_arg10);
    arg11 = (char **)(2 * t_arg11);
    arg12 = (char **)(2 * t_arg12);
    arg13 = (char **)(2 * t_arg13);
    arg14 = (char **)(2 * t_arg14);
    
    for (i = 0; i < ING_ARGS_MAX; i++)
  	v_args[i] = (char *)0;		/* initialize arg array */

  /* 
  ** Enter this switch statement according to argument count.
  ** Fill v_args, starting at last arg and dropping through
  ** all subsequent ones until first arg
  */
    switch( *count - 1 ) {
	case 14:  v_args[13] = arg14;
	case 13:  v_args[12] = arg13;	
	case 12:  v_args[11] = arg12;	
	case 11:  v_args[10] = arg11;	
	case 10:  v_args[ 9] = arg10;	
	case  9:  v_args[ 8] = arg9;	
	case  8:  v_args[ 7] = arg8;	
	case  7:  v_args[ 6] = arg7;	
	case  6:  v_args[ 5] = arg6;	
	case  5:  v_args[ 4] = arg5;	
	case  4:  v_args[ 3] = arg4;	
	case  3:  v_args[ 2] = arg3;	
	case  2:  v_args[ 1] = arg2;	
	case  1:  v_args[ 0] = arg1;	
    }

    IIingopen( *lan, v_args[0], v_args[1], v_args[2], v_args[3], 
	v_args[4], v_args[5], v_args[6], v_args[7], v_args[8], v_args[9],
	v_args[10], v_args[11], v_args[12], v_args[13]); 
}

/*
** IInextget
**	- Checks to see if there's another tuple in retrieve loop
*/
i4
IINEXTGET()
{
    return IInextget();
}

/*
** IInexec
**	- Checks if repeat query successfully executed.
*/
i4
IINEXEC()
{
    return IInexec();
}

/*
** IIeqiqio
**	- ## inquire_equel statement
**	- Called once for each object being inquired about
**	- We must blank pad user var if result var is a string
*/
 
void
IIEQIQIO( t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr, t_inq_name )
u_i4	t_indflag;		/* 0 = no null pointer		*/
u_i4	t_indptr;		/* null pointer			*/
u_i4	t_isvar;		/* by value or reference	*/
u_i4	t_type;			/* type of user variable	*/
u_i4	t_len;			/* sizeof data, or strlen	*/
u_i4	var_ptr;
u_i4	t_inq_name;

{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;
        char	**inq_name;

   /* double pointer because of DG commonformat */
   indflag = (i4 *)(2 * t_indflag);
   indptr = (i2 *)(2 * t_indptr);
   isvar = (i4 *)(2 * t_isvar);
   type = (i4 *)(2 * t_type);
   len = (i4 *)(2 * t_len);
   inq_name = (char **)(2 * t_inq_name);

   if ( !*indflag )
      indptr = (i2 *)0;

   if (*type == DB_CHR_TYPE)
   {
      IIeqiqio( indptr, 1, DB_CHA_TYPE, *len, (char *)var_ptr, *inq_name );
   }
   else if (*type == DB_DEC_CHR_TYPE)
   {
      IIeqiqio( indptr, 1, *type, *len, (char *)var_ptr, *inq_name );
   }
   else
   {
      var_ptr = (2 * var_ptr);
      IIeqiqio( indptr, 1, *type, *len, var_ptr, *inq_name );
   }
}


/*
** IIeqstio
**	- ## set_equel command
*/
void
IIEQSTIO( t_setname, t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr )
u_i4	t_setname;		/* Object to set		*/
u_i4	t_indflag;		/* 0 = no null indicator	*/
u_i4	t_indptr;		/* null indicator pointer	*/
u_i4	t_isvar;		/* Always 1 for F77		*/
u_i4	t_type;			/* Type of user variable	*/
u_i4	t_len;			/* Sizeof data, or strlen	*/
u_i4	var_ptr;		/* Variable containing value	*/
{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;
	char	**setname;

     /* double pointer because of DG commonformat */
     indflag = (i4 *)(2 * t_indflag);
     indptr = (i2 *)(2 * t_indptr);
     isvar = (i4 *)(2 * t_isvar);
     type = (i4 *)(2 * t_type);
     len = (i4 *)(2 * t_len);
     setname = (char **)(2 * t_setname);

     if ( !*indflag )
 	indptr = (i2 *)0;
 
     if (*type == DB_CHR_TYPE)
     {
     	IIeqstio( *setname, indptr,  1, DB_CHR_TYPE, *len, (char *)var_ptr );
     }
     else if (*type == DB_DEC_CHR_TYPE)
     {
     	IIeqstio( *setname, indptr,  1, *type, *len, (char *)var_ptr );
     }
     else
     {
        var_ptr = (2 * var_ptr);
     	IIeqstio( *setname, indptr, 1, *type, *len, (i4 *)var_ptr );
     }
}
     
/*
** IIgetdomio
**	- Transfers data from retrieve statement into host-vars
** 	- When the receiving variable is a string, we must blank pad
*/
void
IIGETDOMIO( t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr )
u_i4	t_indflag;		/* 0 = no null indicator	*/
u_i4	t_indptr;		/* null indicator pointer	*/
u_i4	t_isvar;		/* Always 1 for F77		*/
u_i4	t_type;			/* Type of user variable	*/
u_i4	t_len;			/* Sizeof data, or strlen	*/
u_i4	var_ptr;		/* pointer to the object	*/
{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;

     /* double pointer because of DG commonformat */
     indflag = (i4 *)(2 * t_indflag);  
     indptr = (i2 *)(2 * t_indptr);
     isvar = (i4 *)(2 * t_isvar);
     type = (i4 *)(2 * t_type);
     len = (i4 *)(2 * t_len);

    if ( !*indflag )
	indptr = (i2 *)0;

    if (*type == DB_CHR_TYPE)
    {
	IIgetdomio( indptr, 1, DB_CHA_TYPE, *len, (char *)var_ptr );
    }
    else if (*type == DB_DEC_CHR_TYPE)
    {
	IIgetdomio( indptr, 1, *type, *len, (char *)var_ptr );
    }
    else
    {
        var_ptr = (2 * var_ptr);
	IIgetdomio( indptr, 1, *type, *len, var_ptr );
    }
}
		
/*
** IIretinit
** 	- Set up for retrieve loop
*/
void
IIRETINIT( t_file_name, t_line_num )
u_i4	t_file_name;
u_i4	t_line_num;
{
    char **file_name;
    i4	 *line_num;

    /* double pointer because of DG commonformat */
    line_num = (i4 *)(2 * t_line_num);
    file_name = (char **)(2 * t_file_name);

    IIretinit( *file_name, *line_num );
}

/*
** IIputdomio
**	- Transfers data to backend in database write statements
**	- Generated on ## append and ## replace
**	- Trims if len > 0.
*/
void
IIPUTDOMIO( t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr )
u_i4	t_indflag;		/* 0 = no null indicator	*/
u_i4	t_indptr;		/* null indicator pointer	*/
u_i4	t_isvar;		/* by value or reference	*/
u_i4	t_type;			/* type of object		*/
u_i4	t_len;			/* sizeof data, or strlen	*/
u_i4	var_ptr;		/* pointer to the object	*/
{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;

   /* double pointer because of DG commonformat */
   indflag = (i4 *)(2 * t_indflag);
   indptr = (i2 *)(2 * t_indptr);
   isvar = (i4 *)(2 * t_isvar);
   type = (i4 *)(2 * t_type);
   len = (i4 *)(2 * t_len);

    if ( !*indflag )
	indptr = (i2 *)0;

    if (*type == DB_CHR_TYPE)
    {
	IIputdomio( indptr, 1, DB_CHA_TYPE, *len, (char *)var_ptr );
    }
    else if (*type == DB_DEC_CHR_TYPE)
    {
	IIputdomio( indptr, 1, *type, *len, (char *)var_ptr );
    }
    else
    {
        var_ptr = (2 * var_ptr);
	IIputdomio( indptr, 1, *type, *len, var_ptr);
    }
}
/*
** IInotrimio
**	- Transfers data to backend in database write statements
**	- Generated on ## append and ## replace
**	- No trimming takes place
**	- Send as DB_CHR_TYPE so ADH will not trim trailing blanks.
*/
void
IINOTRIMIO( t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr )
u_i4	t_indflag;		/* 0 = no null indicator	*/
u_i4	t_indptr;		/* null indicator pointer	*/
u_i4	t_isvar;		/* by value or reference	*/
u_i4	t_type;			/* type of object		*/
u_i4	t_len;			/* sizeof data, or strlen	*/
u_i4	var_ptr;		/* pointer to the object	*/
{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;

   /* double pointer because of DG commonformat */
   indflag = (i4 *)(2 * t_indflag);
   indptr = (i2 *)(2 * t_indptr);
   isvar = (i4 *)(2 * t_isvar);
   type = (i4 *)(2 * t_type);
   len = (i4 *)(2 * t_len);

    if ( !*indflag )
	indptr = (i2 *)0;

    IIputdomio( indptr, 1, DB_CHR_TYPE, *len, (char *)var_ptr );
}

/*
** IIsexec
**	- Resets status flag during repeat query loop
*/
void
IISEXEC()
{
    IIsexec();
}

/*
** IIsyncup
**	- Generated after IIwrite calls to synch up with backend
*/
void
IISYNCUP( t_file_name, t_line_num )
u_i4	t_file_name;
u_i4	t_line_num;
{
    i4	 *line_num;
    char **file_name;

    /* double pointer because of DG commonformat */
    line_num = (i4 *)(2 * t_line_num);
    file_name = (char **)(2 * t_file_name);

    IIsyncup( *file_name, *line_num );
}

/*
** IItupget
**	- Generated in parameterized retrieves to get data into host_var.
*/
i4
IITUPGET()
{
    return IItupget();
}

/*
** IIutsys
**	- ## call <ingres subsystem>  (parameters)
*/
void
IIUTSYS( t_flag, t_arg, t_argstr )
u_i4	t_flag;
u_i4	t_arg;			/* Program/argument name */
u_i4	t_argstr;		/* Value of argument name */
{
   i4	*flag;
   char	**arg;			
   char	**argstr;	

   /* double pointer because of DG commonformat */
   flag = (i4 *)(2 * t_flag);
   arg = (char **)(2 * t_arg);
   argstr = (char **)(2 * t_argstr);

    IIutsys( *flag, *arg, *argstr ); 
}


/*
** IIwritio
**	- Writes a string to the backend
**	- Generated for most statements
*/
void
IIWRITIO( t_trim, t_indflag, t_indptr, t_isvar, t_type, t_len, t_string )
u_i4	t_trim;			/* trim flag, 0 = no trim	*/
u_i4	t_indflag;		/* 0 = no null pointer		*/
u_i4	t_indptr;		/* null pointer			*/
u_i4	t_isvar;		/* by value or reference	*/
u_i4	t_type;			/* type of data			*/
u_i4	t_len;			/* length of string		*/
u_i4	t_string;		/* actual string		*/
{
        i4	*trim;			
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;
	char	**string;		

   /* double pointer because of DG commonformat */
   trim = (i4 *)(2 * t_trim);
   indflag = (i4 *)(2 * t_indflag); 
   indptr = (i2 *)(2 * t_indptr);
   isvar = (i4 *)(2 * t_isvar);
   type = (i4 *)(2 * t_type);
   len = (i4 *)(2 * t_len);
   string = (char **)(2 * t_string);

    if ( !*indflag )
	indptr = (i2 *)0;

    IIwritio( *trim, indptr, *isvar, *type, *len, *string );
}

/*
** IIcsClose
**	- Close cursor
*/
void
IICSCLOSE( t_cursor_name, t_cid1, t_cid2 )
u_i4	 t_cursor_name;
u_i4	 t_cid1;			/* cursor id 1			*/
u_i4	 t_cid2;			/* cursor id 2			*/
{
   i4	*cid1;
   i4	*cid2;
   char **cursor_name;

   /* double pointer because of DG commonformat */
   cid1 = (i4 *)(2 * t_cid1);
   cid2 = (i4 *)(2 * t_cid2);
   cursor_name = (char **)(2 * t_cursor_name);

    IIcsClose( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsDelete
**	- Delete cursor
*/
void
IICSDELETE( t_table_name, t_cursor_name, t_cid1, t_cid2 )
u_i4	t_table_name;
u_i4	t_cursor_name;
u_i4	t_cid1;			/* cursor id 1			*/
u_i4	t_cid2;			/* cursor id 2			*/
{
   i4	*cid1;
   i4	*cid2;
   char	**table_name;
   char	**cursor_name;

   /* double pointer because of DG commonformat */
   cid1 = (i4 *)(2 * t_cid1);
   cid2 = (i4 *)(2 * t_cid2);
   cursor_name = (char **)(2 * t_cursor_name);
   table_name = (char **)(2 * t_table_name);

   IIcsDelete( *table_name, *cursor_name, *cid1, *cid2 );
}

/*
** IIcsERplace
**	- Cursor UPDATE/REPLACE end
*/
void
IICSERPLACE( t_cursor_name, t_cid1, t_cid2 )
u_i4	t_cursor_name;
u_i4	t_cid1;			/* cursor id 1			*/
u_i4	t_cid2;			/* cursor id 2			*/
{
   i4	*cid1;
   i4	*cid2;
   char	**cursor_name;

   /* double pointer because of DG commonformat */
   cid1 = (i4 *)(2 * t_cid1);
   cid2 = (i4 *)(2 * t_cid2);
   cursor_name = (char **)(2 * t_cursor_name);

   IIcsERplace( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsReplace 
**	- Cursor UPDATE/REPLACE begin
*/
void
IICSREPLACE( t_cursor_name, t_cid1, t_cid2 )
u_i4	t_cursor_name;
u_i4	t_cid1;			/* cursor id 1			*/
u_i4	t_cid2;			/* cursor id 2			*/
{
   i4	*cid1;
   i4	*cid2;
   char	**cursor_name;

   /* double pointer because of DG commonformat */
   cid1 = (i4 *)(2 * t_cid1);
   cid2 = (i4 *)(2 * t_cid2);
   cursor_name = (char **)(2 * t_cursor_name);

    IIcsReplace( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsOpen
**	- Cursor OPEN begin
*/
void
IICSOPEN( t_cursor_name, t_cid1, t_cid2 )
u_i4	t_cursor_name;
u_i4	t_cid1;			/* cursor id 1			*/
u_i4	t_cid2;			/* cursor id 2			*/
{
   i4	*cid1;
   i4	*cid2;
   char	**cursor_name;

   /* double pointer because of DG commonformat */
   cid1 = (i4 *)(2 * t_cid1);
   cid2 = (i4 *)(2 * t_cid2);
   cursor_name = (char **)(2 * t_cursor_name);

   IIcsOpen( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsQuery
**	- Cursor OPEN end
*/
void
IICSQUERY( t_cursor_name, t_cid1, t_cid2 )
u_i4	t_cursor_name;
u_i4	t_cid1;			/* cursor id 1			*/
u_i4	t_cid2;			/* cursor id 2			*/
{
   i4	*cid1;
   i4	*cid2;
   char	**cursor_name;

   /* double pointer because of DG commonformat */
   cid1 = (i4 *)(2 * t_cid1);
   cid2 = (i4 *)(2 * t_cid2);
   cursor_name = (char **)(2 * t_cursor_name);

   IIcsQuery( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsRetrieve
**	- Cursor FETCH begin
*/
i4
IICSRETRIEVE(t_cursor_name, t_cid1, t_cid2 )
u_i4	t_cursor_name;
u_i4	t_cid1;			/* cursor id 1			*/
u_i4	t_cid2;			/* cursor id 2			*/
{
   i4	*cid1;
   i4	*cid2;
   char	**cursor_name;

   /* double pointer because of DG commonformat */
   cid1 = (i4 *)(2 * t_cid1);
   cid2 = (i4 *)(2 * t_cid2);
   cursor_name = (char **)(2 * t_cursor_name);

   return IIcsRetrieve( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsGetio
**	- Cursor FETCH data into user variable
*/
void
IICSGETIO( t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr )
u_i4	t_indflag;		/* 0 = no null pointer		*/
u_i4	t_indptr;		/* null pointer			*/
u_i4	t_isvar;		/* by value or reference	*/
u_i4	t_type;			/* type of data			*/
u_i4	t_len;			/* sizeof data, or strlen	*/
u_i4	var_ptr;		/* pointer to user space	*/
{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;

   /* double pointer because of DG commonformat */
   indflag = (i4 *)(2 * t_indflag);
   indptr = (i2 *)(2 * t_indptr);
   isvar = (i4 *)(2 * t_isvar);
   type = (i4 *)(2 * t_type);
   len = (i4 *)(2 * t_len);

    if ( !*indflag )
	indptr = (i2 *)0;

    if ( *type == DB_CHR_TYPE )
    {
	IIcsGetio( indptr, 1, DB_CHA_TYPE, *len,(char *)var_ptr );
    }
    else if ( *type == DB_DEC_CHR_TYPE )
    {
	IIcsGetio( indptr, 1, *type, *len,(char *)var_ptr );
    }
    else
    {
        var_ptr = (2 * var_ptr);
	IIcsGetio( indptr, 1, *type, *len, var_ptr );
    }
}

/*
** IIcsERetrieve 
**	- Cursor FETCH end
*/
void
IICSERETRIEVE()
{
    IIcsERetrieve();
}

/*
** IIexDefine
**	- Repeat Query Definition
*/
void
IIEXDEFINE( t_type, t_name, t_qid1, t_qid2 )
u_i4	t_type;			/* type of repeat definition	*/
u_i4	t_name;			/* name of query		*/
u_i4	t_qid1;			/* query id 1			*/
u_i4	t_qid2;			/* query id 2			*/
{
   i4   *type;			
   i4	*qid1;
   i4	*qid2;
   char	**name;			

   /* double pointer because of DG commonformat */
   type = (i4 *)(2 * t_type);
   qid1 = (i4 *)(2 * t_qid1);
   qid2 = (i4 *)(2 * t_qid2);
   name = (char **)(2 * t_name);

   IIexDefine( *type, *name, *qid1, *qid2 );
}

/*
** IIexExec
**	- Repeat Query Execution
*/
void
IIEXEXEC ( t_type, t_name, t_qid1, t_qid2 )
u_i4	t_type;			/* type of repeat definition	*/
u_i4	t_name;			/* name of query		*/
u_i4	t_qid1;			/* query id 1			*/
u_i4	t_qid2;			/* query id 2			*/
{
   i4   *type;			
   i4	*qid1;
   i4	*qid2;
   char	**name;			

   /* double pointer because of DG commonformat */
   type = (i4 *)(2 * t_type);
   qid1 = (i4 *)(2 * t_qid1);
   qid2 = (i4 *)(2 * t_qid2);
   name = (char **)(2 * t_name);

   _VOID_ IIexExec( *type, *name, *qid1, *qid2 );
}

/*
** IIputctrl
**	- Place control character in the DBMS query string
*/
void
IIPUTCTRL( t_ctrl )
u_i4	t_ctrl;
{
   i4	*ctrl;

   /* double pointer because of DG commonformat */
   ctrl = (i4 *)(2 * t_ctrl);

   IIputctrl ( *ctrl );
}


/*
** IIxact
**	- Begin Transaction, Commit Transaction, End Transaction
*/
void
IIXACT( t_flag )
u_i4	t_flag;
{
   i4	*flag;

   /* double pointer because of DG commonformat */
   flag = (i4 *)(2 * t_flag);

   IIxact ( *flag );
}


/*
** IIvarstrio
**	- Send variable to the BE as string
*/
void
IIVARSTRIO( t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr )
u_i4	t_indflag;		/* 0 = no null pointer		*/
u_i4	t_indptr;		/* null pointer			*/
u_i4	t_isvar;		/* by value or reference	*/
u_i4	t_type;			/* type of data			*/
u_i4	t_len;			/* sizeof data, or strlen	*/
u_i4	var_ptr;		/* pointer to user space	*/
{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;

   /* double pointer because of DG commonformat */
   indflag = (i4 *)(2 * t_indflag);
   indptr = (i2 *)(2 * t_indptr);
   isvar = (i4 *)(2 * t_isvar);
   type = (i4 *)(2 * t_type);
   len = (i4 *)(2 * t_len);

    if ( !*indflag )
	indptr = (i2 *)0;

    if ( *type == DB_CHR_TYPE )
    {
	IIvarstrio( indptr, 1, DB_CHA_TYPE, *len, (char *)var_ptr );
    }
    else if ( *type == DB_DEC_CHR_TYPE )
    {
	IIvarstrio( indptr, 1, *type, *len, (char *)var_ptr );
    }
    else
    {
        var_ptr = (2 * var_ptr);
	IIvarstrio( indptr, 1, *type, *len, var_ptr );
    }
}


/*
** IIcsRdO
**	- Open cursor for Repeat Query readonly operations
*/
void
IICSRDO( t_flag, t_str )
u_i4	t_flag;
u_i4	t_str;
{
   i4	*flag;
   char	**str;

   /* double pointer because of DG commonformat */
   flag = (i4 *)(2 * t_flag);
   str = (char **)(2 * t_str);

   IIcsRdO( *flag, ERx("for readonly") );
}

/*
** IILQpriProcInit
**	- Create/Execute/Drop Procedure
*/
void
IILQPRIPROCINIT( t_type, t_name )
u_i4	t_type;
u_i4	t_name;
{
   i4	*type;
   char **name;

   /* double pointer because of DG commonformat */
   type = (i4 *)(2 * t_type);
   name = (char **)(2 * t_name);

    IILQpriProcInit( *type, *name );
}


/*
** IILQprsProcStatus
**	- EXECUTE PROCEDURE control flow
*/
i4
IILQPRSPROCSTATUS()
{
    return IILQprsProcStatus(0);
}

/*
** IILQprvProcValio
**	- EXECUTE PROCEDURE requiring i/o
*/
void
IILQPRVPROCVALIO( t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr )
u_i4	t_indflag;		/* 0 = no null pointer		*/
u_i4	t_indptr;		/* null pointer			*/
u_i4	t_isvar;		/* by value or reference	*/
u_i4	t_type;			/* type of data			*/
u_i4	t_len;			/* sizeof data, or strlen	*/
u_i4	var_ptr;		/* pointer to user space	*/
{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;

   /* double pointer because of DG commonformat */
   indflag = (i4 *)(2 * t_indflag);
   indptr = (i2 *)(2 * t_indptr);
   isvar = (i4 *)(2 * t_isvar);
   type = (i4 *)(2 * t_type);
   len = (i4 *)(2 * t_len);

    if ( !*indflag )
	indptr = (i2 *)0;

    if ( *type == DB_CHR_TYPE )
    {
	IILQprvProcValio( indptr, 1, DB_CHA_TYPE, *len, (char *)var_ptr );
    }
    else if ( *type == DB_DEC_CHR_TYPE )
    {
	IILQprvProcValio( indptr, 1, *type, *len, (char *)var_ptr );
    }
    else
    {
        var_ptr = (2 * var_ptr);
	IILQprvProcValio( indptr, 1, *type, *len, var_ptr );
    }
}

/*
** IIseterr
**	- user defined error function
*/
void
IISETERR( t_func )
u_i4	t_func;
{
   i4	*func;

   /* double pointer because of DG commonformat */
   func = (i4 *)(2 * t_func);

   IIseterr( func );
}

/*
** IIsqConnect
**	- error handling layer between ESQL program and IIingopen
** 	- Sends a variable number of arguments, up to a maximum of 15
**	  character string args plus language argument.
**	- we assume an extra first argument, which is a
**	  count representing the number of string args.  This is present
**	  on all calls which have a varying number of arguments.
**	  (See which calls go through gen_var_args in code generator.)
*/
void
IISQCONNECT( t_count, t_lan, t_arg1, t_arg2, t_arg3, t_arg4, t_arg5, t_arg6, 
	    t_arg7, t_arg8, t_arg9, t_arg10, t_arg11, t_arg12, t_arg13, 
	    t_arg14, t_arg15 )
u_i4	t_count, t_lan; 
u_i4	t_arg1, t_arg2, t_arg3, t_arg4, t_arg5, t_arg6, 
	t_arg7, t_arg8, t_arg9, t_arg10,t_arg11,t_arg12,
	t_arg13, t_arg14, t_arg15;
{
# define 	ING_ARGS_MAX	15
    char	*v_args[ING_ARGS_MAX];
    i4  	i;
    i4		*count, *lan; 
    char	**arg1, **arg2, **arg3, **arg4, **arg5, **arg6, **arg7, **arg8,
        	**arg9, **arg10,**arg11,**arg12,**arg13, **arg14, **arg15;

    /* double pointer because of DG commonformat */
    count = (i4 *)(2 * t_count);
    lan = (i4 *)(2 * t_lan);
    arg1 = (char **)(2 * t_arg1);
    arg2 = (char **)(2 * t_arg2);
    arg3 = (char **)(2 * t_arg3);
    arg4 = (char **)(2 * t_arg4);
    arg5 = (char **)(2 * t_arg5);
    arg6 = (char **)(2 * t_arg6);
    arg7 = (char **)(2 * t_arg7);
    arg8 = (char **)(2 * t_arg8);
    arg9 = (char **)(2 * t_arg9);
    arg10 = (char **)(2 * t_arg10);
    arg11 = (char **)(2 * t_arg11);
    arg12 = (char **)(2 * t_arg12);
    arg13 = (char **)(2 * t_arg13);
    arg14 = (char **)(2 * t_arg14);

    for (i = 0; i < ING_ARGS_MAX; i++)
  	v_args[i] = (char *)0;		/* initialize arg array */

  /* 
  ** Enter this switch statement according to argument count.
  ** Fill v_args, starting at last arg and dropping through
  ** all subsequent ones until first arg
  */
    switch( *count - 1 ) {
	case 15:  v_args[14] = *arg15;
	case 14:  v_args[13] = *arg14;
	case 13:  v_args[12] = *arg13;	
	case 12:  v_args[11] = *arg12;	
	case 11:  v_args[10] = *arg11;	
	case 10:  v_args[ 9] = *arg10;	
	case  9:  v_args[ 8] = *arg9;	
	case  8:  v_args[ 7] = *arg8;	
	case  7:  v_args[ 6] = *arg7;	
	case  6:  v_args[ 5] = *arg6;	
	case  5:  v_args[ 4] = *arg5;	
	case  4:  v_args[ 3] = *arg4;	
	case  3:  v_args[ 2] = *arg3;	
	case  2:  v_args[ 1] = *arg2;	
	case  1:  v_args[ 0] = *arg1;	
    }

    IIsqConnect( *lan, v_args[0], v_args[1], v_args[2], v_args[3], 
	v_args[4], v_args[5], v_args[6], v_args[7], v_args[8], v_args[9],
	v_args[10], v_args[11], v_args[12], v_args[13], v_args[14]); 
}

/*
** IIsqDisconnect
** 	- close up any open cursors before calling IIexit
*/
void
IISQDISCONNECT()
{
    IIsqDisconnect();
}


/*
** IIsqFlush
**	- processes sqlca  and resets error handling
*/
void
IISQFLUSH( t_file_name, t_lineno )
u_i4	t_file_name;
u_i4	t_lineno;
{
   i4	*lineno;
   char	**file_name;

   /* double pointer because of DG commonformat */
   lineno = (i4 *)(2 * t_lineno);
   file_name = (char **)(2 * t_file_name);

   IIsqFlush( *file_name, *lineno );
}

/*
** IIsqInit
**	- error handling layer between ESQL program and libq routines
*/
void
IISQINIT( sqlca )
u_i4	sqlca;
{
    
    IIsqInit( 2*sqlca );
}

/*
** IIsqlcdInit
**      - error handling layer between ESQL program and libq routines
*/
void
IISQLCDINIT( sqlca, sqlcode )
u_i4   sqlca;
u_i4   sqlcode;
{

    IIsqInit( 2*sqlca, 2*sqlcode );
}

/*
** IIsqUser
**      - simulates and saves a "-u" flag for use by IIsqConnect
*/
void
IISQGDINIT( t_sqltype, t_sqlstate )
u_i4   t_sqltype;
u_i4   t_sqlstate;
{
    i4	    *sqltype;
    char    **sqlstate;

    /* double pointer because of DG commonformat */
    sqltype = (i4 *)(2 * t_sqltype);
    sqlstate = (char **)(2 * t_sqlstate);

    IIsqGdInit( *sqltype, *sqlstate );
}

/*
** IIsqStop
**	- handles SQL STOP command 
*/
void
IISQSTOP( sqlca )
u_i4	sqlca;
{
    IIsqStop( 2*sqlca );
}

/*
** IIsqPrint
**	- in-house method of dumping error messages 
*/
void
IISQPRINT( sqlca )
u_i4	sqlca;
{
    IIsqPrint( 2*sqlca );
}

/*
** IIsqUser
**	- simulates and saves a "-u" flag for use by IIsqConnect
*/
void
IISQUSER( t_uname )
u_i4	t_uname;
{
    char    **uname;

    /* double pointer because of DG commonformat */
    uname = (char **)(2 * t_uname);

    IIsqUser( *uname );
}

#ifdef DG_LIKE_INGRES
/*
** IIsqTPC
**	- Passes in transaction id on connection made for Two-Phase Commit
*/
void
IISQTPC( t_highxid, t_lowxid )
u_i4 t_highxid, t_lowxid;
{
    i4		*highxid, *lowxid; 

    /* double pointer because of DG commonformat */
    highxid = (i4 *)(2 * t_highxid);
    lowxid = (i4 *)(2 * t_lowxid);

    IIsqTPC( *highxid, *lowxid );
}
#endif /* DG_LIKE_INGRES */

/*
** IILQsidSessID
**	- Pass Session ID on CONNECT statement
*/
void
IILQSIDSESSID( t_sessid )
u_i4	t_sessid;
{
    i4	*sessid;

    /* double pointer because of DG commonformat */
    sessid = (i4 *)(2 * t_sessid);
    IILQsidSessID( *sessid );
}

/*
** IIsqExImmed
**	- EXECUTE IMMEDIATE query
*/
void
IISQEXIMMED( t_qry_str )
u_i4	t_qry_str;
{
    char        **qry_str;

    /* double pointer because of DG commonformat */
    qry_str = (char **)(2 * t_qry_str);

    IIsqExImmed( *qry_str );
}

/*
** IIsqExStmt
**	- EXECUTE statement [USING ...]
*/
void
IISQEXSTMT( t_qry_str, t_using )
u_i4	t_qry_str;
u_i4	t_using;
{
    i4      *using;
    char    **qry_str;

    /* double pointer because of DG commonformat */
    using = (i4 *)(2 * t_using);
    qry_str = (char **)(2 * t_qry_str);

    IIsqExStmt( *qry_str, *using );
}


/*
** IIsqDaIn
**	- send descriptor of variables via IIputdomio
*/
void
IISQDAIN( t_lang, sqd )
u_i4   t_lang;
PTR 	*sqd;
{
    i4		*lang; 

    /* double pointer because of DG commonformat */
    lang = (i4 *)(2 * t_lang);

    /* DG does not support SQLDA so always pass NULL */
    IIsqDaIn( *lang, NULL );
}

/*
** IIsqPrepare
**	- Prepare and describe a statement
*/
void
IISQPREPARE( t_lang, t_stmt_str, t_sqd, t_using_fl, t_qry_str)
u_i4     t_lang;
u_i4	  t_stmt_str;
u_i4 	  t_sqd;
u_i4     t_using_fl;
u_i4	  t_qry_str;
{
    i4	    *lang; 
    i4      *using_fl;
    char    **qry_str;
    char    **stmt_str;

    /* double pointer because of DG commonformat */
    lang = (i4 *)(2 * t_lang);
    using_fl = (i4 *)(2 * t_using_fl);
    qry_str = (char **)(2 * t_qry_str);
    stmt_str = (char **)(2 * t_stmt_str);


    /* DG does not support SQLDA so always pass NULL */
    IIsqPrepare( *lang, stmt_str, NULL, *using_fl, qry_str );
}

/*
** IIsqDescribe
**	- Describe a statement into an SQLDA
*/
void
IISQDESCRIBE( t_lang, t_stmt_str, t_sqd, t_using_fl)
u_i4     t_lang;
u_i4	  t_stmt_str;
u_i4 	  t_sqd;
u_i4     t_using_fl;
{
    /* DG does not support SQLDA so just return */
}


/*
** IIcsDaGet
**	- Fetch values out via an SQLDA
*/
void
IICSDAGET( t_lang, sqd )
u_i4     t_lang;
PTR 	*sqd;
{
    i4	    *lang; 

    /* double pointer because of DG commonformat */
    lang = (i4 *)(2 * t_lang);

    /* DG does not support SQLDA so always pass NULL */
    IIcsDaGet( *lang, NULL );
}

/*
** IIsqMods
**	- Singleton Select or Gateway CONNECT WITH clause
*/
void
IISQMODS( t_flag )
u_i4	t_flag;
{
   i4	*flag;

   /* double pointer because of DG commonformat */
   flag = (i4 *)(2 * t_flag);

    IIsqMods( *flag );
}


/*
** IIsqParms
**	- Gateway WITH clause on CONNECT
*/
void
IISQPARMS( t_op_type, t_name, t_type, t_var_ptr, t_val )
u_i4	t_op_type;
u_i4	t_name;
u_i4	t_type;
u_i4	t_var_ptr;
u_i4	t_val;
{
    i4	 *op_type;
    i4	 *type;
    i4	 *val;
    char **var_ptr;
    char **name;

    /* double pointer because of DG commonformat */
    op_type = (i4 *)(2 * t_op_type);
    type = (i4 *)(2 * t_type);
    val = (i4 *)(2 * t_val);
    var_ptr = (char **)(2 * t_var_ptr); /* passed thru IIsd so need to double */
    name = (char **)(2 * t_name);

    IIsqParms( *op_type, *name, *type, *var_ptr, *val );
}

#ifdef DG_LIKE_INGRES
/*
** IILQesEvStat
**	- GET EVENT initializing/finalizing routine
*/
void
IILQESEVSTAT( t_flag, t_waitsecs )
u_i4	t_flag, t_waitsecs;
{
    i4	*flag, waitsecs;

    /* double pointer because of DG commonformat */
    flag = (i4 *)(2 * t_flag);
    waitsecs = (i4 *)(2 * t_waitsecs);

    IILQesEvStat( *flag, *waitsecs );
}

/*
** IILQSSSETSQLIO
**	- EXEC SQL SET_SQL statment
*/
void
IILQSSSETSQLIO( t_attr, t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr )
u_i4	t_attr;		/* Object to set		*/
u_i4	t_indflag;		/* 0 = no null indicator	*/
u_i4	t_indptr;		/* null indicator pointer	*/
u_i4	t_isvar;		/* Always 1 for F77		*/
u_i4	t_type;			/* Type of user variable	*/
u_i4	t_len;			/* Sizeof data, or strlen	*/
u_i4	var_ptr;		/* Variable containing value	*/
{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;
	i4	*attr;

     /* double pointer because of DG commonformat */
     indflag = (i4 *)(2 * t_indflag);
     indptr = (i2 *)(2 * t_indptr);
     isvar = (i4 *)(2 * t_isvar);
     type = (i4 *)(2 * t_type);
     len = (i4 *)(2 * t_len);
     attr = (i4 *)(2 * t_attr);

     if ( !*indflag )
 	indptr = (i2 *)0;
 
     if (*type == DB_CHR_TYPE)
     {
     	IILQssSetSqlio( *attr, indptr,  1, DB_CHR_TYPE, *len, (char *)var_ptr );
     }
     else
     {
        var_ptr = (2 * var_ptr);
     	IILQssSetSqlio( *attr, indptr, 1, *type, *len, (i4 *)var_ptr );
     }
}

/*
** IILQisInqSqlio
**	- EXEC SQL INQUIRE_SQL statement
**	- Called once for each object being inquired about
**	- We must blank pad user var if result var is a string
*/
 
void
IILQISINQSQLIO( t_indflag, t_indptr, t_isvar, t_type, t_len, var_ptr, t_attr )
u_i4	t_indflag;		/* 0 = no null pointer		*/
u_i4	t_indptr;		/* null pointer			*/
u_i4	t_isvar;		/* by value or reference	*/
u_i4	t_type;			/* type of user variable	*/
u_i4	t_len;			/* sizeof data, or strlen	*/
u_i4	var_ptr;
u_i4	t_attr;

{
	i4	*indflag;		
	i2	*indptr;	
	i4	*isvar;	
	i4	*type;
	i4	*len;
        i4	*attr;

   /* double pointer because of DG commonformat */
   indflag = (i4 *)(2 * t_indflag);
   indptr = (i2 *)(2 * t_indptr);
   isvar = (i4 *)(2 * t_isvar);
   type = (i4 *)(2 * t_type);
   len = (i4 *)(2 * t_len);
   attr = (i4 *)(2 * t_attr);

   if ( !*indflag )
      indptr = (i2 *)0;

   if (*type == DB_CHR_TYPE)
   {
      IILQISINQSQLIO( indptr, 1, DB_CHA_TYPE, *len, (char *)var_ptr, *attr );
   }
   else
   {
      var_ptr = (2 * var_ptr);
      IILQISINQSQLIO( indptr, 1, *type, *len, var_ptr, *attr );
   }
}

/*
** IILQshSetHandler
**      - EXEC SQL INQUIRE_INGRES (HANDLER = funcptr)
**        Where HANLDER can be ERRORHANDLER, MESSAGEHANDLER or EVENTHANDLER.
*/
void
IILQSHSETHANDLER(t_attr, t_func )
u_i4	t_attr;
u_i4   t_func;
{
   	i4  *func;
	i4  *attr;

	/* double pointer because of DG commonformat */

	func = (i4 *)(2 * t_func);
	attr = (i4 *)(2 * t_attr);

	IILQshSetHandler( *attr, func );
}


#endif /* DG_LIKE_INGRES */

/*
+* Procedure:	IIsd
** Purpose:	Convert string into blank trimmed C string.
** Parameters:
**	svar	- *char	- pointer to user's string variable
**	slen	- i4	- F77 supplied length of string var
** Return Values:
-*	Pointer into our temp buffer where the string was converted.
*/

char *
IISD( sstr, sdesc)
char	*sstr;
u_i4	sdesc;
{
	u_i4	len;
	DESC    *t_desc;

	t_desc = (DESC *)(2 * sdesc);
	len = t_desc->s_desc[2];
        return II_sdesc(0, sstr, len);
}

/*
** II_sdesc - Real convertion routine from user string to C string.
**
** Parameters:	flag --	What to do with converted string.
**		str  -- Host string.
**		len  -- Length of the string.
*/

char *
II_sdesc( flag, str, len  )
i4	flag;
char	*str;
i4	len;
{
/*
** Logic on size is to supply at least enough room for one name (usually < 20)
** plus space for data <= 2000.
** But in case the data does not fit, and we start from the beginning
** of the buffer, do not trash data of current call. Therefore
** allow up to 5000 to prevent trashing current data.
** Example:
**	putform f (f1=c700, f2=c2000)
**
**	used to give string table:
**
**		'f1' 'c700' 'f2' c2000 does not fit so wrap around and TRASH
**		previous data including 'f2'.
**
** 	If we have 5000 bytes then we cannot trash data of current call as the
**	only way we wrap around to the start is if the previous data is beyond
**	the middle.
*/
#   define 		MAXSTRING	255
#   define 		STRTABSIZE	2*MAXSTRING +2
    static		char	*str_buf = (char *)0;
    static		char	*str_ptr = (char *)0;

    i2			slen;
    char	 	*sptr;
    char 		locbuf[MAXSTRING +1];

    if ( str == NULL )
	return (char *)0;
    if (str_buf == NULL)	/* Alloc a buffer */
    {
	str_buf = (char *)MEreqmem(0, STRTABSIZE, TRUE, NULL);
	if ( str_buf == NULL )
	{
	    IIlocerr(GE_NO_RESOURCE, E_LS0101_SDALLOC, 0, 0 );
	    IIabort();
	}
	str_ptr = str_buf;			/* Reset roving pointer */
    }
    slen = STlcopy( str, locbuf, (i2)len );	/* Copy and 0 term */
    if (flag & II_TRIM)
       slen = STtrmwhite(locbuf);
    slen++;		/* to account for the null */
    /*
    ** Logic is if that is enough room not to trash previous data,
    ** then fit it in.  Otherwise readjust to start of buffer.  Note
    ** that when there are multiple args to a single call, these
    ** are usually very small anyway.
    */
    sptr = str_ptr;
    if ( str_ptr - str_buf + slen > STRTABSIZE )
	sptr = str_buf;
    MEcopy( locbuf, (u_i2)slen, sptr );
    str_ptr = sptr + slen;
    return sptr;
}

/*
+* Procedure:	IIslen
** Purpose:	Returns the length of a string in FORTRAN
** Parameters:
**	svar	- *char	- pointer to user's string variable
**	sdesc	- u_i4	- F77 supplied descriptor of string var
** Return Values:
-*	Integer length of string, not including the null terminator
*/

i4
IISLEN( svar, sdesc)
char	*svar;
u_i4	sdesc;
{
	DESC    *t_desc;

	t_desc = (DESC *)(2 * sdesc);
	return ( t_desc->s_desc[2]);
}

/*
+* Procedure:	IIstol
** Purpose:	Convert a short integer to an integer
** Parameters:
**	sint	- u_i4	- short integer
** Return Values:
-*	Pointer into our converted long integer
*/

i4  
IISTOL( t_sint)
u_i4	t_sint;
{
	short	*sint;		/* F77 short int */
	i4	lint;		/* long int */

    	/* double pointer because of DG commonformat */
    	sint = (short *)(2 * t_sint);

	lint = *sint;
        return (lint);
}
/*
** IILQled_LoEndData
**	EXEC SQL ENDDATA;
*/
void
IILQLED_LOENDDATA()
{
    IILQled_LoEndData();
}
# endif /* DGC_AOS */
